<?php

declare(strict_types=1);

/*
 * This file is part of the RegexParser package.
 *
 * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace RegexParser\Bridge\Symfony\Routing;

use RegexParser\NodeVisitor\LiteralExtractorVisitor;
use RegexParser\Parser;

/**
 * Utility for Symfony Routing integration.
 * Helps optimize route matching by extracting literal prefixes from regex patterns.
 *
 * Usage:
 *   $dumper = new RegexParserMatcherDumper();
 *   $snippet = $dumper->generateOptimizedMatcherCode([
 *       '/blog/posts/\d+' => 'BlogPostAction',
 *       '/api/v\d+/users' => 'ApiUserAction',
 *   ]);
 */
final class RegexParserMatcherDumper
{
    private Parser $parser;

    private LiteralExtractorVisitor $literalExtractor;

    public function __construct(?Parser $parser = null)
    {
        $this->parser = $parser ?? new Parser();
        $this->literalExtractor = new LiteralExtractorVisitor();
    }

    /**
     * Generate optimized PHP code for route matching using literal prefixes.
     *
     * This helps Symfony Routing avoid expensive regex matching for routes
     * that can be quickly eliminated by checking static prefixes first.
     *
     * @param array<string, string> $routePatterns Map of regex pattern => route name
     *
     * @return string Generated PHP code snippet
     */
    public function generateOptimizedMatcherCode(array $routePatterns): string
    {
        $code = "// Optimized route matching with literal prefix checks\n";
        $code .= "// Generated by RegexParserMatcherDumper\n\n";

        $routesByPrefix = $this->groupByLiteralPrefix($routePatterns);

        foreach ($routesByPrefix as $prefix => $routes) {
            if ('' === $prefix) {
                // Routes without a literal prefix - use regex directly
                foreach ($routes as $pattern => $name) {
                    $code .= \sprintf("\$route = %s; // Pattern: %s\n", var_export($name, true), $pattern);
                }

                continue;
            }

            // Generate optimized check with str_starts_with
            $code .= \sprintf("if (str_starts_with(\$path, %s)) {\n", var_export($prefix, true));
            $code .= "    // Literal prefix matched, now check full regex\n";

            foreach ($routes as $pattern => $name) {
                $code .= \sprintf("    if (preg_match(%s, \$path)) {\n", var_export($pattern, true));
                $code .= \sprintf("        \$route = %s;\n", var_export($name, true));
                $code .= "    }\n";
            }

            $code .= "}\n\n";
        }

        return $code;
    }

    /**
     * Group routes by their extracted literal prefixes.
     *
     * @param array<string, string> $routePatterns
     *
     * @return array<string, array<string, string>>
     */
    private function groupByLiteralPrefix(array $routePatterns): array
    {
        $grouped = [];

        foreach ($routePatterns as $pattern => $name) {
            try {
                $ast = $this->parser->parse($pattern);
                $literals = $ast->accept($this->literalExtractor);
                $prefix = reset($literals) ?: '';
            } catch (\Exception $e) {
                // If parsing fails, treat pattern as non-optimizable
                $prefix = '';
            }

            if (!isset($grouped[$prefix])) {
                $grouped[$prefix] = [];
            }

            $grouped[$prefix][$pattern] = $name;
        }

        return $grouped;
    }
}
