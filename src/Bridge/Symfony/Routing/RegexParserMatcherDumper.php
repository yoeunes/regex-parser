<?php

declare(strict_types=1);

/*
 * This file is part of the RegexParser package.
 *
 * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace RegexParser\Bridge\Symfony\Routing;

use RegexParser\NodeVisitor\LiteralExtractorNodeVisitor;
use RegexParser\Regex;

/**
 * Dumps a set of routes to a PHP class for faster matching.
 *
 * Purpose: This class is a specialized tool for Symfony's Routing component. Its goal is
 * to optimize route matching by pre-analyzing route patterns. It extracts mandatory literal
 * prefixes from the regex of each route. The generated PHP code then uses fast `str_starts_with`
 * checks to quickly discard non-matching routes before running the more expensive `preg_match`.
 * This is particularly effective in applications with many routes.
 */
class RegexParserMatcherDumper
{
    private readonly LiteralExtractorNodeVisitor $literalExtractor;

    private readonly Regex $regex;

    /**
     * Creates a new instance of the matcher dumper.
     *
     * Purpose: This constructor initializes the dumper with the necessary services for
     * parsing and analyzing regular expressions. As a contributor, you can see how the
     * core `Regex` service and the `LiteralExtractorNodeVisitor` are injected to be
     * used in the dumping process.
     */
    public function __construct()
    {
        $this->literalExtractor = new LiteralExtractorNodeVisitor();
        $this->regex = Regex::create();
    }

    /**
     * Generates optimized PHP code for route matching.
     *
     * Purpose: This is the main public method of the class. It takes a collection of route
     * patterns, groups them by their literal prefixes, and generates a PHP script snippet.
     * This snippet contains an optimized matching logic that prioritizes fast string
     * comparisons over immediate regex evaluation, which can significantly improve
     * performance for URL matching in a Symfony application.
     *
     * @param array<string, string> $routePatterns a map where the key is the route's full regex
     *                                             pattern and the value is the route's name or identifier
     *
     * @return string the generated PHP code snippet, ready to be written to a cache file
     *
     * @example
     * ```php
     * $dumper = new RegexParserMatcherDumper();
     * $code = $dumper->generateOptimizedMatcherCode([
     *     '#^/blog/(?P<slug>[a-z-]+)$#s' => 'blog_post',
     *     '#^/contact$#s' => 'contact_page',
     * ]);
     * // The generated $code will contain `if (str_starts_with($path, '/blog/'))` logic.
     * ```
     */
    public function generateOptimizedMatcherCode(array $routePatterns): string
    {
        $code = "// Optimized route matching with literal prefix checks\n";
        $code .= "// Generated by RegexParserMatcherDumper\n\n";

        $routesByPrefix = $this->groupByLiteralPrefix($routePatterns);

        foreach ($routesByPrefix as $prefix => $routes) {
            if ('' === $prefix) {
                // Routes without a literal prefix - use regex directly
                foreach ($routes as $pattern => $name) {
                    $code .= \sprintf("\$route = %s; // Pattern: %s\n", var_export($name, true), $pattern);
                }

                continue;
            }

            // Generate optimized check with str_starts_with
            $code .= \sprintf("if (str_starts_with(\$path, %s)) {\n", var_export($prefix, true));
            $code .= "    // Literal prefix matched, now check full regex\n";

            foreach ($routes as $pattern => $name) {
                $code .= \sprintf("    if (preg_match(%s, \$path)) {\n", var_export($pattern, true));
                $code .= \sprintf("        \$route = %s;\n", var_export($name, true));
                $code .= "    }\n";
            }

            $code .= "}\n\n";
        }

        return $code;
    }

    /**
     * Groups routes by their extracted literal prefixes.
     *
     * @param array<string, string> $routePatterns
     *
     * @return array<string, array<string, string>>
     */
    private function groupByLiteralPrefix(array $routePatterns): array
    {
        $grouped = [];

        foreach ($routePatterns as $pattern => $name) {
            try {
                $ast = $this->regex->parse($pattern);
                $literals = $ast->accept($this->literalExtractor);
                $prefix = $literals->getLongestPrefix() ?? '';
            } catch (\Exception) {
                // If parsing fails, treat pattern as non-optimizable
                $prefix = '';
            }

            $grouped[$prefix][$pattern] = $name;
        }

        return $grouped;
    }
}
