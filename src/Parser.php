<?php

declare(strict_types=1);

/*
 * This file is part of the RegexParser package.
 *
 * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace RegexParser;

use RegexParser\Exception\ParserException;
use RegexParser\Exception\RecursionLimitException;
use RegexParser\Exception\ResourceLimitException;
use RegexParser\Exception\SyntaxErrorException;

/**
 * The Parser.
 *
 * It transforms a stream of Tokens (from the Lexer) into an Abstract Syntax Tree (AST).
 * It implements a Recursive Descent Parser based on PCRE grammar.
 *
 * The Parser is independent of the Lexer and operates purely on a TokenStream.
 * Use the Regex class for convenient string-based parsing that handles
 * delimiter extraction, tokenization, and parsing automatically.
 */
final class Parser
{
    /**
     * Characters that can appear in inline flags.
     */
    private const INLINE_FLAG_CHARS = 'imsxADSUXJnr-';

    private const MAX_RECURSION_DEPTH = 1024;

    /**
     * Token stream (replaces array of tokens for memory efficiency).
     */
    private TokenStream $stream;

    /**
     * Original pattern string for contextual error reporting.
     */
    private string $pattern = '';

    /**
     * Regex flags (e.g., 'imsx').
     */
    private string $flags = '';

    /**
     * Whether the 'J' modifier is active (allows duplicate group names).
     */
    private bool $JModifier = false;

    /**
     * @var array<string, bool>
     */
    private array $groupNames = [];

    /**
     * Tracks if the last consumed token was an alternation.
     */
    private bool $lastTokenWasAlternation = false;

    /**
     * Length of the last inline flags processed.
     */
    private int $lastInlineFlagsLength = 0;

    private int $recursionDepth = 0;

    /**
     * Transforms a `TokenStream` into a structured Abstract Syntax Tree (AST).
     *
     * Purpose: This is the main entry point of the `Parser`. Its role is to consume the
     * flat list of tokens produced by the `Lexer` and organize them into a hierarchical
     * `RegexNode` tree that represents the logical structure of the regular expression.
     * This AST is the foundation upon which all other analysis, compilation, and
     * manipulation visitors operate. As a contributor, this is where you would start
     * to understand how the library interprets the token sequence.
     *
     * The parser uses a recursive descent strategy, with methods like `parseAlternation`
     * and `parseSequence` corresponding to the rules of the regex grammar.
     *
     * @param TokenStream $stream        the sequence of tokens generated by the `Lexer`
     * @param string      $flags         The regex flags (e.g., 'i', 'ms') that apply to the pattern.
     * @param string      $delimiter     The delimiter character (e.g., '/') used in the original regex string.
     * @param int         $patternLength the byte length of the original pattern string (used for root node metadata)
     *
     * @throws ParserException         If the token stream represents an invalid sequence according to the regex grammar
     *                                 (e.g., an unclosed group, a quantifier without a target).
     * @throws RecursionLimitException if the pattern is deeply nested and exceeds internal recursion limits
     * @throws ResourceLimitException  if the pattern is excessively large and exceeds node count limits
     *
     * @return Node\RegexNode the root node of the fully constructed AST
     *
     * @example
     * ```php
     * $lexer = new Lexer();
     * $tokenStream = $lexer->tokenize('a|b');
     *
     * $parser = new Parser();
     * $ast = $parser->parse($tokenStream, 'i', '/', 3);
     * // $ast is now a RegexNode containing an AlternationNode.
     * ```
     */
    public function parse(TokenStream $stream, string $flags = '', string $delimiter = '/', int $patternLength = 0): Node\RegexNode
    {
        // Set the stream for parsing
        $this->stream = $stream;
        $this->pattern = $stream->getPattern();
        $this->flags = $flags;
        $this->JModifier = str_contains($flags, 'J');
        $this->groupNames = [];
        $this->lastTokenWasAlternation = false;
        $this->lastInlineFlagsLength = 0;
        $this->recursionDepth = 0;

        // Parse the pattern content
        $patternNode = $this->parseAlternation();

        // Ensure we reached the end of the pattern
        $this->consume(TokenType::T_EOF, 'Unexpected content at end of pattern');

        return new Node\RegexNode($patternNode, $flags, $delimiter, 0, $patternLength);
    }

    /**
     * alternation -> sequence ( "|" sequence )*
     */
    private function parseAlternation(): Node\NodeInterface
    {
        $this->guardRecursionDepth($this->current()->position);
        $this->recursionDepth++;

        try {
            $startPosition = $this->current()->position;
            $nodes = [$this->parseSequence()];

            while ($this->match(TokenType::T_ALTERNATION)) {
                $this->lastTokenWasAlternation = true;
                $nodes[] = $this->parseSequence();
            }

            if (1 === \count($nodes)) {
                return $nodes[0];
            }

            // Calculate end position based on the last node
            $endPosition = end($nodes)->getEndPosition();

            return new Node\AlternationNode($nodes, $startPosition, $endPosition);
        } finally {
            $this->recursionDepth--;
        }
    }

    /**
     * sequence -> quantifiedAtom*
     */
    private function parseSequence(): Node\NodeInterface
    {
        $nodes = [];
        $startPosition = $this->current()->position;

        while (
            !$this->isAtEnd()
            && !$this->check(TokenType::T_GROUP_CLOSE)
            && !$this->check(TokenType::T_ALTERNATION)
        ) {
            // Handle silent tokens (Quote Mode)
            if (
                $this->match(TokenType::T_QUOTE_MODE_START)
                || $this->match(TokenType::T_QUOTE_MODE_END)
            ) {
                continue;
            }

            // Handle extended mode (x flag): skip whitespace and comments
            if (str_contains($this->flags, 'x')) {
                $skipped = false;
                while (!$this->isAtEnd() && !$this->check(TokenType::T_GROUP_CLOSE) && !$this->check(TokenType::T_ALTERNATION)) {
                    $token = $this->current();
                    if (TokenType::T_LITERAL === $token->type) {
                        if (ctype_space($token->value)) {
                            $this->advance();
                            $skipped = true;

                            continue;
                        }
                        if ('#' === $token->value) {
                            $this->advance(); // consume #
                            while (!$this->isAtEnd() && "\n" !== $this->current()->value) {
                                $this->advance();
                            }
                            if (!$this->isAtEnd() && "\n" === $this->current()->value) {
                                $this->advance();
                            }
                            $skipped = true;

                            continue;
                        }
                    }

                    break;
                }
                if ($skipped) {
                    continue;
                }
            }

            $nodes[] = $this->parseQuantifiedAtom();
        }

        if (empty($nodes)) {
            // "Empty" node at the current position
            return $this->createEmptyLiteralNodeAt($startPosition);
        }

        if (1 === \count($nodes)) {
            return $nodes[0];
        }

        $endPosition = end($nodes)->getEndPosition();

        return new Node\SequenceNode($nodes, $startPosition, $endPosition);
    }

    /**
     * quantifiedAtom -> atom ( QUANTIFIER )?
     */
    private function parseQuantifiedAtom(): Node\NodeInterface
    {
        $node = $this->parseAtom();

        if ($this->match(TokenType::T_QUANTIFIER)) {
            $token = $this->previous();

            $this->assertQuantifierCanApply($node, $token);

            [$quantifier, $type] = $this->parseQuantifierValue($token->value);

            $startPosition = $node->getStartPosition();
            $endPosition = $token->position + \strlen($token->value);

            return new Node\QuantifierNode($node, $quantifier, $type, $startPosition, $endPosition);
        }

        return $node;
    }

    /**
     * @return array{0: string, 1: Node\QuantifierType}
     */
    private function parseQuantifierValue(string $value): array
    {
        $lastChar = substr($value, -1);
        $baseValue = substr($value, 0, -1);

        if ('?' === $lastChar && \strlen($value) > 1) {
            return [$baseValue, Node\QuantifierType::T_LAZY];
        }

        if ('+' === $lastChar && \strlen($value) > 1) {
            return [$baseValue, Node\QuantifierType::T_POSSESSIVE];
        }

        return [$value, Node\QuantifierType::T_GREEDY];
    }

    /**
     * Asserts that a quantifier can be applied to the given node.
     */
    private function assertQuantifierCanApply(Node\NodeInterface $node, Token $token): void
    {
        if ($node instanceof Node\LiteralNode && '' === $node->value) {
            throw $this->parserException(
                \sprintf('Quantifier without target at position %d', $token->position),
                $token->position,
            );
        }

        if ($node instanceof Node\GroupNode && $this->isEmptyGroup($node)) {
            throw $this->parserException(
                \sprintf('Quantifier without target at position %d', $token->position),
                $token->position,
            );
        }

        if (
            $node instanceof Node\AnchorNode
            || $node instanceof Node\AssertionNode
            || $node instanceof Node\PcreVerbNode
            || $node instanceof Node\KeepNode
        ) {
            $nodeName = match (true) {
                $node instanceof Node\AnchorNode => $node->value,
                $node instanceof Node\AssertionNode => '\\'.$node->value,
                $node instanceof Node\PcreVerbNode => '(*'.$node->verb.')',
                default => '\K',
            };

            throw $this->parserException(
                \sprintf(
                    'Quantifier "%s" cannot be applied to assertion or verb "%s" at position %d',
                    $token->value,
                    $nodeName,
                    $node->getStartPosition(),
                ),
                $token->position,
            );
        }
    }

    /**
     * Checks if a group node is effectively empty (i.e., contains no meaningful content).
     */
    private function isEmptyGroup(Node\GroupNode $node): bool
    {
        $child = $node->child;

        return ($child instanceof Node\LiteralNode && '' === $child->value)
            || ($child instanceof Node\SequenceNode && empty($child->children));
    }

    /**
     * atom -> T_LITERAL | T_CHAR_TYPE | ...
     */
    private function parseAtom(): Node\NodeInterface
    {
        $token = $this->current();
        $startPosition = $token->position;

        // Comments (emitted by Lexer) must be parsed into CommentNode
        if ($this->match(TokenType::T_COMMENT_OPEN)) {
            return $this->parseComment();
        }

        if ($this->match(TokenType::T_CALLOUT)) {
            return $this->parseCallout();
        }

        // Quote Mode markers might leak here if sequence parsing logic didn't catch them all.
        // We consume them silently and recurse to get the next real atom.
        if (
            $this->match(TokenType::T_QUOTE_MODE_START)
            || $this->match(TokenType::T_QUOTE_MODE_END)
        ) {
            return $this->parseAtom();
        }

        if (null !== $node = $this->parseSimpleAtom($startPosition)) {
            return $node;
        }

        if (null !== $node = $this->parseGroupOrCharClassAtom($startPosition)) {
            return $node;
        }

        if (null !== $node = $this->parseVerbAtom($startPosition)) {
            return $node;
        }

        // Special case: quantifier without target
        if ($this->check(TokenType::T_QUANTIFIER)) {
            throw $this->parserException(
                \sprintf('Quantifier without target at position %d', $this->current()->position),
                $this->current()->position,
            );
        }

        // @codeCoverageIgnoreStart
        $val = $this->current()->value;
        $type = $this->current()->type->value;

        throw $this->parserException(
            \sprintf('Unexpected token "%s" (%s) at position %d.', $val, $type, $startPosition),
            $startPosition,
        );
        // @codeCoverageIgnoreEnd
    }

    /**
     * Parses "simple" atoms: literals, escapes, char types, unicode, octal, \p{}, \K, \g, etc.
     *
     * Returns null if the current token does not start any of these atoms.
     */
    private function parseSimpleAtom(int $startPosition): ?Node\NodeInterface
    {
        if ($this->match(TokenType::T_LITERAL)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value);

            return new Node\LiteralNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_LITERAL_ESCAPED)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value) + 1; // +1 for the backslash

            return new Node\LiteralNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_CHAR_TYPE)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value) + 1; // +1 for the backslash

            return new Node\CharTypeNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_DOT)) {
            return new Node\DotNode($startPosition, $startPosition + 1);
        }

        if ($this->match(TokenType::T_ANCHOR)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value);

            return new Node\AnchorNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_ASSERTION)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value) + 1;

            return new Node\AssertionNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_BACKREF)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value);

            return new Node\BackrefNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_G_REFERENCE)) {
            return $this->parseGReference($startPosition);
        }

        if ($this->match(TokenType::T_UNICODE)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value);

            return new Node\UnicodeNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_UNICODE_NAMED)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value) + 3; // +3 for \N{

            return new Node\UnicodeNamedNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_CONTROL_CHAR)) {
            $token = $this->previous();
            $endPosition = $startPosition + 3; // \cM

            return new Node\ControlCharNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_OCTAL)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value);

            return new Node\OctalNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_OCTAL_LEGACY)) {
            $token = $this->previous();
            $endPosition = $startPosition + \strlen($token->value) + 1;

            return new Node\OctalLegacyNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_UNICODE_PROP)) {
            $token = $this->previous();
            // Calculate end pos based on original syntax (\p{L} vs \pL)
            $len = 2 + \strlen($token->value); // \p or \P + value
            if (\strlen($token->value) > 1 || str_starts_with($token->value, '^')) {
                $len += 2; // for {}
            }
            $endPosition = $startPosition + $len;

            return new Node\UnicodePropNode($token->value, $startPosition, $endPosition);
        }

        if ($this->match(TokenType::T_KEEP)) {
            return new Node\KeepNode($startPosition, $startPosition + 2); // \K
        }

        return null;
    }

    /**
     * Parses group and character-class atoms: (...), (?...), [...].
     *
     * Returns null if none of those constructs start at the current token.
     */
    private function parseGroupOrCharClassAtom(int $startPosition): ?Node\NodeInterface
    {
        if ($this->match(TokenType::T_GROUP_OPEN)) {
            $startToken = $this->previous();
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_CAPTURING,
                $startToken->position,
                $endToken,
            );
        }

        if ($this->match(TokenType::T_GROUP_MODIFIER_OPEN)) {
            return $this->parseGroupModifier();
        }

        if ($this->match(TokenType::T_CHAR_CLASS_OPEN)) {
            return $this->parseCharClass();
        }

        return null;
    }

    /**
     * Parses PCRE verbs like (*ACCEPT), (*MARK:...), etc.
     *
     * Returns null if the current token is not a PCRE verb.
     */
    private function parseVerbAtom(int $startPosition): ?Node\NodeInterface
    {
        if (!$this->match(TokenType::T_PCRE_VERB)) {
            return null;
        }

        $token = $this->previous();
        $endPosition = $startPosition + \strlen($token->value) + 3; // +3 for "(*)"

        return new Node\PcreVerbNode($token->value, $startPosition, $endPosition);
    }

    /**
     * parses callouts like (?C1), (?C"name"), (?C"string"), and (?Cname)
     */
    private function parseCallout(): Node\CalloutNode
    {
        $token = $this->previous();
        $startPosition = $token->position;
        $value = $token->value;
        $endPosition = $startPosition + \strlen($token->value) + 4; // for (?C)

        $isStringIdentifier = false;
        $identifier = null;
        if (preg_match('/^"([^"]*+)"$/', $value, $matches)) {
            $identifier = $matches[1];
            $isStringIdentifier = true;
        } elseif (ctype_digit($value)) {
            $identifier = (int) $value;
        } elseif (preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*+$/', $value)) {
            $identifier = $value;
        } else {
            throw $this->parserException(
                \sprintf('Invalid callout argument: %s at position %d', $value, $startPosition),
                $startPosition,
            );
        }

        return new Node\CalloutNode($identifier, $isStringIdentifier, $startPosition, $endPosition);
    }

    /**
     * parses \g references (backreferences and subroutines)
     */
    private function parseGReference(int $startPosition): Node\NodeInterface
    {
        $token = $this->previous();
        $value = $token->value;
        $endPosition = $startPosition + \strlen($value);

        // \g{N} or \gN (numeric, incl. relative) -> Backreference
        if (preg_match('/^\\\\g\{?([0-9+-]++)\}?$/', $value, $m)) {
            return new Node\BackrefNode($value, $startPosition, $endPosition);
        }

        // \g<name> or \g{name} (non-numeric) -> Subroutine
        if (
            preg_match('/^\\\\g<(\w++)>$/', $value, $m)
            || preg_match('/^\\\\g\{(\w++)\}$/', $value, $m)
        ) {
            return new Node\SubroutineNode($m[1], 'g', $startPosition, $endPosition);
        }

        throw $this->parserException(
            \sprintf('Invalid \\g reference syntax: %s at position %d', $value, $token->position),
            $token->position,
        );
    }

    /**
     * parses comments like (?# this is a comment )
     */
    private function parseComment(): Node\CommentNode
    {
        $startToken = $this->previous(); // (?#
        $startPosition = $startToken->position;

        $comment = '';
        while (
            !$this->isAtEnd()
            && !$this->check(TokenType::T_GROUP_CLOSE)
        ) {
            $token = $this->current();
            $comment .= $this->reconstructTokenValue($token);
            $this->advance();
        }

        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close comment');
        $endPosition = $endToken->position + 1;

        return new Node\CommentNode($comment, $startPosition, $endPosition);
    }

    /**
     * Reconstructs the original string representation of a token.
     */
    private function reconstructTokenValue(Token $token): string
    {
        return match ($token->type) {
            // Simple literals
            TokenType::T_LITERAL,
            TokenType::T_NEGATION,
            TokenType::T_RANGE,
            TokenType::T_DOT,
            TokenType::T_GROUP_OPEN,
            TokenType::T_GROUP_CLOSE,
            TokenType::T_CHAR_CLASS_OPEN,
            TokenType::T_CHAR_CLASS_CLOSE,
            TokenType::T_QUANTIFIER,
            TokenType::T_ALTERNATION,
            TokenType::T_ANCHOR => $token->value,

            // Types that had a \ stripped
            TokenType::T_CHAR_TYPE,
            TokenType::T_ASSERTION,
            TokenType::T_KEEP,
            TokenType::T_OCTAL_LEGACY,
            TokenType::T_LITERAL_ESCAPED => '\\'.$token->value,

            // Types that kept their \
            TokenType::T_BACKREF,
            TokenType::T_G_REFERENCE,
            TokenType::T_UNICODE => $token->value,
            TokenType::T_UNICODE_NAMED => '\\N{'.$token->value.'}',
            TokenType::T_OCTAL => $token->value,

            // Complex re-assembly
            TokenType::T_CALLOUT => '(?C'.$token->value.')',
            TokenType::T_UNICODE_PROP => str_starts_with($token->value, '{')
                ? '\p'.$token->value
                : ((\strlen($token->value) > 1 || str_starts_with($token->value, '^'))
                    ? '\p{'.$token->value.'}'
                    : '\p'.$token->value),
            TokenType::T_POSIX_CLASS => '[[:'.$token->value.':]]',
            TokenType::T_PCRE_VERB => '(*'.$token->value.')',
            TokenType::T_GROUP_MODIFIER_OPEN => '(?',
            TokenType::T_COMMENT_OPEN => '(?#',
            TokenType::T_QUOTE_MODE_START => '\Q',
            TokenType::T_QUOTE_MODE_END => '\E',
            TokenType::T_CONTROL_CHAR => '\\c'.$token->value,
            TokenType::T_CLASS_INTERSECTION => '&&',
            TokenType::T_CLASS_SUBTRACTION => '--',

            // Should not be encountered here
            TokenType::T_EOF => '',
        };
    }

    /**
     * parses group modifiers like (?=...), (?!...), (?<=...), (?<!...), (?P<name>...), (?P'name'...), (?:...), (?(...)), (?&name), (?R), (?1), (?-1), (?0), and inline flags.
     */
    private function parseGroupModifier(): Node\NodeInterface
    {
        $startToken = $this->previous(); // (?
        $startPosition = $startToken->position;

        // 1. Check for Python-style 'P' groups
        $pPos = $this->current()->position;
        if ($this->matchLiteral('P')) {
            return $this->parsePythonGroup($startPosition, $pPos);
        }

        // 2. Check for standard lookarounds and named groups
        if ($this->matchLiteral('<')) {
            return $this->parseStandardGroup($startPosition);
        }

        // 3. Check for conditional (?(...)
        $isConditionalWithModifier = null;
        if ($this->match(TokenType::T_GROUP_MODIFIER_OPEN)) {
            $isConditionalWithModifier = true;
        } elseif ($this->match(TokenType::T_GROUP_OPEN)) {
            $isConditionalWithModifier = false;
        }

        if (null !== $isConditionalWithModifier) {
            return $this->parseConditional($startPosition, $isConditionalWithModifier);
        }

        // 4. Check for Subroutines
        if ($this->matchLiteral('&')) { // (?&name)
            $name = $this->parseSubroutineName();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close subroutine call');

            return new Node\SubroutineNode($name, '&', $startPosition, $endToken->position + 1);
        }

        if ($this->matchLiteral('R')) { // (?R)
            if ($this->check(TokenType::T_GROUP_CLOSE)) {
                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

                return new Node\SubroutineNode('R', '', $startPosition, $endToken->position + 1);
            }
            $this->stream->rewind(1); // Rewind 'R'
        }

        // Check for (?1), (?-1), (?0)
        if ($subroutine = $this->parseNumericSubroutine($startPosition)) {
            return $subroutine;
        }

        // 5. Check for simple non-capturing, lookaheads, atomic, branch reset
        if ($this->matchLiteral(':')) {
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_NON_CAPTURING,
                $startPosition,
                $endToken,
            );
        }

        if ($this->matchLiteral('=')) {
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_LOOKAHEAD_POSITIVE,
                $startPosition,
                $endToken,
            );
        }

        if ($this->matchLiteral('!')) {
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,
                $startPosition,
                $endToken,
            );
        }

        if ($this->matchLiteral('>')) {
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_ATOMIC,
                $startPosition,
                $endToken,
            );
        }

        if ($this->match(TokenType::T_ALTERNATION)) {
            // Branch reset group (?|...)
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_BRANCH_RESET,
                $startPosition,
                $endToken,
            );
        }

        // 6. Inline flags
        return $this->parseInlineFlags($startPosition);
    }

    /**
     * Parses Python-style named groups and subroutines like
     * (?P'name'...), (?P"name"...), (?P<name>...), (?P>name), and (?P=name).
     */
    private function parsePythonGroup(int $startPos, int $pPos): Node\NodeInterface
    {
        // Check for (?P'name'...) or (?P"name"...)
        if ($this->checkLiteral("'") || $this->checkLiteral('"')) {
            $quote = $this->current()->value;
            $this->advance();

            // Consume T_LITERAL tokens to build the name character by character
            $name = '';
            while (
                !$this->isAtEnd()
                && !$this->checkLiteral($quote)
            ) {
                if ($this->check(TokenType::T_LITERAL)) {
                    $name .= $this->current()->value;
                    $this->advance();
                } else {
                    if ($this->check(TokenType::T_GROUP_CLOSE)) {
                        break;
                    }

                    throw $this->parserException(
                        \sprintf('Unexpected token in group name at position %d', $this->current()->position),
                        $this->current()->position,
                    );
                }
            }

            if ('' === $name) {
                throw $this->parserException(
                    \sprintf('Expected group name at position %d', $this->current()->position),
                    $this->current()->position,
                );
            }

            if (!$this->checkLiteral($quote)) {
                throw $this->parserException(
                    \sprintf('Expected closing quote %s at position %d', $quote, $this->current()->position),
                    $this->current()->position,
                );
            }
            $this->advance();

            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_NAMED,
                $startPos,
                $endToken,
                $name,
            );
        }

        if ($this->matchLiteral('<')) { // (?P<name>...)
            $name = $this->parseGroupName($pPos);
            $this->consumeLiteral('>', 'Expected > after group name');
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_NAMED,
                $startPos,
                $endToken,
                $name,
            );
        }

        if ($this->matchLiteral('>')) { // (?P>name) subroutine
            $name = $this->parseSubroutineName();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close subroutine call');

            return new Node\SubroutineNode($name, 'P>', $startPos, $endToken->position + 1);
        }

        if ($this->matchLiteral('=')) {
            throw $this->parserException(
                'Backreferences (?P=name) are not supported yet.',
                $this->current()->position,
            );
        }

        throw $this->parserException(
            \sprintf('Invalid syntax after (?P at position %d', $pPos),
            $pPos,
        );
    }

    /**
     * Parses standard groups like (?<=...), (?<!...), and (?<name>...).
     */
    private function parseStandardGroup(int $startPos): Node\NodeInterface
    {
        if ($this->matchLiteral('=')) { // (?<=...)
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_LOOKBEHIND_POSITIVE,
                $startPos,
                $endToken,
            );
        }

        if ($this->matchLiteral('!')) { // (?<!...)
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,
                $startPos,
                $endToken,
            );
        }

        // (?<name>...)
        $name = $this->parseGroupName($startPos);
        $this->consumeLiteral('>', 'Expected > after group name');
        $expr = $this->parseAlternation();
        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

        return $this->createGroupNode(
            $expr,
            Node\GroupType::T_GROUP_NAMED,
            $startPos,
            $endToken,
            $name,
        );
    }

    /**
     * Parses numeric subroutine calls like (?1), (?-1), (?0).
     */
    private function parseNumericSubroutine(int $startPos): ?Node\SubroutineNode
    {
        $num = '';
        if ($this->matchLiteral('-')) {
            $num = '-';
        }
        if ($this->isLiteralDigitToken()) {
            $num .= $this->current()->value;
            $this->advance();
            $num .= $this->consumeWhile(static fn (string $c): bool => ctype_digit($c));

            if ($this->check(TokenType::T_GROUP_CLOSE)) {
                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

                return new Node\SubroutineNode($num, '', $startPos, $endToken->position + 1);
            }
            $this->stream->rewind(\strlen($num));
        } elseif ('-' === $num) {
            $this->stream->rewind(1);
        }

        return null;
    }

    /**
     * Parses inline flags and optional sub-expressions (?(?flags:...)).
     */
    private function parseInlineFlags(int $startPosition): Node\NodeInterface
    {
        // Support all PCRE2 flags including n (NO_AUTO_CAPTURE), r (unicode restricted), and ^ (unset)
        // Handle ^ (T_ANCHOR) at the start - it means "unset all flags" in PCRE2
        $flags = '';
        if ($this->check(TokenType::T_ANCHOR) && '^' === $this->current()->value) {
            $flags = '^';
            $this->advance();
        }
        $flags .= $this->consumeWhile(
            static fn (string $c): bool => str_contains(self::INLINE_FLAG_CHARS, $c),
        );

        if ('' !== $flags) {
            [$setFlags, $unsetFlags] = str_contains($flags, '-')
                ? explode('-', $flags, 2)
                : [$flags, ''];

            if (str_contains($setFlags, 'J')) {
                $this->JModifier = true;
            }
            if (str_contains($unsetFlags, 'J')) {
                $this->JModifier = false;
            }

            $expr = null;
            if ($this->matchLiteral(':')) {
                $expr = $this->parseAlternation();
            }
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            if (null === $expr) {
                $expr = $this->createEmptyLiteralNodeAt($this->previous()->position);
            }

            $this->lastInlineFlagsLength = ($endToken->position + 1) - $startPosition;

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_INLINE_FLAGS,
                $startPosition,
                $endToken,
                null,
                $flags,
            );
        }

        throw $this->parserException(
            \sprintf('Invalid group modifier syntax at position %d', $startPosition),
            $startPosition,
        );
    }

    /**
     * Parses conditional constructs (?(condition)...).
     */
    private function parseConditional(int $startPosition, bool $isModifier): Node\ConditionalNode|Node\DefineNode
    {
        if ($isModifier) {
            // Inline Lookaround condition
            $conditionStartPos = $this->previous()->position;
            $condition = $this->parseLookaroundCondition($conditionStartPos);
        } else {
            $condition = $this->parseConditionalCondition();
            $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) after condition');
        }

        $yes = $this->parseAlternation();

        // Special case: (?(DEFINE)...) creates a DefineNode instead of ConditionalNode
        if ($condition instanceof Node\AssertionNode && 'DEFINE' === $condition->value) {
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');
            $endPosition = $endToken->position + 1;

            return new Node\DefineNode($yes, $startPosition, $endPosition);
        }

        $no = null;
        $yesBranch = $yes;
        if ($yes instanceof Node\AlternationNode && \count($yes->alternatives) > 1) {
            $yesBranch = $yes->alternatives[0];
            $noAlternatives = \array_slice($yes->alternatives, 1);
            if (1 === \count($noAlternatives)) {
                $no = $noAlternatives[0];
            } else {
                $lastAlt = $noAlternatives[\count($noAlternatives) - 1];
                $no = new Node\AlternationNode(
                    $noAlternatives,
                    $noAlternatives[0]->getStartPosition(),
                    $lastAlt->getEndPosition(),
                );
            }
        }

        if (null === $no) {
            $no = $this->createEmptyLiteralNodeAt($this->current()->position);
        }

        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');
        $endPosition = $endToken->position + 1;

        return new Node\ConditionalNode($condition, $yesBranch, $no, $startPosition, $endPosition);
    }

    /**
     * Parses lookaround conditions inside conditional constructs (?(?=...)...).
     */
    private function parseLookaroundCondition(int $startPosition): Node\NodeInterface
    {
        if ($this->matchLiteral('=')) {
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_LOOKAHEAD_POSITIVE,
                $startPosition,
                $endToken,
            );
        }

        if ($this->matchLiteral('!')) {
            $expr = $this->parseAlternation();
            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

            return $this->createGroupNode(
                $expr,
                Node\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,
                $startPosition,
                $endToken,
            );
        }

        if ($this->matchLiteral('<')) {
            // @phpstan-ignore-next-line if.alwaysFalse (false positive: position advanced after matching '<')
            if ($this->matchLiteral('=')) {
                $expr = $this->parseAlternation();
                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

                return $this->createGroupNode(
                    $expr,
                    Node\GroupType::T_GROUP_LOOKBEHIND_POSITIVE,
                    $startPosition,
                    $endToken,
                );
            }
            // @phpstan-ignore-next-line if.alwaysFalse (false positive: position advanced after matching '<')
            if ($this->matchLiteral('!')) {
                $expr = $this->parseAlternation();
                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');

                return $this->createGroupNode(
                    $expr,
                    Node\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,
                    $startPosition,
                    $endToken,
                );
            }
        }

        throw $this->parserException(
            'Invalid conditional condition at position '.$startPosition,
            $startPosition,
        );
    }

    /**
     * Parses the condition part of a conditional construct (?(condition)...).
     */
    private function parseConditionalCondition(): Node\NodeInterface
    {
        $startPosition = $this->current()->position;

        // This handles the PCRE feature where (?(DEFINE)...) allows defining subroutines
        // without matching them immediately.
        // We need to check for 'DEFINE' by peeking at multiple tokens since the lexer
        // tokenizes each character separately.
        if ($this->check(TokenType::T_LITERAL) && 'D' === $this->current()->value) {
            $savedPos = $this->stream->getPosition();
            $word = '';
            while ($this->isLiteralAlphaToken()) {
                $word .= $this->current()->value;
                $this->advance();
            }
            if ('DEFINE' === $word && $this->check(TokenType::T_GROUP_CLOSE)) {
                return new Node\AssertionNode('DEFINE', $startPosition, $this->current()->position);
            }
            // Not DEFINE, restore position
            $this->stream->setPosition($savedPos);
        }

        if ($this->isLiteralDigitToken()) {
            $this->advance();
            $num = (string) ($this->previous()->value.$this->consumeWhile(
                static fn (string $c): bool => ctype_digit($c),
            ));

            return new Node\BackrefNode($num, $startPosition, $this->current()->position);
        }

        if ($this->matchLiteral('<') || $this->matchLiteral('{')) {
            $open = $this->previous()->value;
            $name = $this->parseGroupName($startPosition, false);
            $close = '<' === $open ? '>' : '}';
            $this->consumeLiteral($close, "Expected $close after condition name");

            return new Node\BackrefNode($name, $startPosition, $this->current()->position);
        }

        if ($this->matchLiteral('R')) {
            $endPosition = $this->previous()->position;
            $numericPart = '';
            $sawMinus = false;

            if ($this->checkLiteral('-')) {
                $sawMinus = true;
                $this->advance();
            }

            $digits = $this->consumeWhile(static fn (string $c): bool => ctype_digit($c));
            if ('' !== $digits) {
                $numericPart = ($sawMinus ? '-' : '').$digits;
                $endPosition = $this->previous()->position;
            } elseif ($sawMinus) {
                $this->stream->rewind(1);
            }

            $reference = 'R'.$numericPart;

            return new Node\SubroutineNode($reference, '', $startPosition, $endPosition);
        }

        if ($this->matchLiteral('?')) {
            // Lookaround condition inside (?(...))
            return $this->parseLookaroundCondition($startPosition);
        }

        // Bare name check (for conditions like (?(name)...))
        if ($this->check(TokenType::T_LITERAL)) {
            $savedPos = $this->stream->getPosition();
            $name = '';
            while (
                $this->check(TokenType::T_LITERAL)
                && !$this->checkLiteral(')')
                && !$this->isAtEnd()
            ) {
                $name .= $this->current()->value;
                $this->advance();
            }
            if ('' !== $name && $this->check(TokenType::T_GROUP_CLOSE)) {
                return new Node\BackrefNode($name, $startPosition, $this->current()->position);
            }
            $this->stream->setPosition($savedPos);
        }

        $condition = $this->parseAtom();

        if (
            !(
                $condition instanceof Node\BackrefNode
                || $condition instanceof Node\GroupNode
                || $condition instanceof Node\AssertionNode
                || $condition instanceof Node\SubroutineNode
            )
        ) {
            throw $this->parserException(
                \sprintf(
                    'Invalid conditional construct at position %d. Condition must be a group reference, lookaround, or (DEFINE).',
                    $startPosition,
                ),
                $startPosition,
            );
        }

        return $condition;
    }

    /**
     * checks for duplicate group names and registers the name
     */
    private function checkAndRegisterGroupName(string $name, int $position): void
    {
        if (isset($this->groupNames[$name]) && !$this->JModifier) {
            throw $this->parserException(
                \sprintf('Duplicate group name "%s" at position %d.', $name, $position),
                $position,
            );
        }
        $this->groupNames[$name] = true;
    }

    /**
     * parses a group name, handling quoted names and validating characters
     */
    private function parseGroupName(?int $errorPosition = null, bool $register = true): string
    {
        $quote = null;
        $nameStartPosition = $errorPosition ?? $this->current()->position;

        $adjustment = 0;
        if ($this->lastInlineFlagsLength > 0) {
            $adjustment = max(0, $this->lastInlineFlagsLength - 2);
        } elseif ($this->lastTokenWasAlternation) {
            $adjustment = 1;
        }
        $nameStartPosition = max(0, $nameStartPosition - $adjustment);
        $this->lastTokenWasAlternation = false;
        $this->lastInlineFlagsLength = 0;

        // Check for quoted group name (Python-style: 'name' or "name")
        if ($this->checkLiteral("'") || $this->checkLiteral('"')) {
            $quote = $this->current()->value;
            $this->advance();
        }

        $name = '';
        while (
            !$this->checkLiteral('>')
            && !$this->checkLiteral('}')
            && !$this->isAtEnd()
        ) {
            // If we're in quoted mode and hit the closing quote, stop collecting
            if (null !== $quote && $this->checkLiteral($quote)) {
                break;
            }

            if ($this->check(TokenType::T_GROUP_CLOSE)) {
                break;
            }

            if ($this->check(TokenType::T_LITERAL) || $this->check(TokenType::T_LITERAL_ESCAPED)) {
                $name .= $this->current()->value;
                $this->advance();
            } else {
                throw $this->parserException(
                    \sprintf('Unexpected token "%s" in group name', $this->current()->value),
                    $this->current()->position,
                );
            }
        }

        // If quoted, expect the closing quote
        if (null !== $quote) {
            if (!$this->checkLiteral($quote)) {
                throw $this->parserException(
                    \sprintf(
                        'Expected closing quote "%s" for group name at position %d',
                        $quote,
                        $this->current()->position,
                    ),
                    $this->current()->position,
                );
            }
            $this->advance();
        }

        if ('' === $name) {
            throw $this->parserException(
                \sprintf('Expected group name at position %d', $nameStartPosition),
                $nameStartPosition,
            );
        }

        if ($register) {
            $this->checkAndRegisterGroupName($name, $nameStartPosition);
        }

        return $name;
    }

    /**
     * parses a character class, including its parts and negation
     */
    private function parseCharClass(): Node\CharClassNode
    {
        $startToken = $this->previous();
        $startPosition = $startToken->position;
        $isNegated = $this->match(TokenType::T_NEGATION);
        $parts = $this->parseClassExpression();

        $endToken = $this->consume(TokenType::T_CHAR_CLASS_CLOSE, 'Expected "]" to close character class');

        return new Node\CharClassNode($parts, $isNegated, $startPosition, $endToken->position + 1);
    }

    /**
     * Parses a character class expression with intersection (&&) and subtraction (--) operations.
     */
    private function parseClassExpression(): Node\NodeInterface
    {
        $left = $this->parseCharClassAlternation();

        while ($this->check(TokenType::T_CLASS_INTERSECTION) || $this->check(TokenType::T_CLASS_SUBTRACTION)) {
            $type = TokenType::T_CLASS_INTERSECTION === $this->current()->type ? Node\ClassOperationType::INTERSECTION : Node\ClassOperationType::SUBTRACTION;
            $this->advance();
            $right = $this->parseCharClassAlternation();
            $left = new Node\ClassOperationNode($type, $left, $right, $left->getStartPosition(), $right->getEndPosition());
        }

        return $left;
    }

    /**
     * Parses the alternation of character class parts (without operations).
     */
    private function parseCharClassAlternation(): Node\NodeInterface
    {
        $parts = [];

        while (
            !$this->check(TokenType::T_CHAR_CLASS_CLOSE)
            && !$this->check(TokenType::T_CLASS_INTERSECTION)
            && !$this->check(TokenType::T_CLASS_SUBTRACTION)
            && !$this->isAtEnd()
        ) {
            // Silent tokens inside char class
            if (
                $this->match(TokenType::T_QUOTE_MODE_START)
                || $this->match(TokenType::T_QUOTE_MODE_END)
            ) {
                continue;
            }
            $parts[] = $this->parseCharClassPart();
        }

        if (empty($parts)) {
            return $this->createEmptyLiteralNodeAt($this->current()->position);
        }

        if (1 === \count($parts)) {
            return $parts[0];
        }

        $start = $parts[0]->getStartPosition();
        $end = $parts[\count($parts) - 1]->getEndPosition();

        return new Node\AlternationNode($parts, $start, $end);
    }

    /**
     * parses a part of a character class, which can be a literal, range, char type, unicode property, etc
     */
    private function parseCharClassPart(): Node\NodeInterface
    {
        $startToken = $this->current();
        $startPosition = $startToken->position;
        $startNode = null;

        // Simplified matching logic for char class parts
        if ($this->match(TokenType::T_LITERAL) || $this->match(TokenType::T_LITERAL_ESCAPED)) {
            $token = $this->previous();
            // Check for range validity
            // +1 if escaped
            $endPosition = $startPosition + \strlen($token->value)
                + (TokenType::T_LITERAL_ESCAPED === $token->type ? 1 : 0);
            $startNode = new Node\LiteralNode($token->value, $startPosition, $endPosition);
        } elseif ($this->match(TokenType::T_CHAR_TYPE)) {
            $token = $this->previous();
            $startNode = new Node\CharTypeNode(
                $token->value,
                $startPosition,
                $startPosition + \strlen($token->value) + 1,
            );
        } elseif ($this->match(TokenType::T_UNICODE_PROP)) {
            $token = $this->previous();
            // Basic length calc - Parser logic from original
            $len = 2 + \strlen($token->value)
                + ((\strlen($token->value) > 1 || str_starts_with($token->value, '^')) ? 2 : 0);
            $startNode = new Node\UnicodePropNode($token->value, $startPosition, $startPosition + $len);
        } elseif ($this->match(TokenType::T_UNICODE)) {
            $token = $this->previous();
            $startNode = new Node\UnicodeNode(
                $token->value,
                $startPosition,
                $startPosition + \strlen($token->value),
            );
        } elseif ($this->match(TokenType::T_OCTAL)) {
            $token = $this->previous();
            $startNode = new Node\OctalNode(
                $token->value,
                $startPosition,
                $startPosition + \strlen($token->value),
            );
        } elseif ($this->match(TokenType::T_OCTAL_LEGACY)) {
            $token = $this->previous();
            $startNode = new Node\OctalLegacyNode(
                $token->value,
                $startPosition,
                $startPosition + \strlen($token->value) + 1,
            );
        } elseif ($this->match(TokenType::T_RANGE)) {
            // Literal hyphen at start
            return new Node\LiteralNode($this->previous()->value, $startPosition, $startPosition + 1);
        } elseif ($this->match(TokenType::T_POSIX_CLASS)) {
            $token = $this->previous();
            $startNode = new Node\PosixClassNode(
                $token->value,
                $startPosition,
                $startPosition + \strlen($token->value) + 4,
            );
        } else {
            throw $this->parserException(
                \sprintf(
                    'Unexpected token "%s" in character class at position %d.',
                    $this->current()->value,
                    $this->current()->position,
                ),
                $this->current()->position,
            );
        }

        // Check for Range
        if ($this->match(TokenType::T_RANGE)) {
            if ($this->check(TokenType::T_CHAR_CLASS_CLOSE)) {
                // Trailing hyphen
                $this->stream->rewind(1);

                return $startNode;
            }

            // We call parseCharClassPart again for the end node.
            // The grammar does not support chained ranges (a-b-c), so this is safe.
            $endNode = $this->parseCharClassPart();

            return new Node\RangeNode($startNode, $endNode, $startPosition, $endNode->getEndPosition());
        }

        return $startNode;
    }

    /**
     * parses a subroutine name consisting of alphanumeric characters and underscores
     */
    private function parseSubroutineName(): string
    {
        $name = '';
        while (
            !$this->check(TokenType::T_GROUP_CLOSE)
            && !$this->isAtEnd()
        ) {
            if ($this->check(TokenType::T_LITERAL) || $this->check(TokenType::T_LITERAL_ESCAPED)) {
                $char = $this->current()->value;
                if (!preg_match('/^[a-zA-Z0-9_]$/', $char)) {
                    throw $this->parserException(
                        'Unexpected token in subroutine name: '.$char,
                        $this->current()->position,
                    );
                }
                $name .= $char;
                $this->advance();
            } else {
                throw $this->parserException(
                    'Unexpected token in subroutine name: '.$this->current()->value,
                    $this->current()->position,
                );
            }
        }
        if ('' === $name) {
            throw $this->parserException(
                'Expected subroutine name at position '.$this->current()->position,
                $this->current()->position,
            );
        }

        return $name;
    }

    /**
     * creates a ParserException with context about the pattern being parsed
     */
    private function parserException(string $message, int $position): ParserException
    {
        return SyntaxErrorException::withContext($message, $position, $this->pattern);
    }

    private function guardRecursionDepth(int $position): void
    {
        if ($this->recursionDepth >= self::MAX_RECURSION_DEPTH) {
            throw RecursionLimitException::withContext(
                \sprintf('Recursion limit of %d exceeded', self::MAX_RECURSION_DEPTH),
                $position,
                $this->pattern,
            );
        }
    }

    /**
     * @return bool true if the current token matches the given type
     */
    private function match(TokenType $type): bool
    {
        if ($this->check($type)) {
            $this->advance();

            return true;
        }

        return false;
    }

    /**
     * @return bool true if the current token is a T_LITERAL and its value matches the given value
     */
    private function matchLiteral(string $value): bool
    {
        if ($this->checkLiteral($value)) {
            $this->advance();

            return true;
        }

        return false;
    }

    /**
     * @return bool true if the current token is a T_LITERAL and its value matches the given value
     */
    private function checkLiteral(string $value): bool
    {
        if ($this->isAtEnd()) {
            return false;
        }
        $token = $this->current();

        return TokenType::T_LITERAL === $token->type && $token->value === $value;
    }

    /**
     * @return Token the consumed token
     */
    private function consume(TokenType $type, string $error): Token
    {
        if ($this->check($type)) {
            $token = $this->current();
            $this->advance();

            return $token;
        }
        $at = $this->isAtEnd() ? 'end of input' : 'position '.$this->current()->position;

        throw $this->parserException(
            $error.' at '.$at.' (found '.$this->current()->type->value.')',
            $this->current()->position,
        );
    }

    /**
     * @return Token the consumed token
     */
    private function consumeLiteral(string $value, string $error): Token
    {
        if ($this->checkLiteral($value)) {
            $token = $this->current();
            $this->advance();

            return $token;
        }
        $at = $this->isAtEnd() ? 'end of input' : 'position '.$this->current()->position;

        throw $this->parserException(
            $error.' at '.$at.' (found '.$this->current()->type->value.' with value '.$this->current()->value.')',
            $this->current()->position,
        );
    }

    /**
     * @return bool true if the current token matches the given type
     */
    private function check(TokenType $type): bool
    {
        if ($this->isAtEnd()) {
            return TokenType::T_EOF === $type;
        }

        return $this->current()->type === $type;
    }

    /**
     * Advances the parser to the next token in the stream.
     */
    private function advance(): void
    {
        if (!$this->isAtEnd()) {
            $this->stream->next();
        }
    }

    /**
     * @return bool true if the parser has reached the end of the token stream
     */
    private function isAtEnd(): bool
    {
        return TokenType::T_EOF === $this->current()->type;
    }

    /**
     * @return Token the current token in the stream
     */
    private function current(): Token
    {
        return $this->stream->current();
    }

    /**
     * @return Token the previous token in the stream
     */
    private function previous(): Token
    {
        return $this->stream->peek(-1);
    }

    /**
     * Creates an empty literal node (epsilon) at a given position.
     */
    private function createEmptyLiteralNodeAt(int $position): Node\LiteralNode
    {
        return new Node\LiteralNode('', $position, $position);
    }

    /**
     * Small factory for group nodes to keep argument ordering and end positions consistent.
     */
    private function createGroupNode(
        Node\NodeInterface $expr,
        Node\GroupType $type,
        int $startPosition,
        Token $endToken,
        ?string $name = null,
        ?string $flags = null
    ): Node\GroupNode {
        return new Node\GroupNode($expr, $type, $name, $flags, $startPosition, $endToken->position + 1);
    }

    /**
     * @return bool true if the current token is a T_LITERAL and its value is a digit (0-9)
     */
    private function isLiteralDigitToken(): bool
    {
        return $this->check(TokenType::T_LITERAL) && ctype_digit($this->current()->value);
    }

    /**
     * @return bool true if the current token is a T_LITERAL and its value is an alphabetic character (a-z, A-Z)
     */
    private function isLiteralAlphaToken(): bool
    {
        return $this->check(TokenType::T_LITERAL) && ctype_alpha($this->current()->value);
    }

    /**
     * Consumes tokens while the predicate returns true, concatenating their values.
     */
    private function consumeWhile(callable $predicate): string
    {
        $value = '';

        while (
            !$this->isAtEnd()
            && $this->check(TokenType::T_LITERAL)
            && $predicate($this->current()->value)
        ) {
            $value .= $this->current()->value;
            $this->advance();
        }

        return $value;
    }
}
