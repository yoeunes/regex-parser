#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Corpus Update Script
 *
 * Updates git repositories under corpus/ with parallel processing and timeouts.
 */

final class ConsoleStyle
{
    private bool $useColor;

    public function __construct()
    {
        $this->useColor = $this->supportsColor();
    }

    public function header(string $title): void
    {
        $line = str_repeat('=', \strlen($title));
        echo $this->bold($title).PHP_EOL;
        echo $this->dim($line).PHP_EOL;
    }

    public function status(string $label, string $message, ?string $detail = null): void
    {
        $plainLabel = preg_replace('/\e\[[\d;]*m/', '', $label);
        $plainLabel ??= $label;
        $pad = max(0, 8 - \strlen($plainLabel));
        $label = $label.str_repeat(' ', $pad);
        echo '  '.$label.' '.$message.PHP_EOL;
        if (null !== $detail && '' !== $detail) {
            echo $this->indent($detail, '         ');
        }
    }

    public function info(string $message): void
    {
        echo $message.PHP_EOL;
    }

    public function warn(string $message): void
    {
        echo $this->yellow('Warning: ').$message.PHP_EOL;
    }

    public function error(string $message): void
    {
        fwrite(\STDERR, $this->red('Error: ').$message.PHP_EOL);
    }

    public function dim(string $text): string
    {
        return $this->colorize($text, '2');
    }

    public function bold(string $text): string
    {
        return $this->colorize($text, '1');
    }

    public function green(string $text): string
    {
        return $this->colorize($text, '32');
    }

    public function red(string $text): string
    {
        return $this->colorize($text, '31');
    }

    public function yellow(string $text): string
    {
        return $this->colorize($text, '33');
    }

    public function cyan(string $text): string
    {
        return $this->colorize($text, '36');
    }

    private function colorize(string $text, string $code): string
    {
        if (!$this->useColor) {
            return $text;
        }

        return "\033[".$code."m".$text."\033[0m";
    }

    private function supportsColor(): bool
    {
        if ('1' === getenv('NO_COLOR')) {
            return false;
        }

        if (!\function_exists('posix_isatty')) {
            return false;
        }

        return posix_isatty(\STDOUT);
    }

    private function indent(string $text, string $prefix): string
    {
        $lines = preg_split("/\\r?\\n/", trim($text));
        if (!\is_array($lines)) {
            return '';
        }

        $indented = array_map(static fn (string $line): string => $prefix.$line, $lines);

        return implode(PHP_EOL, $indented).PHP_EOL;
    }
}

// ---------------------------------------------------------------------------
// Argument parsing
// ---------------------------------------------------------------------------

/**
 * @return array<string, mixed>
 */
function parseArgs(array $argv): array
{
    $options = [
        'jobs' => null,
        'timeout' => null,
        'force' => false,
        'debug' => false,
        'help' => false,
    ];

    for ($i = 1; $i < \count($argv); $i++) {
        $arg = $argv[$i];
        if ('--help' === $arg || '-h' === $arg) {
            $options['help'] = true;
            continue;
        }
        if ('--force' === $arg) {
            $options['force'] = true;
            continue;
        }
        if ('--debug' === $arg) {
            $options['debug'] = true;
            continue;
        }
        if ('--jobs' === $arg || '-j' === $arg) {
            $next = $argv[$i + 1] ?? null;
            if (null === $next || str_starts_with($next, '-')) {
                $options['jobs'] = null;
                continue;
            }
            $options['jobs'] = $next;
            $i++;
            continue;
        }
        if (str_starts_with($arg, '--jobs=')) {
            $options['jobs'] = substr($arg, \strlen('--jobs='));
            continue;
        }
        if ('--timeout' === $arg || '-t' === $arg) {
            $next = $argv[$i + 1] ?? null;
            if (null === $next || str_starts_with($next, '-')) {
                continue;
            }
            $options['timeout'] = $next;
            $i++;
            continue;
        }
        if (str_starts_with($arg, '--timeout=')) {
            $options['timeout'] = substr($arg, \strlen('--timeout='));
            continue;
        }

        throw new InvalidArgumentException(sprintf('Unknown argument: %s', $arg));
    }

    return $options;
}

function printUsage(): void
{
    echo <<<'TXT'
Usage: corpus/update [--jobs[=<n>|auto]] [--timeout=<sec>] [--force] [--debug] [--help]

Options:
  --jobs, -j      Number of parallel workers (default: auto, 2x CPUs)
  --timeout, -t   Per-repo timeout in seconds (default: 120)
  --force         Reset tracked changes and remove untracked files before pulling
  --debug         Show git commands and detailed diagnostics per repo
  --help, -h      Show this help message

TXT;
}

// ---------------------------------------------------------------------------
// System helpers
// ---------------------------------------------------------------------------

function detectCpuCount(): int
{
    if (\function_exists('swoole_cpu_num')) {
        return swoole_cpu_num();
    }

    if (\DIRECTORY_SEPARATOR === '/') {
        if (\is_readable('/proc/cpuinfo')) {
            $cpuinfo = \file_get_contents('/proc/cpuinfo');
            if (false !== $cpuinfo) {
                $matches = [];
                \preg_match_all('/^processor\\s*:/m', $cpuinfo, $matches);
                if (!empty($matches[0])) {
                    return \count($matches[0]);
                }
            }
        }

        $result = \shell_exec('sysctl -n hw.ncpu 2>/dev/null');
        if (null !== $result) {
            $cpu = (int) trim((string) $result);
            if ($cpu > 0) {
                return $cpu;
            }
        }
    } else {
        $result = \shell_exec('wmic cpu get NumberOfCores 2>nul | findstr /r /v "^$" | findstr /v "NumberOfCores"');
        if (null !== $result) {
            $cpu = (int) trim((string) $result);
            if ($cpu > 0) {
                return $cpu;
            }
        }
    }

    return 1;
}

function supportsParallel(): bool
{
    return \PHP_SAPI === 'cli'
        && \function_exists('pcntl_fork')
        && \function_exists('pcntl_waitpid');
}

// ---------------------------------------------------------------------------
// Repository discovery
// ---------------------------------------------------------------------------

/**
 * @return array<string>
 */
function findGitRepos(string $dir): array
{
    $repos = [];
    findGitReposRecursive($dir, $repos);

    sort($repos);

    return $repos;
}

/**
 * @param array<string> $repos
 */
function findGitReposRecursive(string $dir, array &$repos): void
{
    $subdirs = glob($dir.'/*', GLOB_ONLYDIR);
    if (false === $subdirs) {
        return;
    }

    foreach ($subdirs as $subdir) {
        if (is_dir($subdir.'/.git')) {
            $repos[] = $subdir;
            continue;
        }

        if ('.' === basename($subdir)[0]) {
            continue;
        }

        findGitReposRecursive($subdir, $repos);
    }
}

function isSafeRepo(string $repoPath, string $corpusDir): bool
{
    $repoReal = realpath($repoPath);
    $corpusReal = realpath($corpusDir);
    if (false === $repoReal || false === $corpusReal) {
        return false;
    }

    $prefix = rtrim($corpusReal, DIRECTORY_SEPARATOR).DIRECTORY_SEPARATOR;

    return str_starts_with($repoReal, $prefix) && is_dir($repoReal.'/.git');
}

function formatRepoLabel(string $repoPath, string $corpusDir): string
{
    $repoReal = realpath($repoPath) ?: $repoPath;
    $corpusReal = realpath($corpusDir) ?: $corpusDir;
    $prefix = rtrim($corpusReal, DIRECTORY_SEPARATOR).DIRECTORY_SEPARATOR;

    if (str_starts_with($repoReal, $prefix)) {
        return substr($repoReal, \strlen($prefix));
    }

    return $repoReal;
}

// ---------------------------------------------------------------------------
// Git execution with timeout
// ---------------------------------------------------------------------------

/**
 * @param array<int, string> $args
 *
 * @return array{code: int, output: string}
 */
function runGit(string $repoPath, array $args, int $timeout = 120): array
{
    $command = array_merge(['git'], $args);
    $descriptors = [
        0 => ['file', '/dev/null', 'r'],
        1 => ['pipe', 'w'],
        2 => ['pipe', 'w'],
    ];

    $process = proc_open($command, $descriptors, $pipes, $repoPath, ['GIT_TERMINAL_PROMPT' => '0']);
    if (!\is_resource($process)) {
        return ['code' => 1, 'output' => 'Failed to start git process.'];
    }

    stream_set_blocking($pipes[1], false);
    stream_set_blocking($pipes[2], false);

    $stdout = '';
    $stderr = '';
    $deadline = microtime(true) + $timeout;

    while (true) {
        $remaining = $deadline - microtime(true);
        if ($remaining <= 0) {
            proc_terminate($process, 9);
            fclose($pipes[1]);
            fclose($pipes[2]);
            proc_close($process);

            return ['code' => -1, 'output' => 'Timed out after '.$timeout.'s'];
        }

        $status = proc_get_status($process);

        $stdout .= (string) stream_get_contents($pipes[1]);
        $stderr .= (string) stream_get_contents($pipes[2]);

        if (!$status['running']) {
            $stdout .= (string) stream_get_contents($pipes[1]);
            $stderr .= (string) stream_get_contents($pipes[2]);
            fclose($pipes[1]);
            fclose($pipes[2]);
            proc_close($process);

            return [
                'code' => $status['exitcode'],
                'output' => trim($stdout."\n".$stderr),
            ];
        }

        usleep(20000); // 20ms
    }
}

// ---------------------------------------------------------------------------
// Pull-command resolution (no I/O side effects)
// ---------------------------------------------------------------------------

function getCurrentBranch(string $repoPath, int $timeout): ?string
{
    $result = runGit($repoPath, ['rev-parse', '--abbrev-ref', 'HEAD'], $timeout);
    if (0 !== $result['code']) {
        return null;
    }

    $branch = trim($result['output']);

    return ('' === $branch || 'HEAD' === $branch) ? null : $branch;
}

function getUpstreamRef(string $repoPath, int $timeout): ?string
{
    $result = runGit($repoPath, ['rev-parse', '--abbrev-ref', '--symbolic-full-name', '@{u}'], $timeout);
    if (0 !== $result['code']) {
        return null;
    }

    $ref = trim($result['output']);

    return '' === $ref ? null : $ref;
}

function remoteExists(string $repoPath, string $remote, int $timeout): bool
{
    $result = runGit($repoPath, ['remote', 'get-url', $remote], $timeout);

    return 0 === $result['code'] && '' !== trim($result['output']);
}

function getBranchRemote(string $repoPath, string $branch, int $timeout): ?string
{
    $result = runGit($repoPath, ['config', '--get', 'branch.'.$branch.'.remote'], $timeout);
    if (0 === $result['code']) {
        $remote = trim($result['output']);
        if ('' !== $remote) {
            return $remote;
        }
    }

    return remoteExists($repoPath, 'origin', $timeout) ? 'origin' : null;
}

function getBranchMergeRef(string $repoPath, string $branch, int $timeout): ?string
{
    $result = runGit($repoPath, ['config', '--get', 'branch.'.$branch.'.merge'], $timeout);
    if (0 !== $result['code']) {
        return null;
    }

    $mergeRef = trim($result['output']);

    return '' === $mergeRef ? null : $mergeRef;
}

function normalizeMergeRef(string $mergeRef): string
{
    $prefix = 'refs/heads/';
    if (str_starts_with($mergeRef, $prefix)) {
        return substr($mergeRef, \strlen($prefix));
    }

    return $mergeRef;
}

/**
 * @return array{ok: bool, args?: array<int, string>, command?: string, note?: string, message?: string}
 */
function resolvePullCommand(string $repoPath, int $timeout): array
{
    $upstream = getUpstreamRef($repoPath, $timeout);
    if (null !== $upstream) {
        return [
            'ok' => true,
            'args' => ['pull', '--rebase'],
            'command' => 'git pull --rebase',
        ];
    }

    $branch = getCurrentBranch($repoPath, $timeout);
    if (null === $branch) {
        return [
            'ok' => false,
            'message' => 'Detached HEAD or unable to determine current branch.',
        ];
    }

    $remote = getBranchRemote($repoPath, $branch, $timeout);
    if (null === $remote) {
        return [
            'ok' => false,
            'message' => 'No git remote found for branch '.$branch.'.',
        ];
    }

    $mergeRef = getBranchMergeRef($repoPath, $branch, $timeout);
    $remoteBranch = null !== $mergeRef ? normalizeMergeRef($mergeRef) : $branch;

    return [
        'ok' => true,
        'args' => ['pull', '--rebase', $remote, $remoteBranch],
        'command' => 'git pull --rebase '.$remote.' '.$remoteBranch,
        'note' => 'No upstream configured; pulling '.$remote.'/'.$remoteBranch.'.',
    ];
}

// ---------------------------------------------------------------------------
// Combined prepare + update per repo (runs inside worker)
// ---------------------------------------------------------------------------

/**
 * @return array{path: string, status: string, output: string, command: string, code: int, log: array<string>}
 */
function processRepo(string $repoPath, bool $force, string $corpusDir, bool $debug, int $timeout): array
{
    $log = [];
    $fail = static fn (string $msg, string $cmd = 'N/A', int $code = 1): array => [
        'path' => $repoPath,
        'status' => 'FAIL',
        'output' => $msg,
        'command' => $cmd,
        'code' => $code,
        'log' => $log,
    ];

    $git = static function (array $args) use ($repoPath, $timeout, $debug, &$log): array {
        $result = runGit($repoPath, $args, $timeout);
        if ($debug) {
            $cmdStr = 'git '.implode(' ', array_map('escapeshellarg', $args));
            $detail = 0 === $result['code'] && '' === $result['output'] ? '(no output)' : $result['output'];
            $log[] = $cmdStr.' â†’ exit '.$result['code'].': '.$detail;
        }

        return $result;
    };

    // Safety check
    if (!isSafeRepo($repoPath, $corpusDir)) {
        return [
            'path' => $repoPath,
            'status' => 'SKIP',
            'output' => 'Outside corpus directory.',
            'command' => 'N/A',
            'code' => 0,
            'log' => $log,
        ];
    }

    // --- Prepare phase ---
    if ($force) {
        $reset = $git(['reset', '--hard', 'HEAD']);
        if (0 !== $reset['code']) {
            return $fail('Reset failed: '.$reset['output']);
        }

        $clean = $git(['clean', '-fd']);
        if (0 !== $clean['code']) {
            return $fail('Clean failed: '.$clean['output']);
        }
    } else {
        $status = $git(['status', '--porcelain']);
        if (0 !== $status['code']) {
            return $fail($status['output']);
        }

        if ('' !== $status['output']) {
            return [
                'path' => $repoPath,
                'status' => 'SKIP',
                'output' => 'Dirty working tree (use --force to reset).',
                'command' => 'N/A',
                'code' => 0,
                'log' => $log,
            ];
        }
    }

    // --- Update phase ---
    $resolved = resolvePullCommand($repoPath, $timeout);
    if (!($resolved['ok'] ?? false)) {
        return $fail($resolved['message'] ?? 'Unable to resolve pull command.');
    }

    /** @var array<int, string> $args */
    $args = $resolved['args'] ?? ['pull', '--rebase'];
    $command = $resolved['command'] ?? 'git pull --rebase';

    $pull = $git($args);
    $output = $pull['output'];
    if (isset($resolved['note']) && '' !== $resolved['note']) {
        $output = $resolved['note'].('' === $output ? '' : PHP_EOL.$output);
    }

    return [
        'path' => $repoPath,
        'status' => 0 === $pull['code'] ? 'OK' : 'FAIL',
        'output' => $output,
        'command' => $command,
        'code' => $pull['code'],
        'log' => $log,
    ];
}

// ---------------------------------------------------------------------------
// Worker-pool parallel execution
// ---------------------------------------------------------------------------

/**
 * @param array<string> $repos
 *
 * @return array<int, array{path: string, status: string, output: string, command: string, code: int, log: array<string>}>
 */
function processReposParallel(
    array $repos,
    int $jobs,
    bool $force,
    string $corpusDir,
    bool $debug,
    int $timeout,
    callable $onComplete,
): array {
    $results = [];
    $queue = $repos;
    /** @var array<int, array{tmp: string, repo: string}> $active */
    $active = [];
    $completed = 0;
    $total = \count($repos);

    while ($queue || $active) {
        // Fill worker slots
        while (\count($active) < $jobs && $queue) {
            $repo = array_shift($queue);
            $tmp = tempnam(sys_get_temp_dir(), 'corpus_');
            if (false === $tmp) {
                $results[] = processRepo($repo, $force, $corpusDir, $debug, $timeout);
                $completed++;
                $onComplete($completed, $total);
                continue;
            }

            $pid = pcntl_fork();
            if (-1 === $pid) {
                @unlink($tmp);
                $results[] = processRepo($repo, $force, $corpusDir, $debug, $timeout);
                $completed++;
                $onComplete($completed, $total);
                continue;
            }

            if (0 === $pid) {
                // Child: process single repo, write result, exit
                $result = processRepo($repo, $force, $corpusDir, $debug, $timeout);
                file_put_contents($tmp, serialize($result));
                exit(0);
            }

            $active[$pid] = ['tmp' => $tmp, 'repo' => $repo];
        }

        if ([] === $active) {
            break;
        }

        // Wait for any child to finish
        $pid = pcntl_waitpid(-1, $status);
        if ($pid > 0 && isset($active[$pid])) {
            $info = $active[$pid];
            unset($active[$pid]);

            $data = @file_get_contents($info['tmp']);
            @unlink($info['tmp']);

            if (false !== $data) {
                $decoded = @unserialize($data);
                if (\is_array($decoded)) {
                    $results[] = $decoded;
                } else {
                    $results[] = [
                        'path' => $info['repo'],
                        'status' => 'FAIL',
                        'output' => 'Worker produced invalid result.',
                        'command' => 'N/A',
                        'code' => 1,
                        'log' => [],
                    ];
                }
            } else {
                $results[] = [
                    'path' => $info['repo'],
                    'status' => 'FAIL',
                    'output' => 'Worker result file missing.',
                    'command' => 'N/A',
                    'code' => 1,
                    'log' => [],
                ];
            }

            $completed++;
            $onComplete($completed, $total);
        }
    }

    return $results;
}

// ---------------------------------------------------------------------------
// Progress rendering
// ---------------------------------------------------------------------------

function canUseDynamicProgress(): bool
{
    return \function_exists('posix_isatty') && posix_isatty(\STDOUT);
}

function renderProgress(int $current, int $total, bool $dynamic, bool $final = false): void
{
    $total = max(1, $total);
    $ratio = min(1, $current / $total);
    $width = 28;
    $filled = (int) floor($ratio * $width);
    $bar = str_repeat('#', $filled).str_repeat('-', $width - $filled);
    $percent = str_pad((string) round($ratio * 100), 3, ' ', \STR_PAD_LEFT);
    $line = sprintf('  [%s] %s%% %d/%d', $bar, $percent, $current, $total);

    if ($dynamic) {
        echo "\r\033[2K".$line;
        if ($final) {
            echo PHP_EOL;
        }

        return;
    }

    echo $line.PHP_EOL;
}

// ---------------------------------------------------------------------------
// Result printing
// ---------------------------------------------------------------------------

function printResult(array $result, string $corpusDir, ConsoleStyle $io, bool $debug): void
{
    $label = formatRepoLabel($result['path'], $corpusDir);

    $detail = '';
    if ($debug) {
        $lines = [];
        if ([] !== ($result['log'] ?? [])) {
            $lines = array_merge($lines, $result['log']);
        }
        $detail = implode(PHP_EOL, $lines);
    } elseif ('' !== ($result['output'] ?? '')) {
        $detail = $result['output'];
    }

    switch ($result['status']) {
        case 'OK':
            $io->status($io->green('[OK]'), $label, $detail);
            break;
        case 'SKIP':
            $io->status($io->yellow('[SKIP]'), $label, $detail);
            break;
        case 'FAIL':
        default:
            $statusTag = -1 === ($result['code'] ?? 0) ? '[TIMEOUT]' : '[FAIL]';
            $io->status($io->red($statusTag), $label, $detail);
            break;
    }
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function main(array $argv): int
{
    $io = new ConsoleStyle();

    try {
        $options = parseArgs($argv);
    } catch (InvalidArgumentException $e) {
        $io->error($e->getMessage());
        printUsage();

        return 1;
    }

    if ($options['help']) {
        printUsage();

        return 0;
    }

    $corpusDir = realpath(__DIR__);
    if (false === $corpusDir) {
        $io->error('Unable to resolve corpus directory.');

        return 1;
    }

    $repos = findGitRepos($corpusDir);
    if ([] === $repos) {
        $io->info('No git repositories found in corpus/.');

        return 0;
    }

    // --- Resolve jobs ---
    $jobs = $options['jobs'];
    if (null === $jobs || '' === $jobs || 'auto' === $jobs) {
        $jobs = max(2, detectCpuCount() * 2);
    } else {
        $jobs = trim((string) $jobs);
        if (!ctype_digit($jobs)) {
            $io->error('The --jobs value must be a positive integer or "auto".');

            return 1;
        }
    }

    $jobs = (int) $jobs;
    if ($jobs < 1) {
        $io->error('The --jobs value must be a positive integer or "auto".');

        return 1;
    }

    if ($jobs > 1 && !supportsParallel()) {
        $io->warn('Parallel jobs requested but pcntl is unavailable; falling back to 1 job.');
        $jobs = 1;
    }

    // --- Resolve timeout ---
    $timeout = $options['timeout'];
    if (null === $timeout || '' === $timeout) {
        $timeout = 120;
    } else {
        $timeout = trim((string) $timeout);
        if (!ctype_digit($timeout)) {
            $io->error('The --timeout value must be a positive integer.');

            return 1;
        }
        $timeout = (int) $timeout;
    }

    $debug = (bool) $options['debug'];
    $force = (bool) $options['force'];

    $io->header('Corpus Updater');
    $io->info('Runtime : PHP '.PHP_VERSION);
    $io->info('Corpus  : '.$corpusDir);
    $io->info('Jobs    : '.$jobs);
    $io->info('Timeout : '.$timeout.'s per repo');
    $io->info('Force   : '.($force ? 'yes' : 'no'));
    $io->info('Debug   : '.($debug ? 'on' : 'off'));
    $io->info('Repos   : '.\count($repos));
    $io->info('');

    $dynamicProgress = canUseDynamicProgress() && !$debug;
    $startTime = microtime(true);

    if (1 === $jobs) {
        // Sequential: print each result immediately
        $results = [];
        $total = \count($repos);
        renderProgress(0, $total, $dynamicProgress);

        foreach ($repos as $i => $repo) {
            $result = processRepo($repo, $force, $corpusDir, $debug, $timeout);
            $results[] = $result;

            if ($debug) {
                printResult($result, $corpusDir, $io, $debug);
            }

            renderProgress($i + 1, $total, $dynamicProgress, $i + 1 >= $total);
        }
    } else {
        // Parallel: worker pool
        $onComplete = static function (int $current, int $total) use ($dynamicProgress): void {
            renderProgress($current, $total, $dynamicProgress, $current >= $total);
        };

        renderProgress(0, \count($repos), $dynamicProgress);
        $results = processReposParallel($repos, $jobs, $force, $corpusDir, $debug, $timeout, $onComplete);
    }

    $elapsed = microtime(true) - $startTime;
    $io->info('');

    // --- Print results (parallel mode deferred; sequential already printed in debug) ---
    if ($jobs > 1) {
        // Sort results by path to match repo order
        usort($results, static fn (array $a, array $b): int => strcmp($a['path'] ?? '', $b['path'] ?? ''));

        foreach ($results as $result) {
            printResult($result, $corpusDir, $io, $debug);
        }
    } elseif (!$debug) {
        // Sequential non-debug: print compact results
        foreach ($results as $result) {
            printResult($result, $corpusDir, $io, false);
        }
    }

    // --- Summary ---
    $ok = 0;
    $failed = 0;
    $skipped = 0;
    $timedOut = 0;

    foreach ($results as $result) {
        switch ($result['status']) {
            case 'OK':
                $ok++;
                break;
            case 'SKIP':
                $skipped++;
                break;
            default:
                if (-1 === ($result['code'] ?? 0)) {
                    $timedOut++;
                }
                $failed++;
                break;
        }
    }

    $io->info('');
    $io->info($io->bold('Summary'));
    $io->info('Updated  : '.$ok);
    $io->info('Failed   : '.$failed.($timedOut > 0 ? ' ('.$timedOut.' timed out)' : ''));
    $io->info('Skipped  : '.$skipped);
    $io->info('Elapsed  : '.round($elapsed, 1).'s');

    return $failed > 0 ? 1 : 0;
}

exit(main($argv));
