{
    "LintIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Represents a single linter diagnostic for a regex pattern.\n *\/\nfinal readonly class LintIssue\n{\n    public function __construct(\n        public string $id,\n        public string $message,\n        public ?int $offset = null,\n        public ?string $hint = null,\n    ) {}\n}\n",
    "TokenType.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\nenum TokenType: string\n{\n    \/** A single literal character (e.g., \"a\", \"1\"). *\/\n    case T_LITERAL = 'literal';\n\n    \/** A special character class type (e.g., \\d, \\s, \\w). *\/\n    case T_CHAR_TYPE = 'char_type';\n\n    \/** A group opening parenthesis \"(\". *\/\n    case T_GROUP_OPEN = 'group_open';\n\n    \/** A group closing parenthesis \")\". *\/\n    case T_GROUP_CLOSE = 'group_close';\n\n    \/** A special group opening sequence (e.g., \"(?\"). *\/\n    case T_GROUP_MODIFIER_OPEN = 'group_modifier_open';\n\n    \/** A character class opening bracket \"[\". *\/\n    case T_CHAR_CLASS_OPEN = 'char_class_open';\n\n    \/** A character class closing bracket \"]\". *\/\n    case T_CHAR_CLASS_CLOSE = 'char_class_close';\n\n    \/** A quantifier (e.g., \"*\", \"+\", \"?\", \"{n,m}\", \"*?\", \"++\", \"{n,m}+\"). *\/\n    case T_QUANTIFIER = 'quantifier';\n\n    \/** The alternation pipe \"|\". *\/\n    case T_ALTERNATION = 'alternation';\n\n    \/** The wildcard dot \".\". *\/\n    case T_DOT = 'dot';\n\n    \/** An anchor (e.g., \"^\", \"$\"). *\/\n    case T_ANCHOR = 'anchor';\n\n    \/** The end-of-file marker. *\/\n    case T_EOF = 'eof';\n\n    \/** A range operator \"-\" inside a character class. *\/\n    case T_RANGE = 'range';\n\n    \/** A negation operator \"^\" at the start of a character class. *\/\n    case T_NEGATION = 'negation';\n\n    \/** A backreference (e.g., \"\\1\", \"\\k<name>\"). *\/\n    case T_BACKREF = 'backref';\n\n    \/** A Unicode escape (e.g., \"\\xHH\", \"\\u{HHHH}\"). *\/\n    case T_UNICODE = 'unicode';\n\n    \/** A POSIX class inside a character class (e.g., \"[:alpha:]\"). *\/\n    case T_POSIX_CLASS = 'posix_class';\n\n    \/** An assertion (e.g., \\b, \\B, \\A, \\z, \\Z, \\G). *\/\n    case T_ASSERTION = 'assertion';\n\n    \/** A Unicode property (e.g., \\p{L}, \\P{^L}). *\/\n    case T_UNICODE_PROP = 'unicode_prop';\n\n    \/** An octal escape (e.g., \\o{777}). *\/\n    case T_OCTAL = 'octal';\n\n    \/** A legacy octal escape (e.g., \\012). *\/\n    case T_OCTAL_LEGACY = 'octal_legacy';\n\n    \/** A comment opening in group (?#). *\/\n    case T_COMMENT_OPEN = 'comment_open';\n\n    \/** A PCRE verb (e.g., \"(*FAIL)\", \"(*COMMIT)\"). *\/\n    case T_PCRE_VERB = 'pcre_verb';\n\n    \/** A \\g reference (e.g., \"\\g{1}\", \"\\g<name>\", \"\\g-1\"). *\/\n    case T_G_REFERENCE = 'g_reference';\n\n    \/** The \\K \"keep\" assertion. *\/\n    case T_KEEP = 'keep';\n\n    \/** A literal generated from an escaped sequence (e.g., \"\\*\"). *\/\n    case T_LITERAL_ESCAPED = 'literal_escaped';\n\n    \/** The \\Q sequence start. *\/\n    case T_QUOTE_MODE_START = 'quote_mode_start';\n\n    \/** The \\E sequence end. *\/\n    case T_QUOTE_MODE_END = 'quote_mode_end';\n\n    \/** A callout (e.g., \"(?C1)\", \"(?C\"arg\")\"). *\/\n    case T_CALLOUT = 'callout';\n\n    \/** A named Unicode character (e.g., \\N{name}). *\/\n    case T_UNICODE_NAMED = 'unicode_named';\n\n    \/** Control character escape (e.g., \\cM). *\/\n    case T_CONTROL_CHAR = 'control_char';\n\n    \/** Character class intersection operator (&&). *\/\n    case T_CLASS_INTERSECTION = 'class_intersection';\n\n    \/** Character class subtraction operator (--). *\/\n    case T_CLASS_SUBTRACTION = 'class_subtraction';\n}\n",
    "Regex.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\nuse RegexParser\\Cache\\CacheInterface;\nuse RegexParser\\Cache\\NullCache;\nuse RegexParser\\Exception\\LexerException;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Exception\\ResourceLimitException;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\ReDoS\\ReDoSAnalysis;\nuse RegexParser\\ReDoS\\ReDoSAnalyzer;\nuse RegexParser\\ReDoS\\ReDoSSeverity;\n\nfinal readonly class Regex\n{\n    public const DEFAULT_MAX_PATTERN_LENGTH = 100_000;\n    public const DEFAULT_MAX_LOOKBEHIND_LENGTH = 255;\n\n    \/**\n     * @param array<string> $redosIgnoredPatterns\n     *\/\n    private function __construct(\n        private int $maxPatternLength,\n        private int $maxLookbehindLength,\n        private CacheInterface $cache,\n        private array $redosIgnoredPatterns,\n    ) {}\n\n    \/**\n     * @param array<string, mixed> $options\n     *\/\n    public static function create(array $options = []): self\n    {\n        $parsedOptions = RegexOptions::fromArray($options);\n\n        $redosIgnoredPatterns = $parsedOptions->redosIgnoredPatterns;\n\n        return new self(\n            $parsedOptions->maxPatternLength,\n            $parsedOptions->maxLookbehindLength,\n            $parsedOptions->cache,\n            $redosIgnoredPatterns,\n        );\n    }\n\n    public function parse(string $regex): RegexNode\n    {\n        $ast = $this->doParse($regex, false);\n\n        return $ast instanceof RegexNode ? $ast : $ast->ast;\n    }\n\n    public function parseTolerant(string $regex): TolerantParseResult\n    {\n        $result = $this->doParse($regex, true);\n\n        return $result instanceof TolerantParseResult ? $result : new TolerantParseResult($result);\n    }\n\n    public function parsePattern(string $pattern, string $delimiter = '\/', string $flags = ''): RegexNode\n    {\n        if (1 !== \\strlen($delimiter) || ctype_alnum($delimiter)) {\n            throw new ParserException('Delimiter must be a single non-alphanumeric character.');\n        }\n\n        $regex = $delimiter.$pattern.$delimiter.$flags;\n\n        return $this->parse($regex);\n    }\n\n    public function validate(string $regex): ValidationResult\n    {\n        try {\n            $pattern = null;\n\n            try {\n                [$pattern] = $this->extractPatternAndFlags($regex);\n            } catch (ParserException) {\n            }\n\n            $ast = $this->parse($regex);\n            $ast->accept(new NodeVisitor\\ValidatorNodeVisitor($this->maxLookbehindLength, $pattern));\n            $score = $ast->accept(new NodeVisitor\\ComplexityScoreNodeVisitor());\n\n            $this->validatePcreRuntime($regex, $pattern);\n\n            return new ValidationResult(true, null, $score);\n        } catch (LexerException|ParserException $e) {\n            $message = $e->getMessage();\n            $snippet = $e->getVisualSnippet();\n            $hint = null;\n            $code = null;\n            $category = ValidationErrorCategory::SYNTAX;\n\n            if ($e instanceof Exception\\SemanticErrorException) {\n                $category = ValidationErrorCategory::SEMANTIC;\n                $hint = $e->getHint();\n                $code = $e->getErrorCode();\n            }\n\n            if ($e instanceof Exception\\PcreRuntimeException) {\n                $category = ValidationErrorCategory::PCRE_RUNTIME;\n                $code = $e->getErrorCode();\n            }\n\n            if ('' !== $snippet) {\n                $message .= \"\\n\".$snippet;\n            }\n\n            return new ValidationResult(\n                false,\n                $message,\n                0,\n                $category,\n                $e->getPosition(),\n                '' !== $snippet ? $snippet : null,\n                $hint,\n                $code,\n            );\n        }\n    }\n\n    public function isValid(string $regex): bool\n    {\n        return $this->validate($regex)->isValid();\n    }\n\n    public function assertValid(string $regex): void\n    {\n        $result = $this->validate($regex);\n        if (!$result->isValid()) {\n            $message = $result->getErrorMessage() ?? 'Invalid regex pattern.';\n            $offset = $result->getErrorOffset();\n            $pattern = null;\n\n            try {\n                [$pattern] = $this->extractPatternAndFlags($regex);\n            } catch (ParserException) {\n                $pattern = null;\n            }\n\n            if (ValidationErrorCategory::SEMANTIC === $result->getErrorCategory()) {\n                throw new Exception\\SemanticErrorException(\n                    $message,\n                    $offset,\n                    $pattern,\n                    null,\n                    $result->getErrorCode() ?? 'regex.semantic',\n                    $result->getHint(),\n                );\n            }\n\n            if (ValidationErrorCategory::PCRE_RUNTIME === $result->getErrorCategory()) {\n                throw new Exception\\PcreRuntimeException(\n                    $message,\n                    $offset,\n                    $pattern,\n                    null,\n                    $result->getErrorCode(),\n                );\n            }\n\n            throw new ParserException($message, $offset, $pattern);\n        }\n    }\n\n    public function analyzeReDoS(string $regex, ?ReDoSSeverity $threshold = null): ReDoSAnalysis\n    {\n        return (new ReDoSAnalyzer($this, array_values($this->redosIgnoredPatterns)))->analyze($regex, $threshold);\n    }\n\n    public function isSafe(string $regex, ?ReDoSSeverity $threshold = null): bool\n    {\n        $analysis = $this->analyzeReDoS($regex, $threshold);\n\n        return null === $threshold ? $analysis->isSafe() : !$analysis->exceedsThreshold($threshold);\n    }\n\n    \/**\n     * @return array{0: int, 1: int|null}\n     *\/\n    public function getLengthRange(string $regex)\n    {\n        return $this->parse($regex)->accept(new NodeVisitor\\LengthRangeNodeVisitor());\n    }\n\n    public function extractLiterals(string $regex): LiteralExtractionResult\n    {\n        $literalSet = $this->parse($regex)->accept(new NodeVisitor\\LiteralExtractorNodeVisitor());\n        $literals = array_values(array_unique(array_merge($literalSet->prefixes, $literalSet->suffixes)));\n        $patterns = [];\n\n        foreach ($literalSet->prefixes as $prefix) {\n            if ('' !== $prefix) {\n                $patterns[] = '^'.preg_quote($prefix, '\/');\n            }\n        }\n\n        foreach ($literalSet->suffixes as $suffix) {\n            if ('' !== $suffix) {\n                $patterns[] = preg_quote($suffix, '\/').'$';\n            }\n        }\n\n        $patterns = array_values(array_unique($patterns));\n\n        $confidence = $literalSet->complete && !$literalSet->isVoid()\n            ? 'high'\n            : (!$literalSet->isVoid() ? 'medium' : 'low');\n\n        return new LiteralExtractionResult($literals, $patterns, $confidence, $literalSet);\n    }\n\n    public function optimize(string $regex): OptimizationResult\n    {\n        $optimized = $this->transformAndCompile($regex, new NodeVisitor\\OptimizerNodeVisitor());\n        $changes = $optimized === $regex ? [] : ['Optimized pattern.'];\n\n        return new OptimizationResult($regex, $optimized, $changes);\n    }\n\n    public function modernize(string $regex): string\n    {\n        return $this->transformAndCompile($regex, new NodeVisitor\\ModernizerNodeVisitor());\n    }\n\n    public function generate(string $regex): string\n    {\n        return $this->parse($regex)->accept(new NodeVisitor\\SampleGeneratorNodeVisitor());\n    }\n\n    public function generateTestCases(string $regex): TestCaseGenerationResult\n    {\n        $cases = $this->parse($regex)->accept(new NodeVisitor\\TestCaseGeneratorNodeVisitor());\n\n        return new TestCaseGenerationResult(\n            array_values($cases['matching']),\n            array_values($cases['non_matching']),\n            ['Generated samples are heuristic; validate with real inputs.'],\n        );\n    }\n\n    public function visualize(string $regex): VisualizationResult\n    {\n        $mermaid = $this->parse($regex)->accept(new NodeVisitor\\MermaidNodeVisitor());\n\n        return new VisualizationResult($mermaid);\n    }\n\n    public function dump(string $regex): string\n    {\n        return $this->parse($regex)->accept(new NodeVisitor\\DumperNodeVisitor());\n    }\n\n    public function highlight(string $regex, string $format = 'auto'): string\n    {\n        if ('auto' === $format) {\n            $format = $this->isCli() ? 'cli' : 'html';\n        }\n\n        $visitor = match ($format) {\n            'cli' => new NodeVisitor\\ConsoleHighlighterVisitor(),\n            'html' => new NodeVisitor\\HtmlHighlighterVisitor(),\n            default => throw new \\InvalidArgumentException(\"Invalid format: $format\"),\n        };\n\n        return $this->parse($regex)->accept($visitor);\n    }\n\n    public function highlightCli(string $regex): string\n    {\n        return $this->highlight($regex, 'cli');\n    }\n\n    public function highlightHtml(string $regex): string\n    {\n        return $this->highlight($regex, 'html');\n    }\n\n    public function explain(string $regex, string $format = 'text'): string\n    {\n        $visitor = match ($format) {\n            'text' => new NodeVisitor\\ExplainNodeVisitor(),\n            'html' => new NodeVisitor\\HtmlExplainNodeVisitor(),\n            default => throw new \\InvalidArgumentException(\"Invalid format: $format\"),\n        };\n\n        return $this->parse($regex)->accept($visitor);\n    }\n\n    public function htmlExplain(string $regex): string\n    {\n        return $this->explain($regex, 'html');\n    }\n\n    \/**\n     * @param iterable<string> $regexes\n     *\/\n    public function warm(iterable $regexes): void\n    {\n        foreach ($regexes as $regex) {\n            $this->parse($regex); \/\/ hits cache\n            $this->analyzeReDoS($regex);\n        }\n    }\n\n    \/**\n     * @return array<string>\n     *\/\n    public function getRedosIgnoredPatterns(): array\n    {\n        return array_values($this->redosIgnoredPatterns);\n    }\n\n    public function getParser(): Parser\n    {\n        return new Parser();\n    }\n\n    public function getLexer(): Lexer\n    {\n        return new Lexer();\n    }\n\n    public function createTokenStream(string $pattern): TokenStream\n    {\n        return $this->getLexer()->tokenize($pattern);\n    }\n\n    \/**\n     * @return array{0: string, 1: string, 2: string}\n     *\/\n    public function extractPatternAndFlags(string $regex): array\n    {\n        \/\/ Trim leading whitespace to match PHP's PCRE behavior\n        $regex = ltrim($regex);\n\n        $len = \\strlen($regex);\n        if ($len < 2) {\n            throw new ParserException('Regex is too short. It must include delimiters.');\n        }\n\n        $delimiter = $regex[0];\n        \/\/ Handle bracket delimiters style: (pattern), [pattern], {pattern}, <pattern>\n        $closingDelimiter = match ($delimiter) {\n            '(' => ')',\n            '[' => ']',\n            '{' => '}',\n            '<' => '>',\n            default => $delimiter,\n        };\n\n        \/\/ Find the last occurrence of the closing delimiter that is NOT escaped\n        \/\/ We scan from the end to optimize for flags\n        for ($i = $len - 1; $i > 0; $i--) {\n            if ($regex[$i] === $closingDelimiter) {\n                \/\/ Check if escaped (count odd number of backslashes before it)\n                $escapes = 0;\n                for ($j = $i - 1; $j > 0 && '\\\\' === $regex[$j]; $j--) {\n                    $escapes++;\n                }\n\n                if (0 === $escapes % 2) {\n                    \/\/ Found the end delimiter\n                    $pattern = substr($regex, 1, $i - 1);\n                    $flags = substr($regex, $i + 1);\n\n                    \/\/ Validate flags (only allow standard PCRE flags)\n                    \/\/ n = NO_AUTO_CAPTURE, r = PCRE2_EXTRA_CASELESS_RESTRICT (unicode restricted)\n                    if (!preg_match('\/^[imsxADSUXJunr]*+$\/', $flags)) {\n                        \/\/ Find the invalid flag for a better error message\n                        $invalid = preg_replace('\/[imsxADSUXJunr]\/', '', $flags);\n\n                        throw new ParserException(\\sprintf('Unknown regex flag(s) found: \"%s\"', $invalid ?? $flags));\n                    }\n\n                    return [$pattern, $flags, $delimiter];\n                }\n            }\n        }\n\n        throw new ParserException(\\sprintf('No closing delimiter \"%s\" found.', $closingDelimiter));\n    }\n\n    private function validatePcreRuntime(string $regex, ?string $pattern): void\n    {\n        $errorMessage = null;\n        $handler = static function (int $severity, string $message) use (&$errorMessage): bool {\n            $errorMessage = $message;\n\n            return true;\n        };\n\n        set_error_handler($handler);\n        $result = @preg_match($regex, '');\n        restore_error_handler();\n\n        if (false === $result) {\n            $message = $errorMessage ?? preg_last_error_msg();\n            $message = '' !== $message ? $message : 'PCRE runtime error.';\n\n            throw new Exception\\PcreRuntimeException($message, null, $pattern, null, 'regex.pcre.runtime');\n        }\n    }\n\n    \/**\n     * @param NodeVisitor\\NodeVisitorInterface<Node\\NodeInterface> $transformer\n     *\/\n    private function transformAndCompile(string $regex, NodeVisitor\\NodeVisitorInterface $transformer): string\n    {\n        $ast = $this->parse($regex);\n        \/** @var Node\\NodeInterface $transformed *\/\n        $transformed = $ast->accept($transformer);\n\n        return $transformed->accept(new NodeVisitor\\CompilerNodeVisitor());\n    }\n\n    private function isCli(): bool\n    {\n        return \\PHP_SAPI === 'cli';\n    }\n\n    \/**\n     * @return array{0: \\RegexParser\\Node\\RegexNode|null, 1: string|null}\n     *\/\n    private function loadFromCache(string $regex): array\n    {\n        if ($this->cache instanceof NullCache) {\n            return [null, null];\n        }\n\n        $cacheKey = $this->cache->generateKey($regex);\n        $cached = $this->cache->load($cacheKey);\n\n        return [$cached instanceof RegexNode ? $cached : null, $cacheKey];\n    }\n\n    private function storeInCache(?string $cacheKey, RegexNode $ast): void\n    {\n        if (null === $cacheKey) {\n            return;\n        }\n\n        try {\n            $this->cache->write($cacheKey, self::compileCachePayload($ast));\n        } catch (\\Throwable) {\n        }\n    }\n\n    private static function compileCachePayload(RegexNode $ast): string\n    {\n        $serialized = serialize($ast);\n        $exported = var_export($serialized, true);\n\n        return <<<PHP\n            <?php\n\n            declare(strict_types=1);\n\n            return unserialize($exported, ['allowed_classes' => true]);\n\n            PHP;\n    }\n\n    \/**\n     * @return array{0: string, 1: string, 2: string, 3: int}\n     *\/\n    private function safeExtractPattern(string $regex): array\n    {\n        try {\n            [$pattern, $flags, $delimiter] = $this->extractPatternAndFlags($regex);\n            $pattern = (string) $pattern;\n            $flags = (string) $flags;\n            $delimiter = (string) $delimiter;\n            $length = \\strlen((string) $pattern);\n\n            return [$pattern, $flags, $delimiter, $length];\n        } catch (ParserException) {\n            return [$regex, '', '\/', \\strlen($regex)];\n        }\n    }\n\n    private function buildFallbackAst(string $pattern, string $flags, string $delimiter, int $patternLength, ?int $errorPosition): Node\\RegexNode\n    {\n        $value = null === $errorPosition ? $pattern : substr($pattern, 0, max(0, $errorPosition));\n        $literal = new Node\\LiteralNode($value, 0, \\strlen($value));\n        $sequence = new Node\\SequenceNode([$literal], 0, $literal->getEndPosition());\n\n        return new Node\\RegexNode($sequence, $flags, $delimiter, 0, $patternLength);\n    }\n\n    private function doParse(string $regex, bool $tolerant): RegexNode|TolerantParseResult\n    {\n        try {\n            $ast = $this->performParse($regex);\n\n            return $tolerant ? new TolerantParseResult($ast) : $ast;\n        } catch (LexerException|ParserException $e) {\n            if (!$tolerant) {\n                throw $e;\n            }\n\n            [$pattern, $flags, $delimiter, $length] = $this->safeExtractPattern($regex);\n            $ast = $this->buildFallbackAst($pattern, $flags, $delimiter, $length, $e->getPosition());\n\n            return new TolerantParseResult($ast, [$e]);\n        }\n    }\n\n    private function performParse(string $regex): RegexNode\n    {\n        if (\\strlen($regex) > $this->maxPatternLength) {\n            throw ResourceLimitException::withContext(\n                \\sprintf('Regex pattern exceeds maximum length of %d characters.', $this->maxPatternLength),\n                $this->maxPatternLength,\n                $regex,\n            );\n        }\n\n        [$cached, $cacheKey] = $this->loadFromCache($regex);\n        if (null !== $cached) {\n            return $cached;\n        }\n\n        [$pattern, $flags, $delimiter] = $this->extractPatternAndFlags($regex);\n\n        $stream = $this->getLexer()->tokenize($pattern);\n        $parser = $this->getParser();\n\n        $ast = $parser->parse($stream, $flags, $delimiter, \\strlen($pattern));\n\n        $this->storeInCache((string) $cacheKey, $ast);\n\n        return $ast;\n    }\n}\n",
    "Token.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Represents a single token from the lexer.\n *\/\nfinal readonly class Token\n{\n    public function __construct(\n        public TokenType $type,\n        public string $value,\n        public int $position,\n    ) {}\n}\n",
    "Cache\/FilesystemCache.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Cache;\n\nfinal readonly class FilesystemCache implements RemovableCacheInterface\n{\n    private string $directory;\n\n    public function __construct(string $directory, private string $extension = '.php')\n    {\n        $this->directory = rtrim($directory, '\\\\\/');\n    }\n\n    #[\\Override]\n    public function generateKey(string $regex): string\n    {\n        $hash = hash('sha256', $regex);\n\n        return \\sprintf(\n            '%s%s%s%s%s%s',\n            $this->directory,\n            \\DIRECTORY_SEPARATOR,\n            $hash[0],\n            $hash[1],\n            \\DIRECTORY_SEPARATOR,\n            substr($hash, 2).$this->extension,\n        );\n    }\n\n    #[\\Override]\n    public function write(string $key, string $content): void\n    {\n        $directory = \\dirname($key);\n        $this->createDirectory($directory);\n\n        $tmpFile = @tempnam($directory, 'regex');\n        if (false === $tmpFile) {\n            throw new \\RuntimeException(\\sprintf('Unable to create temporary file in \"%s\".', $directory));\n        }\n\n        if (false === @file_put_contents($tmpFile, $content)) {\n            @unlink($tmpFile);\n\n            throw new \\RuntimeException(\\sprintf('Failed to write cache file \"%s\".', $key));\n        }\n\n        if (!@rename($tmpFile, $key)) {\n            if (!@copy($tmpFile, $key)) {\n                @unlink($tmpFile);\n\n                throw new \\RuntimeException(\\sprintf('Failed to move cache file \"%s\".', $tmpFile));\n            }\n\n            @unlink($tmpFile);\n        }\n\n        @chmod($key, 0o666 & ~umask());\n\n        if (\\function_exists('opcache_invalidate')) {\n            @opcache_invalidate($key, true);\n        }\n    }\n\n    #[\\Override]\n    public function load(string $key): mixed\n    {\n        if (!is_file($key)) {\n            return null;\n        }\n\n        try {\n            \/* @psalm-suppress UnresolvableInclude *\/\n            return include $key;\n        } catch (\\Throwable) {\n            return null;\n        }\n    }\n\n    #[\\Override]\n    public function getTimestamp(string $key): int\n    {\n        return is_file($key) ? (int) filemtime($key) : 0;\n    }\n\n    #[\\Override]\n    public function clear(?string $regex = null): void\n    {\n        if (null !== $regex) {\n            $file = $this->generateKey($regex);\n            if (is_file($file)) {\n                @unlink($file);\n            }\n\n            return;\n        }\n\n        if (!is_dir($this->directory)) {\n            return;\n        }\n\n        $iterator = new \\RecursiveIteratorIterator(\n            new \\RecursiveDirectoryIterator($this->directory, \\RecursiveDirectoryIterator::SKIP_DOTS),\n            \\RecursiveIteratorIterator::CHILD_FIRST,\n        );\n\n        foreach ($iterator as $fileInfo) {\n            if (!$fileInfo instanceof \\SplFileInfo) {\n                continue;\n            }\n\n            $path = $fileInfo->getRealPath();\n            if (!\\is_string($path)) {\n                continue;\n            }\n\n            if ($fileInfo->isDir()) {\n                @rmdir($path);\n            } else {\n                @unlink($path);\n            }\n        }\n\n        @rmdir($this->directory);\n    }\n\n    private function createDirectory(string $directory): void\n    {\n        if (is_dir($directory)) {\n            return;\n        }\n\n        $umask = umask(0o002);\n\n        try {\n            if (!@mkdir($directory, 0o777, true) && !is_dir($directory)) {\n                throw new \\RuntimeException(\\sprintf('Unable to create the cache directory \"%s\".', $directory));\n            }\n        } finally {\n            umask($umask);\n        }\n    }\n}\n",
    "Cache\/NullCache.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Cache;\n\nfinal readonly class NullCache implements RemovableCacheInterface\n{\n    #[\\Override]\n    public function generateKey(string $regex): string\n    {\n        return hash('sha256', $regex);\n    }\n\n    #[\\Override]\n    public function write(string $key, string $content): void {}\n\n    #[\\Override]\n    public function load(string $key): mixed\n    {\n        return null;\n    }\n\n    #[\\Override]\n    public function getTimestamp(string $key): int\n    {\n        return 0;\n    }\n\n    #[\\Override]\n    public function clear(?string $regex = null): void {}\n}\n",
    "Cache\/PsrCacheAdapter.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Cache;\n\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse RegexParser\\Node\\RegexNode;\n\n\/**\n * PSR-6 bridge for AST caching.\n *\n * This adapter lets you plug a PSR-6 cache pool into the RegexParser cache\n * system. The Regex service passes a compiled cache payload string\n * (generated by {@see \\RegexParser\\Regex::compileCachePayload()}); this\n * adapter evaluates that payload once and stores the resulting RegexNode\n * instance directly in the pool so that subsequent reads are fast and\n * type-safe.\n *\/\nfinal readonly class PsrCacheAdapter implements RemovableCacheInterface\n{\n    public function __construct(\n        private CacheItemPoolInterface $pool,\n        private string $prefix = 'regex_',\n        private ?\\Closure $keyFactory = null\n    ) {}\n\n    public function generateKey(string $regex): string\n    {\n        if (null !== $this->keyFactory) {\n            $custom = ($this->keyFactory)($regex);\n\n            return $this->prefix.(\\is_string($custom) ? $custom : hash('sha256', serialize($custom)));\n        }\n\n        return $this->prefix.hash('sha256', $regex);\n    }\n\n    public function write(string $key, string $content): void\n    {\n        $item = $this->pool->getItem($key);\n\n        $value = $this->decodePayload($content);\n        $item->set($value ?? $content);\n\n        $this->pool->save($item);\n    }\n\n    public function load(string $key): mixed\n    {\n        $item = $this->pool->getItem($key);\n\n        return $item->isHit() ? $item->get() : null;\n    }\n\n    public function getTimestamp(string $key): int\n    {\n        \/\/ PSR-6 does not expose timestamps; return 0 (unknown).\n        return 0;\n    }\n\n    public function clear(?string $regex = null): void\n    {\n        if (null !== $regex) {\n            $this->pool->deleteItem($this->generateKey($regex));\n\n            return;\n        }\n\n        $this->pool->clear();\n    }\n\n    \/**\n     * Decodes the compiled cache payload string into a RegexNode instance.\n     *\n     * The Regex service passes a small PHP script generated by\n     * {@see \\RegexParser\\Regex::compileCachePayload()}. For PSR-6 caches we\n     * execute this script once and store the resulting AST object directly\n     * in the pool so that subsequent reads return a RegexNode instead of\n     * the raw payload string.\n     *\/\n    private function decodePayload(string $content): ?RegexNode\n    {\n        $serialized = $this->extractSerializedString($content);\n        if (null === $serialized) {\n            return null;\n        }\n\n        $value = @unserialize($serialized, ['allowed_classes' => true]);\n\n        return $value instanceof RegexNode ? $value : null;\n    }\n\n    \/**\n     * Extracts the serialized AST string from the generated payload without executing it.\n     *\/\n    private function extractSerializedString(string $content): ?string\n    {\n        $code = ltrim($content);\n        if (str_starts_with($code, '<?php')) {\n            $code = substr($code, 5);\n        }\n\n        $offset = stripos($code, 'unserialize(');\n        if (false === $offset) {\n            return null;\n        }\n\n        $argumentBlock = substr($code, $offset + \\strlen('unserialize('));\n        $commaPos = strpos($argumentBlock, ',');\n        if (false === $commaPos) {\n            return null;\n        }\n\n        $argument = trim(substr($argumentBlock, 0, $commaPos));\n        if ('' === $argument) {\n            return null;\n        }\n\n        if (\\in_array($argument[0], [\"'\", '\"'], true) && $argument[0] === substr($argument, -1)) {\n            $argument = substr($argument, 1, -1);\n        }\n\n        return stripcslashes($argument);\n    }\n}\n",
    "Cache\/CacheInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Cache;\n\ninterface CacheInterface\n{\n    public function generateKey(string $regex): string;\n\n    public function write(string $key, string $content): void;\n\n    public function load(string $key): mixed;\n\n    public function getTimestamp(string $key): int;\n}\n",
    "Cache\/RemovableCacheInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Cache;\n\ninterface RemovableCacheInterface extends CacheInterface\n{\n    public function clear(?string $regex = null): void;\n}\n",
    "Cache\/PsrSimpleCacheAdapter.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Cache;\n\nuse Psr\\SimpleCache\\CacheInterface;\nuse RegexParser\\Node\\RegexNode;\n\n\/**\n * PSR-16 bridge for AST caching.\n *\n * This adapter lets you plug a PSR-16 cache implementation into the\n * RegexParser cache system. It receives the compiled cache payload string\n * from the Regex service and stores the decoded RegexNode instance so\n * later reads can return the AST directly.\n *\/\nfinal readonly class PsrSimpleCacheAdapter implements RemovableCacheInterface\n{\n    public function __construct(\n        private CacheInterface $cache,\n        private string $prefix = 'regex_',\n        private ?\\Closure $keyFactory = null\n    ) {}\n\n    public function generateKey(string $regex): string\n    {\n        if (null !== $this->keyFactory) {\n            $custom = ($this->keyFactory)($regex);\n\n            return $this->prefix.(\\is_string($custom) ? $custom : hash('sha256', serialize($custom)));\n        }\n\n        return $this->prefix.hash('sha256', $regex);\n    }\n\n    public function write(string $key, string $content): void\n    {\n        $value = $this->decodePayload($content);\n\n        $this->cache->set($key, $value ?? $content);\n    }\n\n    public function load(string $key): mixed\n    {\n        $value = $this->cache->get($key);\n\n        return $value ?? null;\n    }\n\n    public function getTimestamp(string $key): int\n    {\n        return 0;\n    }\n\n    public function clear(?string $regex = null): void\n    {\n        if (null !== $regex) {\n            $this->cache->delete($this->generateKey($regex));\n\n            return;\n        }\n\n        $this->cache->clear();\n    }\n\n    \/**\n     * Decodes the compiled cache payload string into a RegexNode instance.\n     *\n     * The Regex service passes a small PHP script generated by\n     * {@see \\RegexParser\\Regex::compileCachePayload()}. For PSR-16 caches we\n     * execute this script once and store the resulting AST object directly\n     * in the cache so that subsequent reads return a RegexNode.\n     *\/\n    private function decodePayload(string $content): ?RegexNode\n    {\n        $serialized = $this->extractSerializedString($content);\n        if (null === $serialized) {\n            return null;\n        }\n\n        $value = @unserialize($serialized, ['allowed_classes' => true]);\n\n        return $value instanceof RegexNode ? $value : null;\n    }\n\n    \/**\n     * Extracts the serialized AST string from the generated payload without executing it.\n     *\/\n    private function extractSerializedString(string $content): ?string\n    {\n        $code = ltrim($content);\n        if (str_starts_with($code, '<?php')) {\n            $code = substr($code, 5);\n        }\n\n        $offset = stripos($code, 'unserialize(');\n        if (false === $offset) {\n            return null;\n        }\n\n        $argumentBlock = substr($code, $offset + \\strlen('unserialize('));\n        $commaPos = strpos($argumentBlock, ',');\n        if (false === $commaPos) {\n            return null;\n        }\n\n        $argument = trim(substr($argumentBlock, 0, $commaPos));\n        if ('' === $argument) {\n            return null;\n        }\n\n        if (\\in_array($argument[0], [\"'\", '\"'], true) && $argument[0] === substr($argument, -1)) {\n            $argument = substr($argument, 1, -1);\n        }\n\n        return stripcslashes($argument);\n    }\n}\n",
    "NodeVisitor\/HtmlExplainNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\QuantifierType;\n\n\/**\n * A visitor that explains the AST in an HTML format for rich display.\n *\n * Purpose: This visitor traverses the Abstract Syntax Tree (AST) of a regular expression\n * and generates a human-readable explanation of its components in HTML format.\n * This is particularly useful for visualizing complex regex patterns, making them\n * easier to understand for developers and non-technical users alike. It breaks down\n * the regex into its logical parts and describes what each part matches.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nfinal class HtmlExplainNodeVisitor extends AbstractNodeVisitor\n{\n    private const CHAR_TYPE_MAP = [\n        'd' => 'any digit (0-9)',\n        'D' => 'any non-digit',\n        's' => 'any whitespace character',\n        'S' => 'any non-whitespace character',\n        'w' => 'any \"word\" character (alphanumeric or _)',\n        'W' => 'any \"non-word\" character',\n        'h' => 'any horizontal whitespace',\n        'H' => 'any non-horizontal whitespace',\n        'v' => 'any vertical whitespace',\n        'V' => 'any non-vertical whitespace',\n        'R' => 'a generic newline (\\\\r\\\\n, \\\\r, or \\\\n)',\n    ];\n\n    private const ANCHOR_MAP = [\n        '^' => 'the start of the string (or line, with \/m flag)',\n        '$' => 'the end of the string (or line, with \/m flag)',\n    ];\n\n    private const ASSERTION_MAP = [\n        'A' => 'the absolute start of the string',\n        'z' => 'the absolute end of the string',\n        'Z' => 'the end of the string (before final newline)',\n        'G' => 'the position of the last successful match',\n        'b' => 'a word boundary',\n        'B' => 'a non-word boundary',\n    ];\n\n    \/**\n     * Visits a RegexNode and generates an HTML explanation for the entire regex.\n     *\n     * Purpose: This is the entry point for generating an HTML explanation of a regular expression.\n     * It wraps the explanation of the main pattern with overall regex context, including any flags,\n     * providing a structured and comprehensive overview.\n     *\n     * @param Node\\RegexNode $node the `RegexNode` representing the entire regular expression\n     *\n     * @return string an HTML string explaining the regex pattern and its flags\n     *\n     * @example\n     * ```php\n     * \/\/ Assuming $regexNode is the root of your parsed AST for '\/hello\/i'\n     * $visitor = new HtmlExplainNodeVisitor();\n     * $html = $regexNode->accept($visitor);\n     * \/\/ $html will contain a div with the explanation of \"hello\" and mention of the 'i' flag.\n     * ```\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        $patternExplain = $node->pattern->accept($this);\n        $flags = $node->flags ? $this->e(' (with flags: '.$node->flags.')') : '';\n\n        return \\sprintf(\n            \"<div class=\\\"regex-explain\\\">\\n<strong>Regex matches%s:<\/strong>\\n<ul>%s<\/ul>\\n<\/div>\",\n            $flags,\n            $patternExplain,\n        );\n    }\n\n    \/**\n     * Visits an AlternationNode and generates an HTML explanation for its alternatives.\n     *\n     * Purpose: This method explains the \"OR\" logic in a regex (e.g., `cat|dog`).\n     * It clearly separates each alternative in the HTML output, making it easy to\n     * understand that the regex engine will try to match one of the provided options.\n     *\n     * @param Node\\AlternationNode $node the `AlternationNode` representing a choice between patterns\n     *\n     * @return string an HTML string explaining the alternation, with each alternative listed\n     *\n     * @example\n     * ```php\n     * \/\/ For an alternation like `(apple|banana|orange)`\n     * $alternationNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><strong>EITHER:<\/strong><ul>...explanation of apple...<\/ul><\/li>\n     * \/\/ <li><strong>OR:<\/strong><ul>...explanation of banana...<\/ul><\/li>\n     * \/\/ <li><strong>OR:<\/strong><ul>...explanation of orange...<\/ul><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        $alts = array_map(\n            fn (Node\\NodeInterface $alt) => $alt->accept($this),\n            $node->alternatives,\n        );\n\n        return \\sprintf(\n            \"<li><strong>EITHER:<\/strong>\\n<ul>%s<\/ul>\\n<\/li>\",\n            implode(\"\\n<li><strong>OR:<\/strong>\\n<ul>\", $alts),\n        );\n    }\n\n    \/**\n     * Visits a SequenceNode and generates an HTML explanation for its child elements.\n     *\n     * Purpose: This method explains a linear sequence of regex elements (e.g., `abc`).\n     * It concatenates the HTML explanations of all child nodes, preserving their order,\n     * to show that these elements must match consecutively.\n     *\n     * @param Node\\SequenceNode $node the `SequenceNode` representing a series of regex components\n     *\n     * @return string an HTML string concatenating the explanations of its child nodes\n     *\n     * @example\n     * ```php\n     * \/\/ For a sequence `foo` (represented as a sequence of 'f', 'o', 'o' literals)\n     * $sequenceNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li>Literal: <strong>'f'<\/strong><\/li>\n     * \/\/ <li>Literal: <strong>'o'<\/strong><\/li>\n     * \/\/ <li>Literal: <strong>'o'<\/strong><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        $parts = array_map(fn ($child) => $child->accept($this), $node->children);\n        $parts = array_filter($parts, fn ($part) => '' !== $part);\n\n        return implode(\"\\n\", $parts);\n    }\n\n    \/**\n     * Visits a GroupNode and generates an HTML explanation for the group and its content.\n     *\n     * Purpose: This method provides detailed explanations for various types of groups\n     * (capturing, non-capturing, named, lookarounds, atomic, etc.). It clearly labels\n     * the group's purpose and then recursively explains its internal pattern, helping\n     * users understand the role of each grouping construct.\n     *\n     * @param Node\\GroupNode $node the `GroupNode` representing a specific grouping construct\n     *\n     * @return string an HTML string explaining the group's type and its child's pattern\n     *\n     * @example\n     * ```php\n     * \/\/ For a capturing group `(abc)`\n     * $groupNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><span title=\"Start Capturing Group\"><strong>Start Capturing Group:<\/strong><\/span>\n     * \/\/ <ul><li>...explanation of abc...<\/li><\/ul><\/li>\n     *\n     * \/\/ For a positive lookahead `(?=test)`\n     * $groupNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><span title=\"Start Positive Lookahead\"><strong>Start Positive Lookahead:<\/strong><\/span>\n     * \/\/ <ul><li>...explanation of test...<\/li><\/ul><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $childExplain = $node->child->accept($this);\n        $type = match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => 'Start Capturing Group',\n            GroupType::T_GROUP_NON_CAPTURING => 'Start Non-Capturing Group',\n            GroupType::T_GROUP_NAMED => \\sprintf(\"Start Capturing Group (named: '%s')\", $this->e($node->name)),\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => 'Start Positive Lookahead',\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => 'Start Negative Lookahead',\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => 'Start Positive Lookbehind',\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => 'Start Negative Lookbehind',\n            GroupType::T_GROUP_ATOMIC => 'Start Atomic Group',\n            GroupType::T_GROUP_BRANCH_RESET => 'Start Branch Reset Group',\n            GroupType::T_GROUP_INLINE_FLAGS => \\sprintf(\"Start Group (with flags: '%s')\", $this->e($node->flags)),\n        };\n\n        return \\sprintf(\n            \"<li><span title=\\\"%s\\\"><strong>%s:<\/strong><\/span>\\n<ul>%s<\/ul>\\n<\/li>\",\n            $this->e($type),\n            $this->e($type),\n            $childExplain,\n        );\n    }\n\n    \/**\n     * Visits a QuantifierNode and generates an HTML explanation for the repetition.\n     *\n     * Purpose: This method explains how many times a preceding element is allowed to repeat\n     * (e.g., `*`, `+`, `{1,5}`). It also clarifies the \"greediness\" type (greedy, lazy, possessive).\n     * The explanation is integrated with the quantified element's explanation for clarity.\n     *\n     * @param Node\\QuantifierNode $node the `QuantifierNode` representing a repetition operator\n     *\n     * @return string an HTML string explaining the quantifier and its quantified child\n     *\n     * @example\n     * ```php\n     * \/\/ For a quantifier `a+?`\n     * $quantifierNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li>(one or more times (as few as possible)) Literal: <strong>'a'<\/strong><\/li>\n     *\n     * \/\/ For a complex quantified group `(foo){2,5}`\n     * $quantifierNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><strong>Quantifier (between 2 and 5 times):<\/strong>\n     * \/\/ <ul><li>...explanation of foo...<\/li><\/ul><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        $childExplain = $node->node->accept($this);\n        $quantExplain = $this->explainQuantifierValue($node->quantifier, $node->type);\n\n        \/\/ If the child is simple (one line <li>), put it on one line.\n        if (str_starts_with((string) $childExplain, '<li>') && !str_contains(substr((string) $childExplain, 4), '<li>')) {\n            \/\/ Inject the quantifier explanation into the child's <li>\n            return str_replace('<li>', \\sprintf('<li>(%s) ', $this->e($quantExplain)), (string) $childExplain);\n        }\n\n        \/\/ If the child is complex, wrap it\n        return \\sprintf(\n            \"<li><strong>Quantifier (%s):<\/strong>\\n<ul>%s<\/ul>\\n<\/li>\",\n            $this->e($quantExplain),\n            $childExplain,\n        );\n    }\n\n    \/**\n     * Visits a LiteralNode and generates an HTML explanation for the literal character(s).\n     *\n     * Purpose: This method explains literal characters or strings (e.g., `a`, `hello`).\n     * It formats the literal value for display, including handling special characters\n     * like newlines (`\\n`) for better readability in the HTML output.\n     *\n     * @param Node\\LiteralNode $node the `LiteralNode` representing a literal character or string\n     *\n     * @return string an HTML string explaining the literal value\n     *\n     * @example\n     * ```php\n     * \/\/ For a literal `a`\n     * $literalNode->accept($visitor); \/\/ Returns HTML like: <li>Literal: <strong>'a'<\/strong><\/li>\n     *\n     * \/\/ For a literal newline `\\n`\n     * $literalNode->accept($visitor); \/\/ Returns HTML like: <li>Literal: <strong>'\\n' (newline)<\/strong><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        $explanation = $this->explainLiteral($node->value);\n\n        return \\sprintf(\n            '<li><span title=\"Literal: %s\">Literal: <strong>%s<\/strong><\/span><\/li>',\n            $this->e($explanation),\n            $this->e($explanation),\n        );\n    }\n\n    \/**\n     * Visits a CharTypeNode and generates an HTML explanation for the character type.\n     *\n     * Purpose: This method explains predefined character types (e.g., `\\d` for digit, `\\s` for whitespace).\n     * It provides a human-readable description of what the character type matches, enhancing clarity\n     * in the HTML output.\n     *\n     * @param Node\\CharTypeNode $node the `CharTypeNode` representing a predefined character type\n     *\n     * @return string an HTML string explaining the character type\n     *\n     * @example\n     * ```php\n     * \/\/ For a character type `\\d`\n     * $charTypeNode->accept($visitor);\n     * \/\/ Returns HTML like: <li>Character Type: <strong>\\d<\/strong> (any digit (0-9))<\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        $explanation = self::CHAR_TYPE_MAP[$node->value] ?? 'unknown (\\\\'.$node->value.')';\n\n        return \\sprintf(\n            '<li><span title=\"Character Type: %s\">Character Type: <strong>\\%s<\/strong> (%s)<\/span><\/li>',\n            $this->e($explanation),\n            $this->e($node->value),\n            $this->e($explanation),\n        );\n    }\n\n    \/**\n     * Visits a DotNode and generates an HTML explanation for the wildcard dot.\n     *\n     * Purpose: This method explains the wildcard dot (`.`) character. It provides a simple\n     * description indicating that it matches \"any character\" (with caveats depending on flags),\n     * which is helpful for understanding its broad matching capability in the HTML output.\n     *\n     * @param Node\\DotNode $node the `DotNode` representing the wildcard dot character\n     *\n     * @return string an HTML string explaining the wildcard dot\n     *\n     * @example\n     * ```php\n     * \/\/ For a dot `.`\n     * $dotNode->accept($visitor);\n     * \/\/ Returns HTML like: <li>Wildcard: <strong>.<\/strong> (any character (except newline, unless \/s flag is used))<\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        $explanation = 'any character (except newline, unless \/s flag is used)';\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Wildcard: <strong>.<\/strong> (%s)<\/span><\/li>',\n            $this->e($explanation),\n            $this->e($explanation),\n        );\n    }\n\n    \/**\n     * Visits an AnchorNode and generates an HTML explanation for the positional anchor.\n     *\n     * Purpose: This method explains positional anchors like `^` (start of line) or `$` (end of line).\n     * It provides a clear description of what position the anchor asserts, which is crucial for\n     * understanding boundary matching in the HTML output.\n     *\n     * @param Node\\AnchorNode $node the `AnchorNode` representing a positional anchor\n     *\n     * @return string an HTML string explaining the anchor\n     *\n     * @example\n     * ```php\n     * \/\/ For an anchor `^`\n     * $anchorNode->accept($visitor);\n     * \/\/ Returns HTML like: <li>Anchor: <strong>^<\/strong> (the start of the string (or line, with \/m flag))<\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        $explanation = self::ANCHOR_MAP[$node->value] ?? $node->value;\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Anchor: <strong>%s<\/strong> (%s)<\/span><\/li>',\n            $this->e($explanation),\n            $this->e($node->value),\n            $this->e($explanation),\n        );\n    }\n\n    \/**\n     * Visits an AssertionNode and generates an HTML explanation for the zero-width assertion.\n     *\n     * Purpose: This method explains zero-width assertions like `\\b` (word boundary) or `\\A` (start of subject).\n     * It displays the assertion value and its meaning, helping users understand conditions that must be met\n     * without consuming characters, presented clearly in HTML.\n     *\n     * @param Node\\AssertionNode $node the `AssertionNode` representing a zero-width assertion\n     *\n     * @return string an HTML string explaining the assertion\n     *\n     * @example\n     * ```php\n     * \/\/ For an assertion `\\b`\n     * $assertionNode->accept($visitor);\n     * \/\/ Returns HTML like: <li>Assertion: <strong>\\b<\/strong> (a word boundary)<\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        $explanation = self::ASSERTION_MAP[$node->value] ?? '\\\\'.$node->value;\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Assertion: <strong>\\%s<\/strong> (%s)<\/span><\/li>',\n            $this->e($explanation),\n            $this->e($node->value),\n            $this->e($explanation),\n        );\n    }\n\n    \/**\n     * Visits a KeepNode and generates an HTML explanation for the `\\K` assertion.\n     *\n     * Purpose: This method explains the `\\K` \"keep\" assertion. It indicates that the\n     * match start position is reset at this point, which is important for understanding\n     * how the final matched string is determined. The explanation is provided in HTML.\n     *\n     * @param Node\\KeepNode $node the `KeepNode` representing the `\\K` assertion\n     *\n     * @return string an HTML string explaining the `\\K` assertion\n     *\n     * @example\n     * ```php\n     * \/\/ For a keep assertion `\\K`\n     * $keepNode->accept($visitor);\n     * \/\/ Returns HTML like: <li>Assertion: <strong>\\K<\/strong> (\\K (reset match start))<\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        $explanation = '\\K (reset match start)';\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Assertion: <strong>\\K<\/strong> (%s)<\/span><\/li>',\n            $this->e($explanation),\n            $this->e($explanation),\n        );\n    }\n\n    \/**\n     * Visits a CharClassNode and generates an HTML explanation for the character set.\n     *\n     * Purpose: This method explains character sets (e.g., `[a-z]`, `[^0-9]`). It determines\n     * if the class is negated and lists its constituent parts, providing a clear HTML\n     * representation of the characters that are (or are not) matched.\n     *\n     * @param Node\\CharClassNode $node the `CharClassNode` representing a character class\n     *\n     * @return string an HTML string explaining the character class\n     *\n     * @example\n     * ```php\n     * \/\/ For a character class `[a-zA-Z]`\n     * $charClassNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"Character Class: any character in [ 'a', 'Z' ]\">Character Class: [ 'a', 'Z' ]<\/span><\/li>\n     *\n     * \/\/ For a negated character class `[^0-9]`\n     * $charClassNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"Character Class: any character NOT in [ '0', '9' ]\">Character Class: [ <strong>NOT<\/strong> '0', '9' ]<\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $neg = $node->isNegated ? '<strong>NOT<\/strong> ' : '';\n        $expressionParts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        $explainedParts = array_map(fn (Node\\NodeInterface $part) => $part->accept($this), $expressionParts);\n\n        \/\/ Char class parts are just strings, not <li>\n        $parts = array_map(strip_tags(...), $explainedParts);\n\n        $explanation = \\sprintf('any character %sin [ %s ]', $neg, implode(', ', $parts));\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Character Class: [ %s%s ]<\/span><\/li>',\n            $this->e(strip_tags($explanation)),\n            $neg,\n            $this->e(implode(', ', $parts)),\n        );\n    }\n\n    \/**\n     * Visits a RangeNode and generates an HTML explanation for the character range.\n     *\n     * Purpose: This method explains character ranges within a character class (e.g., `a-z`).\n     * It processes the start and end characters of the range, providing a clear HTML\n     * representation of the inclusive character set.\n     *\n     * @param Node\\RangeNode $node the `RangeNode` representing a character range\n     *\n     * @return string an HTML string explaining the character range\n     *\n     * @example\n     * ```php\n     * \/\/ For a range `a-z` inside a character class\n     * $rangeNode->accept($visitor); \/\/ Returns HTML like: Range: from 'a' to 'z'\n     * ```\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        $start = ($node->start instanceof Node\\LiteralNode)\n            ? $this->explainLiteral($node->start->value)\n            : $node->start->accept($this);\n\n        $end = ($node->end instanceof Node\\LiteralNode)\n            ? $this->explainLiteral($node->end->value)\n            : $node->end->accept($this);\n\n        return \\sprintf('Range: from %s to %s', $this->e((string) $start), $this->e((string) $end));\n    }\n\n    \/**\n     * Visits a BackrefNode and generates an HTML explanation for the backreference.\n     *\n     * Purpose: This method explains backreferences to previously captured groups. It clearly\n     * indicates which group is being referenced (by number or name), which is essential for\n     * understanding patterns that match repeated text, presented in HTML.\n     *\n     * @param Node\\BackrefNode $node the `BackrefNode` representing a backreference\n     *\n     * @return string an HTML string explaining the backreference\n     *\n     * @example\n     * ```php\n     * \/\/ For a backreference `\\1`\n     * $backrefNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"matches text from group \"1\"\">Backreference: <strong>\\1<\/strong><\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        $explanation = \\sprintf('matches text from group \"%s\"', $node->ref);\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Backreference: <strong>\\%s<\/strong><\/span><\/li>',\n            $this->e($explanation),\n            $this->e($node->ref),\n        );\n    }\n\n    \/**\n     * Visits a UnicodeNode and generates an HTML explanation for the Unicode character.\n     *\n     * Purpose: This method explains Unicode characters specified by their hexadecimal code points.\n     * It displays the code, helping users understand the exact character being matched, especially\n     * for non-ASCII characters, presented clearly in HTML.\n     *\n     * @param Node\\UnicodeNode $node the `UnicodeNode` representing a Unicode character escape\n     *\n     * @return string an HTML string explaining the Unicode character\n     *\n     * @example\n     * ```php\n     * \/\/ For a Unicode character `\\x{2603}` (snowman)\n     * $unicodeNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"Unicode: {2603}\">Unicode: <strong>{2603}<\/strong><\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"Unicode: %s\">Unicode: <strong>%s<\/strong><\/span><\/li>',\n            $this->e($node->code),\n            $this->e($node->code),\n        );\n    }\n\n    \/**\n     * Visits a UnicodePropNode and generates an HTML explanation for the Unicode property.\n     *\n     * Purpose: This method explains Unicode character properties (e.g., `\\p{L}` for letters).\n     * It displays the property name and whether it's matching or non-matching, allowing users\n     * to understand character matching based on Unicode categories, presented in HTML.\n     *\n     * @param Node\\UnicodePropNode $node the `UnicodePropNode` representing a Unicode property\n     *\n     * @return string an HTML string explaining the Unicode property\n     *\n     * @example\n     * ```php\n     * \/\/ For a Unicode property `\\p{L}`\n     * $unicodePropNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"any character matching \"L\"\">Unicode Property: <strong>\\p{L}<\/strong><\/span><\/li>\n     *\n     * \/\/ For a negated Unicode property `\\P{N}`\n     * $unicodePropNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"any character non-matching \"N\"\">Unicode Property: <strong>\\P{N}<\/strong><\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        $type = str_starts_with($node->prop, '^') ? 'non-matching' : 'matching';\n        $prop = ltrim($node->prop, '^');\n        $explanation = \\sprintf('any character %s \"%s\"', $type, $prop);\n        $prefix = str_starts_with($node->prop, '^') ? 'P' : 'p';\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Unicode Property: <strong>\\%s{%s}<\/strong><\/span><\/li>',\n            $this->e($explanation),\n            $prefix,\n            $this->e($prop),\n        );\n    }\n\n    \/**\n     * Visits a PosixClassNode and generates an HTML explanation for the POSIX character class.\n     *\n     * Purpose: This method explains POSIX character classes (e.g., `[:alpha:]`).\n     * It displays the class name, providing a clear HTML representation of these predefined\n     * character sets.\n     *\n     * @param Node\\PosixClassNode $node the `PosixClassNode` representing a POSIX character class\n     *\n     * @return string an HTML string explaining the POSIX character class\n     *\n     * @example\n     * ```php\n     * \/\/ For a POSIX class `[:digit:]`\n     * $posixClassNode->accept($visitor); \/\/ Returns HTML like: POSIX Class: [[:digit:]]\n     * ```\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return \\sprintf('<li>POSIX Class: [[:%s:]]<\/li>', $this->e($node->class));\n    }\n\n    \/**\n     * Visits a CommentNode and generates an HTML explanation for the inline comment.\n     *\n     * Purpose: This method explains inline comments within the regex. While comments\n     * don't affect matching, displaying them helps in understanding the original author's\n     * intent and provides context for complex patterns, presented in HTML.\n     *\n     * @param Node\\CommentNode $node the `CommentNode` representing an inline comment\n     *\n     * @return string an HTML string explaining the comment\n     *\n     * @example\n     * ```php\n     * \/\/ For a comment `(?# This is a comment)`\n     * $commentNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"Comment\" style=\"color: #888; font-style: italic;\">Comment: This is a comment<\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"Comment\" style=\"color: #888; font-style: italic;\">Comment: %s<\/span><\/li>',\n            $this->e($node->comment),\n        );\n    }\n\n    \/**\n     * Visits a ConditionalNode and generates an HTML explanation for the conditional construct.\n     *\n     * Purpose: This method explains conditional constructs (if-then-else logic) in a regex.\n     * It clearly separates the condition, the \"if true\" branch, and the \"if false\" branch\n     * (if present), making complex branching patterns easier to understand in HTML.\n     *\n     * @param Node\\ConditionalNode $node the `ConditionalNode` representing a conditional sub-pattern\n     *\n     * @return string an HTML string explaining the conditional construct\n     *\n     * @example\n     * ```php\n     * \/\/ For a conditional `(?(1)yes|no)`\n     * $conditionalNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><strong>Conditional: IF<\/strong> (explanation of condition) <strong>THEN:<\/strong>\n     * \/\/ <ul>...explanation of yes...<\/ul>\n     * \/\/ <strong>ELSE:<\/strong>\n     * \/\/ <ul>...explanation of no...<\/ul><\/li>\n     *\n     * \/\/ For a conditional `(?(DEFINE)pattern)`\n     * $conditionalNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><strong>Conditional: IF<\/strong> (explanation of DEFINE) <strong>THEN:<\/strong>\n     * \/\/ <ul>...explanation of pattern...<\/ul><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        $cond = $node->condition->accept($this);\n        $yes = $node->yes->accept($this);\n\n        \/\/ Check if the 'no' branch is an empty literal node\n        $hasElseBranch = !($node->no instanceof Node\\LiteralNode && '' === $node->no->value);\n        $no = $hasElseBranch ? $node->no->accept($this) : '';\n\n        \/\/ Condition node will be a <li>, just need its text\n        $condText = trim(strip_tags((string) $cond));\n\n        if ('' === $no || '<li><\/li>' === $no) {\n            return \\sprintf(\n                \"<li><strong>Conditional: IF<\/strong> (%s) <strong>THEN:<\/strong>\\n<ul>%s<\/ul>\\n<\/li>\",\n                $this->e($condText),\n                $yes,\n            );\n        }\n\n        return \\sprintf(\n            \"<li><strong>Conditional: IF<\/strong> (%s) <strong>THEN:<\/strong>\\n<ul>%s<\/ul>\\n<strong>ELSE:<\/strong>\\n<ul>%s<\/ul>\\n<\/li>\",\n            $this->e($condText),\n            $yes,\n            $no,\n        );\n    }\n\n    \/**\n     * Visits a SubroutineNode and generates an HTML explanation for the subroutine call.\n     *\n     * Purpose: This method explains subroutine calls within the regex. It displays the\n     * reference (e.g., group number or name) of the pattern being called, helping to\n     * understand recursive or reused patterns, presented in HTML.\n     *\n     * @param Node\\SubroutineNode $node the `SubroutineNode` representing a subroutine call\n     *\n     * @return string an HTML string explaining the subroutine call\n     *\n     * @example\n     * ```php\n     * \/\/ For a subroutine call `(?&my_pattern)`\n     * $subroutineNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"recurses to group my_pattern\">Subroutine Call: <strong>(?&my_pattern)<\/strong><\/span><\/li>\n     *\n     * \/\/ For a recursive call to the entire pattern `(?R)`\n     * $subroutineNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"recurses to the entire pattern\">Subroutine Call: <strong>(?R)<\/strong><\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        $ref = match ($node->reference) {\n            'R', '0' => 'the entire pattern',\n            default => 'group '.$this->e($node->reference),\n        };\n        $explanation = \\sprintf('recurses to %s', $ref);\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Subroutine Call: <strong>(%s%s)<\/strong><\/span><\/li>',\n            $this->e($explanation),\n            $this->e($node->syntax),\n            $this->e($node->reference),\n        );\n    }\n\n    \/**\n     * Visits a PcreVerbNode and generates an HTML explanation for the PCRE control verb.\n     *\n     * Purpose: This method explains PCRE control verbs (e.g., `(*FAIL)`, `(*COMMIT)`).\n     * It displays the verb, providing insight into how the regex engine's backtracking\n     * behavior is being manipulated, presented in HTML.\n     *\n     * @param Node\\PcreVerbNode $node the `PcreVerbNode` representing a PCRE verb\n     *\n     * @return string an HTML string explaining the PCRE verb\n     *\n     * @example\n     * ```php\n     * \/\/ For a PCRE verb `(*FAIL)`\n     * $pcreVerbNode->accept($visitor);\n     * \/\/ Returns HTML like: <li><span title=\"PCRE Verb\">PCRE Verb: <strong>(*FAIL)<\/strong><\/span><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"PCRE Verb\">PCRE Verb: <strong>(*%s)<\/strong><\/span><\/li>',\n            $this->e($node->verb),\n        );\n    }\n\n    \/**\n     * Visits a DefineNode and generates an HTML explanation for the `(?(DEFINE)...)` block.\n     *\n     * Purpose: This method explains the `(?(DEFINE)...)` block, which is used to define\n     * named sub-patterns for later reuse. It processes the content of the define block\n     * and explains that these patterns are defined without matching, helping to understand\n     * the library of patterns available, presented in HTML.\n     *\n     * @param Node\\DefineNode $node The `DefineNode` representing a `(?(DEFINE)...)` block.\n     *\n     * @return string an HTML string explaining the DEFINE block and its content\n     *\n     * @example\n     * ```php\n     * \/\/ For a DEFINE block `(?(DEFINE)(?<digit>\\d))`\n     * $defineNode->accept($visitor);\n     * \/\/ Returns HTML like:\n     * \/\/ <li><strong>DEFINE Block<\/strong> (defines subpatterns without matching):\n     * \/\/ <ul><li>...explanation of (?<digit>\\d)...<\/li><\/ul><\/li>\n     * ```\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        $content = $node->content->accept($this);\n\n        return \\sprintf(\n            \"<li><strong>DEFINE Block<\/strong> (defines subpatterns without matching):\\n<ul>%s<\/ul>\\n<\/li>\",\n            $content,\n        );\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        $explanation = \\sprintf('sets the match limit to %d', $node->limit);\n\n        return \\sprintf(\n            '<li><span title=\"%s\">PCRE Verb: <strong>(*LIMIT_MATCH=%d)<\/strong><\/span><\/li>',\n            $this->e($explanation),\n            $node->limit,\n        );\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        $argument = $node->isStringIdentifier ? '\"'.$node->identifier.'\"' : (string) $node->identifier;\n        $explanation = \\sprintf('passes control to user function with argument %s', $argument);\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Callout: <strong>(?C%s)<\/strong><\/span><\/li>',\n            $this->e($explanation),\n            $this->e($argument),\n        );\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): string\n    {\n        $title = match ($node->type) {\n            Node\\CharLiteralType::UNICODE => 'Unicode character escape',\n            Node\\CharLiteralType::UNICODE_NAMED => 'Unicode named character',\n            Node\\CharLiteralType::OCTAL => 'Octal character escape',\n            Node\\CharLiteralType::OCTAL_LEGACY => 'Legacy octal character escape',\n        };\n\n        return \\sprintf(\n            '<li><span title=\"%s\">%s: <strong>%s<\/strong><\/span><\/li>',\n            $this->e($title),\n            htmlspecialchars($node->type->label()),\n            $this->e($node->originalRepresentation),\n        );\n    }\n\n    \/**\n     * Generates a human-readable description for a quantifier's value and type.\n     *\n     * Purpose: This private helper method centralizes the logic for translating\n     * raw quantifier strings (e.g., `*`, `{1,5}`) and their types (greedy, lazy, possessive)\n     * into clear, descriptive phrases suitable for the HTML explanation.\n     *\n     * @param string         $q    The raw quantifier string (e.g., `*`, `+`, `{1,5}`).\n     * @param QuantifierType $type the type of quantifier (greedy, lazy, possessive)\n     *\n     * @return string a human-readable description of the quantifier\n     *\/\n    private function explainQuantifierValue(string $q, QuantifierType $type): string\n    {\n        $desc = match ($q) {\n            '*' => 'zero or more times',\n            '+' => 'one or more times',\n            '?' => 'zero or one time',\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    \\sprintf('at least %d times', $m[1]) :\n                    \\sprintf('between %d and %d times', $m[1], $m[2])\n                ) :\n                    \\sprintf('exactly %d times', $m[1])\n                ) :\n                'with quantifier '.$q, \/\/ Fallback\n        };\n\n        $desc .= match ($type) {\n            QuantifierType::T_LAZY => ' (as few as possible)',\n            QuantifierType::T_POSSESSIVE => ' (and do not backtrack)',\n            default => '',\n        };\n\n        return $desc;\n    }\n\n    \/**\n     * Generates a human-readable description for a literal character.\n     *\n     * Purpose: This private helper method provides clear descriptions for literal characters,\n     * especially handling common control characters (like `\\n`, `\\t`) by translating them\n     * into their escaped form and a descriptive name, or indicating non-printable characters.\n     *\n     * @param string $value the raw literal character string\n     *\n     * @return string a human-readable description of the literal character\n     *\/\n    private function explainLiteral(string $value): string\n    {\n        return match ($value) {\n            ' ' => \"' ' (space)\",\n            \"\\t\" => \"'\\\\t' (tab)\",\n            \"\\n\" => \"'\\\\n' (newline)\",\n            \"\\r\" => \"'\\\\r' (carriage return)\",\n            default => ctype_print($value) ? \"'\".$value.\"'\" : '(non-printable char)',\n        };\n    }\n\n    \/**\n     * Helper for HTML escaping.\n     *\n     * Purpose: This private utility method ensures that any string content inserted\n     * into the HTML output is properly escaped to prevent XSS vulnerabilities and\n     * ensure correct rendering of special characters.\n     *\n     * @param string|null $s the string to be HTML escaped\n     *\n     * @return string the HTML escaped string\n     *\/\n    private function e(?string $s): string\n    {\n        return htmlspecialchars((string) $s, \\ENT_QUOTES, 'UTF-8');\n    }\n}\n",
    "NodeVisitor\/HighlighterVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Base visitor for highlighting regex syntax.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nabstract class HighlighterVisitor extends AbstractNodeVisitor\n{\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        return $node->pattern->accept($this);\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        $parts = [];\n        foreach ($node->alternatives as $alt) {\n            $parts[] = $alt->accept($this);\n        }\n\n        return implode($this->wrap('|', 'meta'), $parts);\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        $parts = [];\n        foreach ($node->children as $child) {\n            $parts[] = $child->accept($this);\n        }\n\n        return implode('', $parts);\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        $inner = $node->node->accept($this);\n        $quant = $node->quantifier;\n        if (Node\\QuantifierType::T_LAZY === $node->type) {\n            $quant .= '?';\n        } elseif (Node\\QuantifierType::T_POSSESSIVE === $node->type) {\n            $quant .= '+';\n        }\n\n        return $inner.$this->wrap($this->escape($quant), 'quantifier');\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        return $this->wrap($this->escape($node->value), 'literal');\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        return $this->wrap('\\\\'.$node->value, 'type');\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        return $this->wrap('.', 'meta');\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        return $this->wrap($this->escape($node->value), 'anchor');\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        return $this->wrap('\\\\'.$node->value, 'type');\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $parts = $node->expression instanceof Node\\AlternationNode\n            ? $node->expression->alternatives\n            : [$node->expression];\n        $inner = '';\n        foreach ($parts as $part) {\n            $inner .= $part->accept($this);\n        }\n        $neg = $node->isNegated ? '^' : '';\n\n        return $this->wrap('[', 'meta').$this->escape($neg).$inner.$this->wrap(']', 'meta');\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        $start = $node->start->accept($this);\n        $end = $node->end->accept($this);\n\n        return $start.$this->wrap('-', 'meta').$end;\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        return $this->wrap('\\\\'.$this->escape($node->ref), 'type');\n    }\n\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): string\n    {\n        return $this->wrap('\\\\x'.$node->code, 'type');\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        $prop = $node->prop;\n        if (\\strlen($prop) > 1 || str_starts_with($prop, '^')) {\n            $prop = '{'.$prop.'}';\n        }\n\n        return $this->wrap('\\\\p'.$this->escape($prop), 'type');\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return $this->wrap('[:'.$this->escape($node->class).':]', 'type');\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        return $this->wrap('(?#...)', 'meta');\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        return $this->wrap('(?'.$this->escape($node->reference).')', 'type');\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        return $this->wrap('(*'.$this->escape($node->verb).')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        $inner = $node->content->accept($this);\n\n        return $this->wrap('(?(DEFINE)', 'meta').$inner.$this->wrap(')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        return $this->wrap('(*LIMIT_MATCH='.$node->limit.')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        $content = $node->isStringIdentifier ? '\"'.$this->escape((string) $node->identifier).'\"' : (string) $node->identifier;\n\n        return $this->wrap('(?C'.$content.')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitScriptRun(Node\\ScriptRunNode $node): string\n    {\n        return $this->wrap('(*script_run:'.$this->escape($node->script).')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitVersionCondition(Node\\VersionConditionNode $node): string\n    {\n        return $this->wrap('(?(VERSION>='.$node->version.')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        return $this->wrap('\\\\K', 'type');\n    }\n\n    #[\\Override]\n    public function visitControlChar(Node\\ControlCharNode $node): string\n    {\n        return $this->wrap('\\\\c'.$node->char, 'type');\n    }\n\n    #[\\Override]\n    public function visitClassOperation(Node\\ClassOperationNode $node): string\n    {\n        $left = $node->left->accept($this);\n        $right = $node->right->accept($this);\n        $op = Node\\ClassOperationType::INTERSECTION === $node->type ? '&&' : '--';\n\n        return $this->wrap('[', 'meta').$left.$this->wrap($this->escape($op), 'meta').$right.$this->wrap(']', 'meta');\n    }\n\n    abstract protected function wrap(string $content, string $type): string;\n\n    abstract protected function escape(string $string): string;\n}\n",
    "NodeVisitor\/CompilerNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * High-performance compiler that recompiles regex AST back into optimized strings.\n *\n * This optimized visitor provides intelligent compilation with caching and\n * streamlined string building for maximum performance while maintaining\n * full PCRE compatibility.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nfinal class CompilerNodeVisitor extends AbstractNodeVisitor\n{\n    \/\/ Optimized meta-character sets for fast lookups\n    private const META_CHARACTERS = [\n        '\\\\' => true, '.' => true, '^' => true, '$' => true,\n        '[' => true, ']' => true, '(' => true, ')' => true,\n        '|' => true, '*' => true, '+' => true, '?' => true, '{' => true, '}' => true,\n    ];\n\n    private const CHAR_CLASS_META = [\n        '\\\\' => true, ']' => true, '-' => true, '^' => true,\n    ];\n\n    \/\/ Intelligent delimiter mapping cache\n    \/**\n     * @var array<string, string>\n     *\/\n    private static array $delimiterCache = [];\n\n    \/\/ Minimal state tracking\n    private bool $inCharClass = false;\n\n    private string $delimiter = '\/';\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        $this->delimiter = $node->delimiter;\n        $closingDelimiter = $this->getClosingDelimiter($node->delimiter);\n\n        return $node->delimiter.$node->pattern->accept($this).$closingDelimiter.$node->flags;\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        \/\/ Optimized: direct compilation without array_map overhead\n        $alternatives = $node->alternatives;\n        if ([] === $alternatives) {\n            return '';\n        }\n\n        $separator = $this->inCharClass ? '' : '|';\n        $result = $alternatives[0]->accept($this);\n\n        for ($i = 1, $count = \\count($alternatives); $i < $count; $i++) {\n            $result .= $separator.$alternatives[$i]->accept($this);\n        }\n\n        return $result;\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        \/\/ Optimized: direct compilation without array_map overhead\n        $children = $node->children;\n        if ([] === $children) {\n            return '';\n        }\n\n        $result = $children[0]->accept($this);\n\n        for ($i = 1, $count = \\count($children); $i < $count; $i++) {\n            $result .= $children[$i]->accept($this);\n        }\n\n        return $result;\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $child = $node->child->accept($this);\n        $flags = $node->flags ?? '';\n\n        return match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => '('.$child.')',\n            GroupType::T_GROUP_NON_CAPTURING => '(?:'.$child.')',\n            GroupType::T_GROUP_NAMED => '(?<'.$node->name.'>'.$child.')',\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => '(?='.$child.')',\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => '(?!'.$child.')',\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => '(?<='.$child.')',\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => '(?<!'.$child.')',\n            GroupType::T_GROUP_ATOMIC => '(?>'.$child.')',\n            GroupType::T_GROUP_BRANCH_RESET => '(?|'.$child.')',\n            GroupType::T_GROUP_INLINE_FLAGS => '' === $child ? '(?'.$flags.')' : '(?'.$flags.':'.$child.')',\n        };\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        $nodeCompiled = $node->node->accept($this);\n\n        if ($node->node instanceof Node\\SequenceNode || $node->node instanceof Node\\AlternationNode) {\n            $nodeCompiled = '(?:'.$nodeCompiled.')';\n        }\n\n        $suffix = match ($node->type) {\n            Node\\QuantifierType::T_LAZY => '?',\n            Node\\QuantifierType::T_POSSESSIVE => '+',\n            default => '',\n        };\n\n        return $nodeCompiled.$node->quantifier.$suffix;\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        $value = $node->value;\n\n        \/\/ Fast path for empty strings\n        if ('' === $value) {\n            return '';\n        }\n\n        \/\/ Special case for closing bracket outside char class\n        if (!$this->inCharClass && ']' === $value) {\n            return $value;\n        }\n\n        \/\/ Intelligent escaping with optimized character processing\n        return $this->escapeString($value);\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        return '.';\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        return $node->value;\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        return '\\\\'.$node->value;\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        return '\\\\'.$node->value;\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        return '\\K';\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $wasInCharClass = $this->inCharClass;\n        $this->inCharClass = true;\n\n        try {\n            $negation = $node->isNegated ? '^' : '';\n\n            return '['.$negation.$node->expression->accept($this).']';\n        } finally {\n            $this->inCharClass = $wasInCharClass;\n        }\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        return $node->start->accept($this).'-'.$node->end->accept($this);\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        if (ctype_digit($node->ref)) {\n            return '\\\\'.$node->ref;\n        }\n\n        return $node->ref;\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): string\n    {\n        $rep = $node->originalRepresentation;\n\n        \/\/ If it's already an escape sequence, return as is\n        if (str_starts_with($rep, '\\\\')) {\n            return $rep;\n        }\n\n        \/\/ If it's a single character, check if it needs escaping\n        if (1 === \\strlen($rep)) {\n            $ord = \\ord($rep);\n            if ($ord < 32 || 127 === $ord) {\n                \/\/ Escape control characters\n                return match ($ord) {\n                    9 => '\\\\t',\n                    10 => '\\\\n',\n                    13 => '\\\\r',\n                    12 => '\\\\f',\n                    27 => '\\\\e',\n                    default => '\\\\x'.strtoupper(str_pad(dechex($ord), 2, '0', \\STR_PAD_LEFT)),\n                };\n            }\n        }\n\n        return $rep;\n    }\n\n    #[\\Override]\n    public function visitClassOperation(Node\\ClassOperationNode $node): string\n    {\n        return $node->left->accept($this).(Node\\ClassOperationType::INTERSECTION === $node->type ? '&&' : '--').$node->right->accept($this);\n    }\n\n    #[\\Override]\n    public function visitControlChar(Node\\ControlCharNode $node): string\n    {\n        return '\\\\c'.$node->char;\n    }\n\n    #[\\Override]\n    public function visitScriptRun(Node\\ScriptRunNode $node): string\n    {\n        return '(*script_run:'.$node->script.')';\n    }\n\n    #[\\Override]\n    public function visitVersionCondition(Node\\VersionConditionNode $node): string\n    {\n        return '(?(VERSION'.$node->operator.$node->version.')';\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        if (str_starts_with($node->prop, '^')) {\n            return '\\p{'.$node->prop.'}';\n        }\n\n        if (\\strlen($node->prop) > 1) {\n            return '\\p{'.$node->prop.'}';\n        }\n\n        return '\\p'.$node->prop;\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return '[[:'.$node->class.':]]';\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        return '(?#'.$node->comment.')';\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        if ($node->condition instanceof Node\\BackrefNode) {\n            $cond = $node->condition->ref;\n        } else {\n            $cond = $node->condition->accept($this);\n        }\n\n        $yes = $node->yes->accept($this);\n        $no = $node->no->accept($this);\n        if ('' === $no) {\n            return '(?('.$cond.')'.$yes.')';\n        }\n\n        return '(?('.$cond.')'.$yes.'|'.$no.')';\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        return match ($node->syntax) {\n            '&' => '(?&'.$node->reference.')',\n            'P>' => '(?P>'.$node->reference.')',\n            'g' => '\\g<'.$node->reference.'>',\n            default => '(?'.$node->reference.')',\n        };\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        return '(*'.$node->verb.')';\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        return '(?(DEFINE)'.$node->content->accept($this).')';\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        return '(*LIMIT_MATCH='.$node->limit.')';\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        if (\\is_int($node->identifier)) {\n            return '(?C'.$node->identifier.')';\n        }\n\n        if (!$node->isStringIdentifier && preg_match('\/^[A-Za-z_][A-Za-z0-9_]*+$\/', $node->identifier)) {\n            return '(?C'.$node->identifier.')';\n        }\n\n        return '(?C\"'.$node->identifier.'\")';\n    }\n\n    \/**\n     * Intelligent delimiter mapping with caching.\n     *\/\n    private function getClosingDelimiter(string $delimiter): string\n    {\n        if (!isset(self::$delimiterCache[$delimiter])) {\n            self::$delimiterCache[$delimiter] = match ($delimiter) {\n                '(' => ')',\n                '[' => ']',\n                '{' => '}',\n                '<' => '>',\n                default => $delimiter,\n            };\n        }\n\n        return self::$delimiterCache[$delimiter];\n    }\n\n    \/**\n     * High-performance string escaping with minimal allocations.\n     *\/\n    private function escapeString(string $value): string\n    {\n        $meta = $this->inCharClass ? self::CHAR_CLASS_META : self::META_CHARACTERS;\n        $needsEscape = false;\n\n        \/\/ Fast pre-scan to check if escaping is needed\n        $len = \\strlen($value);\n        for ($i = 0; $i < $len; $i++) {\n            $char = $value[$i];\n            $ord = \\ord($char);\n            if ($char === $this->delimiter || isset($meta[$char]) || $ord < 32 || 127 === $ord) {\n                $needsEscape = true;\n\n                break;\n            }\n        }\n\n        \/\/ Fast path: no escaping needed\n        if (!$needsEscape) {\n            return $value;\n        }\n\n        \/\/ Optimized escaping with single pass\n        $result = '';\n        for ($i = 0; $i < $len; $i++) {\n            $char = $value[$i];\n            if ($char === $this->delimiter || isset($meta[$char])) {\n                $result .= '\\\\'.$char;\n            } elseif (\\ord($char) < 32 || 127 === \\ord($char)) {\n                \/\/ Escape control characters\n                $result .= match (\\ord($char)) {\n                    9 => '\\\\t',\n                    10 => '\\\\n',\n                    13 => '\\\\r',\n                    12 => '\\\\f',\n                    27 => '\\\\e',\n                    default => '\\\\x'.strtoupper(str_pad(dechex(\\ord($char)), 2, '0', \\STR_PAD_LEFT)),\n                };\n            } else {\n                $result .= $char;\n            }\n        }\n\n        return $result;\n    }\n}\n",
    "NodeVisitor\/LinterNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\LintIssue;\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * Lints regex patterns for semantic issues like useless flags.\n *\n * @extends AbstractNodeVisitor<Node\\NodeInterface>\n *\/\nfinal class LinterNodeVisitor extends AbstractNodeVisitor\n{\n    \/**\n     * @var list<LintIssue>\n     *\/\n    private array $issues = [];\n\n    private string $flags = '';\n\n    private bool $hasCaseSensitiveChars = false;\n\n    private bool $hasDots = false;\n\n    private bool $hasAnchors = false;\n\n    \/**\n     * @return list<string>\n     *\/\n    public function getWarnings(): array\n    {\n        return array_map(\n            static fn (LintIssue $issue): string => $issue->message,\n            $this->issues,\n        );\n    }\n\n    \/**\n     * @return list<LintIssue>\n     *\/\n    public function getIssues(): array\n    {\n        return $this->issues;\n    }\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): Node\\NodeInterface\n    {\n        $this->flags = $node->flags;\n        $this->issues = [];\n        $this->hasCaseSensitiveChars = false;\n        $this->hasDots = false;\n        $this->hasAnchors = false;\n\n        \/\/ Visit the pattern\n        $node->pattern->accept($this);\n\n        \/\/ Check flags\n        $this->checkUselessFlags();\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): Node\\NodeInterface\n    {\n        if (preg_match('\/[a-zA-Z]\/', $node->value) > 0) {\n            $this->hasCaseSensitiveChars = true;\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): Node\\NodeInterface\n    {\n        \/\/ Check if char class contains letters\n        $expression = $node->expression;\n        if ($expression instanceof Node\\AlternationNode) {\n            foreach ($expression->alternatives as $alt) {\n                if ($this->charClassPartHasLetters($alt)) {\n                    $this->hasCaseSensitiveChars = true;\n                }\n            }\n        } elseif ($this->charClassPartHasLetters($expression)) {\n            $this->hasCaseSensitiveChars = true;\n        }\n\n        $this->lintRedundantCharClass($node);\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): Node\\NodeInterface\n    {\n        $this->hasDots = true;\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): Node\\NodeInterface\n    {\n        if ('^' === $node->value || '$' === $node->value) {\n            $this->hasAnchors = true;\n        }\n\n        return $node;\n    }\n\n    \/\/ Implement other visit methods as no-op\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): Node\\NodeInterface\n    {\n        $this->lintAlternation($node);\n\n        foreach ($node->alternatives as $alt) {\n            $alt->accept($this);\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): Node\\NodeInterface\n    {\n        \/\/ Check for anchor conflicts\n        $this->checkAnchorConflicts($node);\n\n        foreach ($node->children as $child) {\n            $child->accept($this);\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): Node\\NodeInterface\n    {\n        if (GroupType::T_GROUP_INLINE_FLAGS === $node->type && null !== $node->flags) {\n            $this->lintInlineFlags($node);\n        }\n\n        if (GroupType::T_GROUP_NON_CAPTURING === $node->type && $this->isRedundantGroup($node->child)) {\n            $this->addIssue(\n                'regex.lint.group.redundant',\n                'Redundant non-capturing group; it can be removed without changing behavior.',\n                $node->startPosition,\n            );\n        }\n\n        $node->child->accept($this);\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): Node\\NodeInterface\n    {\n        if ($this->isVariableQuantifier($node->quantifier)) {\n            if ($this->isRepeatableQuantifier($node->quantifier)) {\n                $nested = $this->findNestedQuantifier($node->node);\n                if (null !== $nested && $this->isVariableQuantifier($nested->quantifier)) {\n                    $this->addIssue(\n                        'regex.lint.quantifier.nested',\n                        'Nested quantifiers can cause catastrophic backtracking.',\n                        $node->startPosition,\n                        'Consider using atomic groups (?>...) or possessive quantifiers.',\n                    );\n                }\n            }\n\n            if ($this->isUnboundedQuantifier($node->quantifier) && $this->containsDotStar($node->node)) {\n                $this->addIssue(\n                    'regex.lint.dotstar.nested',\n                    'An unbounded quantifier wraps a dot-star, which can cause severe backtracking.',\n                    $node->startPosition,\n                    'Refactor with atomic groups or a more specific character class.',\n                );\n            }\n        }\n\n        $node->node->accept($this);\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): Node\\NodeInterface\n    {\n        $code = null;\n        if (preg_match('\/^\\\\\\\\x([0-9a-fA-F]{2})$\/', $node->code, $m)) {\n            $code = (int) hexdec($m[1]);\n        } elseif (preg_match('\/^\\\\\\\\u\\{([0-9a-fA-F]++)\\}$\/', $node->code, $m)) {\n            $code = (int) hexdec($m[1]);\n        }\n\n        if (null !== $code && $code > 0x10FFFF) {\n            $this->addIssue(\n                'regex.lint.escape.suspicious',\n                \\sprintf('Suspicious Unicode escape \"%s\" (out of range).', $node->code),\n                $node->startPosition,\n            );\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): Node\\NodeInterface\n    {\n        if (Node\\CharLiteralType::UNICODE === $node->type && $node->codePoint > 0x10FFFF) {\n            $this->addIssue(\n                'regex.lint.escape.suspicious',\n                \\sprintf('Suspicious Unicode escape \"%s\" (out of range).', $node->originalRepresentation),\n                $node->startPosition,\n            );\n        }\n\n        if (\\in_array($node->type, [Node\\CharLiteralType::OCTAL, Node\\CharLiteralType::OCTAL_LEGACY], true) && $node->codePoint > 0xFF) {\n            $this->addIssue(\n                'regex.lint.escape.suspicious',\n                \\sprintf('Suspicious octal escape \"%s\" (out of range).', $node->originalRepresentation),\n                $node->startPosition,\n            );\n        }\n\n        if (Node\\CharLiteralType::UNICODE_NAMED === $node->type && class_exists(\\IntlChar::class)) {\n            $name = $node->originalRepresentation;\n            if (preg_match('\/^\\\\\\\\N\\\\{(.+)}$\/', $name, $matches)) {\n                $char = \\IntlChar::charFromName($matches[1]);\n                if (null === $char) {\n                    $this->addIssue(\n                        'regex.lint.escape.suspicious',\n                        \\sprintf('Unknown Unicode character name \"%s\".', $matches[1]),\n                        $node->startPosition,\n                    );\n                }\n            }\n        }\n\n        return $node;\n    }\n\n    private function checkUselessFlags(): void\n    {\n        if (str_contains($this->flags, 'i') && !$this->hasCaseSensitiveChars) {\n            $this->addIssue(\n                'regex.lint.flag.useless.i',\n                \"Flag 'i' is useless: the pattern contains no case-sensitive characters.\",\n            );\n        }\n\n        if (str_contains($this->flags, 's') && !$this->hasDots) {\n            $this->addIssue(\n                'regex.lint.flag.useless.s',\n                \"Flag 's' is useless: the pattern contains no dots.\",\n            );\n        }\n\n        if (str_contains($this->flags, 'm') && !$this->hasAnchors) {\n            $this->addIssue(\n                'regex.lint.flag.useless.m',\n                \"Flag 'm' is useless: the pattern contains no anchors.\",\n            );\n        }\n    }\n\n    private function charClassPartHasLetters(Node\\NodeInterface $node): bool\n    {\n        if ($node instanceof Node\\LiteralNode && preg_match('\/[a-zA-Z]\/', $node->value) > 0) {\n            return true;\n        }\n        if ($node instanceof Node\\RangeNode) {\n            return $this->rangeHasLetters($node);\n        }\n\n        \/\/ Other types like CharTypeNode might have letters, but for simplicity, assume not\n        return false;\n    }\n\n    private function rangeHasLetters(Node\\RangeNode $node): bool\n    {\n        $start = $node->start instanceof Node\\LiteralNode ? $node->start->value : '';\n        $end = $node->end instanceof Node\\LiteralNode ? $node->end->value : '';\n\n        return preg_match('\/[a-zA-Z]\/', $start.$end) > 0;\n    }\n\n    private function checkAnchorConflicts(Node\\SequenceNode $node): void\n    {\n        $children = $node->children;\n        $count = \\count($children);\n\n        for ($i = 0; $i < $count; $i++) {\n            $child = $children[$i];\n\n            if ($child instanceof Node\\AnchorNode && '^' === $child->value) {\n                \/\/ Check if there are consuming nodes before ^\n                for ($j = 0; $j < $i; $j++) {\n                    if ($this->isConsuming($children[$j])) {\n                        if (!str_contains($this->flags, 'm')) {\n                            $this->addIssue(\n                                'regex.lint.anchor.impossible.start',\n                                \"Start anchor '^' appears after consuming characters, making it impossible to match.\",\n                                $child->startPosition,\n                            );\n                        }\n\n                        break;\n                    }\n                }\n            }\n\n            if ($child instanceof Node\\AnchorNode && '$' === $child->value) {\n                \/\/ Check if there are consuming nodes after $\n                for ($j = $i + 1; $j < $count; $j++) {\n                    if ($this->isConsuming($children[$j])) {\n                        $this->addIssue(\n                            'regex.lint.anchor.impossible.end',\n                            \"End anchor '$' appears before consuming characters, making it impossible to match.\",\n                            $child->startPosition,\n                        );\n\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    private function isConsuming(Node\\NodeInterface $node): bool\n    {\n        if ($node instanceof Node\\LiteralNode) {\n            return true;\n        }\n        if ($node instanceof Node\\CharClassNode) {\n            return true;\n        }\n        if ($node instanceof Node\\CharTypeNode) {\n            return true;\n        }\n        if ($node instanceof Node\\DotNode) {\n            return true;\n        }\n        if ($node instanceof Node\\CharLiteralNode) {\n            return true;\n        }\n        if ($node instanceof Node\\UnicodePropNode) {\n            return true;\n        }\n        if ($node instanceof Node\\PosixClassNode) {\n            return true;\n        }\n        if ($node instanceof Node\\QuantifierNode) {\n            return $this->isConsuming($node->node);\n        }\n        if ($node instanceof Node\\GroupNode) {\n            \/\/ Lookarounds don't consume\n            return !(\\RegexParser\\Node\\GroupType::T_GROUP_LOOKAHEAD_POSITIVE === $node->type\n                || \\RegexParser\\Node\\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE === $node->type\n                || \\RegexParser\\Node\\GroupType::T_GROUP_LOOKBEHIND_POSITIVE === $node->type\n                || \\RegexParser\\Node\\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE === $node->type);\n        }\n        if ($node instanceof Node\\AlternationNode) {\n            \/\/ If any alternative consumes, consider it consuming\n            foreach ($node->alternatives as $alt) {\n                if ($this->isConsuming($alt)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n        if ($node instanceof Node\\SequenceNode) {\n            \/\/ If any child consumes, consider it consuming\n            foreach ($node->children as $child) {\n                if ($this->isConsuming($child)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        \/\/ Anchors, assertions, etc. don't consume\n        return false;\n    }\n\n    private function addIssue(string $id, string $message, ?int $offset = null, ?string $hint = null): void\n    {\n        $this->issues[] = new LintIssue($id, $message, $offset, $hint);\n    }\n\n    private function lintAlternation(Node\\AlternationNode $node): void\n    {\n        $literals = [];\n        foreach ($node->alternatives as $alt) {\n            $literal = $this->extractLiteralSequence($alt);\n            if (null === $literal) {\n                continue;\n            }\n\n            $literals[] = $literal;\n        }\n\n        if ([] === $literals) {\n            return;\n        }\n\n        $counts = array_count_values($literals);\n        foreach ($counts as $literal => $count) {\n            if ($count > 1) {\n                $this->addIssue(\n                    'regex.lint.alternation.duplicate',\n                    \\sprintf('Duplicate alternation branch \"%s\".', $literal),\n                    $node->startPosition,\n                );\n\n                break;\n            }\n        }\n\n        $unique = array_values(array_unique($literals));\n        $total = \\count($unique);\n        for ($i = 0; $i < $total; $i++) {\n            for ($j = $i + 1; $j < $total; $j++) {\n                $a = $unique[$i];\n                $b = $unique[$j];\n                if ('' === $a || '' === $b) {\n                    continue;\n                }\n\n                if (str_starts_with($a, $b) || str_starts_with($b, $a)) {\n                    $this->addIssue(\n                        'regex.lint.alternation.overlap',\n                        \\sprintf('Alternation branches \"%s\" and \"%s\" overlap.', $a, $b),\n                        $node->startPosition,\n                        'Consider ordering longer alternatives first or using atomic groups.',\n                    );\n\n                    return;\n                }\n            }\n        }\n    }\n\n    private function extractLiteralSequence(Node\\NodeInterface $node): ?string\n    {\n        if ($node instanceof Node\\LiteralNode) {\n            return $node->value;\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->extractLiteralSequence($node->child);\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            $value = '';\n            foreach ($node->children as $child) {\n                $literal = $this->extractLiteralSequence($child);\n                if (null === $literal) {\n                    return null;\n                }\n                $value .= $literal;\n            }\n\n            return $value;\n        }\n\n        return null;\n    }\n\n    private function lintRedundantCharClass(Node\\CharClassNode $node): void\n    {\n        $parts = $this->collectCharClassParts($node->expression);\n        if (null === $parts) {\n            return;\n        }\n\n        $ranges = [];\n        $literals = [];\n        $redundant = false;\n\n        foreach ($parts as $part) {\n            if ($part instanceof Node\\LiteralNode && 1 === \\strlen($part->value)) {\n                $ord = \\ord($part->value);\n                if (isset($literals[$ord]) || $this->isOrdCoveredByRanges($ord, $ranges)) {\n                    $redundant = true;\n                }\n                $literals[$ord] = true;\n\n                continue;\n            }\n\n            if ($part instanceof Node\\RangeNode && $part->start instanceof Node\\LiteralNode && $part->end instanceof Node\\LiteralNode) {\n                if (1 !== \\strlen($part->start->value) || 1 !== \\strlen($part->end->value)) {\n                    continue;\n                }\n\n                $start = \\ord($part->start->value);\n                $end = \\ord($part->end->value);\n                if ($start > $end) {\n                    continue;\n                }\n\n                if ($this->rangeOverlaps($start, $end, $ranges)) {\n                    $redundant = true;\n                }\n\n                foreach ($literals as $ord => $seen) {\n                    if ($ord >= $start && $ord <= $end) {\n                        $redundant = true;\n                        unset($literals[$ord]);\n                    }\n                }\n\n                $ranges[] = [$start, $end];\n            }\n        }\n\n        if ($redundant) {\n            $this->addIssue(\n                'regex.lint.charclass.redundant',\n                'Redundant elements detected in character class.',\n                $node->startPosition,\n            );\n        }\n    }\n\n    \/**\n     * @return list<Node\\NodeInterface>|null\n     *\/\n    private function collectCharClassParts(Node\\NodeInterface $node): ?array\n    {\n        if ($node instanceof Node\\ClassOperationNode) {\n            return null;\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            return array_values($node->alternatives);\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            return array_values($node->children);\n        }\n\n        return [$node];\n    }\n\n    \/**\n     * @param list<array{0: int, 1: int}> $ranges\n     *\/\n    private function rangeOverlaps(int $start, int $end, array $ranges): bool\n    {\n        foreach ($ranges as [$rStart, $rEnd]) {\n            if ($start <= $rEnd && $end >= $rStart) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * @param list<array{0: int, 1: int}> $ranges\n     *\/\n    private function isOrdCoveredByRanges(int $ord, array $ranges): bool\n    {\n        foreach ($ranges as [$rStart, $rEnd]) {\n            if ($ord >= $rStart && $ord <= $rEnd) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private function lintInlineFlags(Node\\GroupNode $node): void\n    {\n        $flags = (string) $node->flags;\n        if ('' === $flags) {\n            return;\n        }\n\n        $resetAll = str_starts_with($flags, '^');\n        if ($resetAll) {\n            $flags = substr($flags, 1);\n        }\n\n        [$set, $unset] = str_contains($flags, '-')\n            ? explode('-', $flags, 2)\n            : [$flags, ''];\n\n        $baseFlags = $resetAll ? '' : $this->flags;\n\n        foreach (str_split($set) as $flag) {\n            if ('' === $flag) {\n                continue;\n            }\n            if (str_contains($baseFlags, $flag)) {\n                $this->addIssue(\n                    'regex.lint.flag.redundant',\n                    \\sprintf(\"Inline flag '%s' is redundant; it is already set globally.\", $flag),\n                    $node->startPosition,\n                );\n            }\n        }\n\n        foreach (str_split($unset) as $flag) {\n            if ('' === $flag) {\n                continue;\n            }\n\n            if (!str_contains($baseFlags, $flag)) {\n                $this->addIssue(\n                    'regex.lint.flag.redundant',\n                    \\sprintf(\"Inline flag '-%s' is redundant; the flag is not set globally.\", $flag),\n                    $node->startPosition,\n                );\n            } else {\n                $this->addIssue(\n                    'regex.lint.flag.override',\n                    \\sprintf(\"Inline flag '-%s' overrides a global modifier.\", $flag),\n                    $node->startPosition,\n                    'Consider removing the global flag or limiting it to specific groups.',\n                );\n            }\n        }\n    }\n\n    private function isRedundantGroup(Node\\NodeInterface $node): bool\n    {\n        if ($node instanceof Node\\SequenceNode) {\n            if (1 !== \\count($node->children)) {\n                return false;\n            }\n\n            return $this->isRedundantGroup($node->children[0]);\n        }\n\n        if ($node instanceof Node\\AlternationNode || $node instanceof Node\\QuantifierNode) {\n            return false;\n        }\n\n        return $node instanceof Node\\LiteralNode\n            || $node instanceof Node\\CharTypeNode\n            || $node instanceof Node\\CharClassNode\n            || $node instanceof Node\\CharLiteralNode\n            || $node instanceof Node\\UnicodeNode\n            || $node instanceof Node\\DotNode\n            || $node instanceof Node\\AnchorNode\n            || $node instanceof Node\\AssertionNode\n            || $node instanceof Node\\KeepNode\n            || $node instanceof Node\\UnicodePropNode\n            || $node instanceof Node\\PosixClassNode\n            || $node instanceof Node\\ControlCharNode\n            || $node instanceof Node\\CommentNode\n            || $node instanceof Node\\CalloutNode\n            || $node instanceof Node\\ScriptRunNode;\n    }\n\n    private function isVariableQuantifier(string $quantifier): bool\n    {\n        [$min, $max] = $this->parseQuantifierRange($quantifier);\n\n        return null === $max || $min !== $max;\n    }\n\n    private function isRepeatableQuantifier(string $quantifier): bool\n    {\n        [, $max] = $this->parseQuantifierRange($quantifier);\n\n        return null === $max || $max > 1;\n    }\n\n    private function isUnboundedQuantifier(string $quantifier): bool\n    {\n        [, $max] = $this->parseQuantifierRange($quantifier);\n\n        return null === $max;\n    }\n\n    private function findNestedQuantifier(Node\\NodeInterface $node): ?Node\\QuantifierNode\n    {\n        if ($node instanceof Node\\QuantifierNode) {\n            return $node;\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->findNestedQuantifier($node->child);\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            foreach ($node->children as $child) {\n                $nested = $this->findNestedQuantifier($child);\n                if (null !== $nested) {\n                    return $nested;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            foreach ($node->alternatives as $alt) {\n                $nested = $this->findNestedQuantifier($alt);\n                if (null !== $nested) {\n                    return $nested;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\ConditionalNode) {\n            return $this->findNestedQuantifier($node->yes) ?? $this->findNestedQuantifier($node->no);\n        }\n\n        if ($node instanceof Node\\DefineNode) {\n            return $this->findNestedQuantifier($node->content);\n        }\n\n        return null;\n    }\n\n    private function containsDotStar(Node\\NodeInterface $node): bool\n    {\n        if ($node instanceof Node\\QuantifierNode && $node->node instanceof Node\\DotNode) {\n            return $this->isUnboundedQuantifier($node->quantifier);\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->containsDotStar($node->child);\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            foreach ($node->children as $child) {\n                if ($this->containsDotStar($child)) {\n                    return true;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            foreach ($node->alternatives as $alt) {\n                if ($this->containsDotStar($alt)) {\n                    return true;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\ConditionalNode) {\n            return $this->containsDotStar($node->yes) || $this->containsDotStar($node->no);\n        }\n\n        if ($node instanceof Node\\DefineNode) {\n            return $this->containsDotStar($node->content);\n        }\n\n        return false;\n    }\n\n    \/**\n     * @return array{0: int, 1: int|null}\n     *\/\n    private function parseQuantifierRange(string $quantifier): array\n    {\n        return match ($quantifier) {\n            '*' => [0, null],\n            '+' => [1, null],\n            '?' => [0, 1],\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $quantifier, $m) ?\n                (isset($m[2]) ?\n                    ('' === $m[2] ? [(int) $m[1], null] : [(int) $m[1], (int) $m[2]]) :\n                    [(int) $m[1], (int) $m[1]]\n                ) :\n                [1, 1],\n        };\n    }\n\n    \/\/ Add other visit methods as needed, default to no-op\n}\n",
    "NodeVisitor\/ExplainNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * Generates a human-readable, step-by-step explanation of what a regex does.\n *\n * Purpose: This visitor traverses the AST and translates each node into a natural\n * language description. It's the engine behind the `Regex::explain()` method.\n * For contributors, this class demonstrates how to consume the AST to produce\n * meaningful, user-facing output. Each `visit` method is responsible for\n * generating the English explanation for a specific regex component.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nfinal class ExplainNodeVisitor extends AbstractNodeVisitor\n{\n    private const CHAR_TYPE_MAP = [\n        'd' => 'any digit (0-9)',\n        'D' => 'any non-digit',\n        's' => 'any whitespace character',\n        'S' => 'any non-whitespace character',\n        'w' => 'any \"word\" character (alphanumeric or _)',\n        'W' => 'any \"non-word\" character',\n        'h' => 'any horizontal whitespace',\n        'H' => 'any non-horizontal whitespace',\n        'v' => 'any vertical whitespace',\n        'V' => 'any non-vertical whitespace',\n        'R' => 'a generic newline (\\\\r\\\\n, \\\\r, or \\\\n)',\n    ];\n\n    private const ANCHOR_MAP = [\n        '^' => 'the start of the string (or line, with \/m flag)',\n        '$' => 'the end of the string (or line, with \/m flag)',\n    ];\n\n    private const ASSERTION_MAP = [\n        'A' => 'the absolute start of the string',\n        'z' => 'the absolute end of the string',\n        'Z' => 'the end of the string (before final newline)',\n        'G' => 'the position of the last successful match',\n        'b' => 'a word boundary',\n        'B' => 'a non-word boundary',\n    ];\n\n    private int $indentLevel = 0;\n\n    \/**\n     * Explains the root `RegexNode`.\n     *\n     * Purpose: This is the entry point for the explanation. It sets up the initial\n     * context, mentioning the regex flags, and then recursively calls the visitor\n     * on the main pattern. This method provides a high-level summary of the entire\n     * regular expression.\n     *\n     * @param Node\\RegexNode $node the root node of the AST\n     *\n     * @return string the complete, human-readable explanation of the regex\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        $this->indentLevel = 0;\n        $flags = $node->flags ? ' (with flags: '.$node->flags.')' : '';\n        $header = $this->line('Regex matches'.$flags);\n        $this->indentLevel++;\n        $body = $node->pattern->accept($this);\n        $this->indentLevel = 0;\n\n        return $header.\"\\n\".$body;\n    }\n\n    \/**\n     * Explains an `AlternationNode`.\n     *\n     * Purpose: This method describes an alternation (`|`), making it clear that the\n     * regex engine will try to match one of several possibilities. It formats the\n     * output with \"EITHER...OR...\" to be intuitive, helping to understand the\n     * branching logic within the pattern.\n     *\n     * @param Node\\AlternationNode $node the alternation node to explain\n     *\n     * @return string a description of the alternative branches\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        $lines = [];\n        $this->indentLevel++;\n        foreach ($node->alternatives as $index => $alt) {\n            $label = 0 === $index ? 'EITHER' : 'OR';\n            $lines[] = $this->line($label);\n            $this->indentLevel++;\n            $lines[] = $alt->accept($this);\n            $this->indentLevel--;\n        }\n        $this->indentLevel--;\n\n        return implode(\"\\n\", $lines);\n    }\n\n    \/**\n     * Explains a `SequenceNode`.\n     *\n     * Purpose: This method describes a sequence of regex components that must be\n     * matched in order. It recursively explains each child and joins the\n     * descriptions with newlines to represent the sequence, making the step-by-step\n     * matching process clear.\n     *\n     * @param Node\\SequenceNode $node the sequence node to explain\n     *\n     * @return string a description of the sequential components\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        $parts = array_map(fn ($child) => $child->accept($this), $node->children);\n        $parts = array_filter($parts, fn ($part) => '' !== $part);\n\n        return implode(\"\\n\", $parts);\n    }\n\n    \/**\n     * Explains a `GroupNode`.\n     *\n     * Purpose: This method provides a description for any type of group, clearly\n     * stating its function (e.g., capturing, non-capturing, lookahead) and any\n     * associated metadata like a name or inline flags. This helps in understanding\n     * the structural and behavioral aspects of grouped patterns.\n     *\n     * @param Node\\GroupNode $node the group node to explain\n     *\n     * @return string a description of the group and its contents\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $this->indentLevel++;\n        $childExplain = $node->child->accept($this);\n        $this->indentLevel--;\n\n        $type = match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => 'Capturing group',\n            GroupType::T_GROUP_NON_CAPTURING => 'Non-capturing group',\n            GroupType::T_GROUP_NAMED => \\sprintf(\"Capturing group (named: '%s')\", $node->name),\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => 'Positive lookahead',\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => 'Negative lookahead',\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => 'Positive lookbehind',\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => 'Negative lookbehind',\n            GroupType::T_GROUP_ATOMIC => 'Atomic group (no backtracking)',\n            GroupType::T_GROUP_BRANCH_RESET => 'Branch reset group',\n            GroupType::T_GROUP_INLINE_FLAGS => \\sprintf(\"Inline flags '%s'\", $node->flags),\n        };\n\n        return implode(\"\\n\", [\n            $this->line($type),\n            $childExplain,\n            $this->line('End group'),\n        ]);\n    }\n\n    \/**\n     * Explains a `QuantifierNode`.\n     *\n     * Purpose: This method describes how many times a preceding element can be\n     * matched, translating tokens like `*`, `+`, and `{n,m}` into clear English\n     * phrases like \"zero or more times\" or \"between 2 and 5 times\". It also\n     * clarifies the quantifier's greediness (greedy, lazy, or possessive).\n     *\n     * @param Node\\QuantifierNode $node the quantifier node to explain\n     *\n     * @return string a description of the quantified element\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        $childExplain = $node->node->accept($this);\n        $quantExplain = $this->explainQuantifierValue($node->quantifier, $node->type->value);\n\n        \/\/ If the child is simple (one line), put it on one line.\n        if (!str_contains((string) $childExplain, \"\\n\")) {\n            return $this->line(\\sprintf('%s (%s)', $childExplain, $quantExplain));\n        }\n\n        \/\/ If the child is complex, indent it.\n        $this->indentLevel++;\n        $childExplain = $node->node->accept($this);\n        $this->indentLevel--;\n\n        return implode(\"\\n\", [\n            $this->line('Start Quantified Group ('.$quantExplain.')'),\n            $childExplain,\n            $this->line('End Quantified Group'),\n        ]);\n    }\n\n    \/**\n     * Explains a `LiteralNode`.\n     *\n     * Purpose: This method describes a literal character or string, handling\n     * special whitespace characters to make them readable. It represents the\n     * most basic form of matching: an exact character sequence.\n     *\n     * @param Node\\LiteralNode $node the literal node to explain\n     *\n     * @return string a description of the literal value\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        return $this->line($this->explainLiteral($node->value));\n    }\n\n    \/**\n     * Explains a `CharTypeNode`.\n     *\n     * Purpose: This method translates a character type escape sequence (e.g., `\\d`, `\\s`)\n     * into its well-known meaning (e.g., \"any digit\", \"any whitespace character\"). This\n     * helps in understanding these common shorthand character classes.\n     *\n     * @param Node\\CharTypeNode $node the character type node to explain\n     *\n     * @return string a description of the character type\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        return $this->line('Character Type: '.(self::CHAR_TYPE_MAP[$node->value] ?? 'unknown (\\\\'.$node->value.')'));\n    }\n\n    \/**\n     * Explains a `DotNode`.\n     *\n     * Purpose: This method describes the wildcard (`.`) character, noting its\n     * behavior with respect to newlines and the `\/s` flag. It clarifies that it\n     * matches almost any single character.\n     *\n     * @param Node\\DotNode $node the dot node to explain\n     *\n     * @return string a description of the wildcard\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        return $this->line('Wildcard: any character (except newline, unless \/s flag is used)');\n    }\n\n    \/**\n     * Explains an `AnchorNode`.\n     *\n     * Purpose: This method describes an anchor like `^` or `$`, explaining that it\n     * asserts a position (start or end of string\/line) without consuming any characters.\n     * This is crucial for understanding positional constraints.\n     *\n     * @param Node\\AnchorNode $node the anchor node to explain\n     *\n     * @return string a description of the anchor\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        return $this->line('Anchor: '.(self::ANCHOR_MAP[$node->value] ?? $node->value));\n    }\n\n    \/**\n     * Explains an `AssertionNode`.\n     *\n     * Purpose: This method describes a zero-width assertion like `\\b` (word boundary)\n     * or `\\A` (start of subject). These assertions check for conditions at the current\n     * position without consuming characters, providing precise matching control.\n     *\n     * @param Node\\AssertionNode $node the assertion node to explain\n     *\n     * @return string a description of the assertion\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        return $this->line('Assertion: '.(self::ASSERTION_MAP[$node->value] ?? '\\\\'.$node->value));\n    }\n\n    \/**\n     * Explains a `KeepNode`.\n     *\n     * Purpose: This method describes the `\\K` sequence, explaining its function of\n     * resetting the start of the overall match. This is important for understanding how\n     * the final matched string is determined, especially when parts of the match should\n     * be excluded from the result.\n     *\n     * @param Node\\KeepNode $node the keep node to explain\n     *\n     * @return string a description of the `\\K` assertion\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        return $this->line('Assertion: \\K (reset match start)');\n    }\n\n    \/**\n     * Explains a `CharClassNode`.\n     *\n     * Purpose: This method describes a character class `[...]`, indicating whether it's\n     * negated and listing the characters or ranges it contains. This helps in understanding\n     * the specific set of characters that are allowed or disallowed at a given position.\n     *\n     * @param Node\\CharClassNode $node the character class node to explain\n     *\n     * @return string a description of the character class\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $neg = $node->isNegated ? 'NOT ' : '';\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        $explainedParts = array_map(fn (Node\\NodeInterface $part) => $part->accept($this), $parts);\n\n        return $this->line(\\sprintf('Character Class: any character %sin [ %s ]', $neg, implode(', ', $explainedParts)));\n    }\n\n    \/**\n     * Explains a `RangeNode`.\n     *\n     * Purpose: This method describes a range within a character class (e.g., `a-z`),\n     * making it clear what the start and end of the range are. This simplifies the\n     * understanding of character sets defined by ranges.\n     *\n     * @param Node\\RangeNode $node the range node to explain\n     *\n     * @return string a description of the character range\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        $start = ($node->start instanceof Node\\LiteralNode)\n            ? $this->explainLiteral($node->start->value)\n            : $node->start->accept($this); \/\/ Fallback\n\n        $end = ($node->end instanceof Node\\LiteralNode)\n            ? $this->explainLiteral($node->end->value)\n            : $node->end->accept($this); \/\/ Fallback\n\n        return $this->line(\\sprintf('Range: from %s to %s', $start, $end));\n    }\n\n    \/**\n     * Explains a `BackrefNode`.\n     *\n     * Purpose: This method describes a backreference (e.g., `\\1`), explaining that\n     * it matches the text previously captured by a specific group. This is crucial for\n     * understanding patterns that enforce repetition or symmetry based on earlier matches.\n     *\n     * @param Node\\BackrefNode $node the backreference node to explain\n     *\n     * @return string a description of the backreference\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        return $this->line(\\sprintf('Backreference: matches text from group \"%s\"', $node->ref));\n    }\n\n    #[\\Override]\n    public function visitClassOperation(Node\\ClassOperationNode $node): string\n    {\n        $op = Node\\ClassOperationType::INTERSECTION === $node->type ? 'intersection' : 'subtraction';\n\n        return $this->line(\\sprintf('Class %s between %s and %s', $op, $node->left->accept($this), $node->right->accept($this)));\n    }\n\n    #[\\Override]\n    public function visitControlChar(Node\\ControlCharNode $node): string\n    {\n        return $this->line(\\sprintf('Control character: \\\\c%s', $node->char));\n    }\n\n    #[\\Override]\n    public function visitScriptRun(Node\\ScriptRunNode $node): string\n    {\n        return $this->line(\\sprintf('Script run assertion for script: %s', $node->script));\n    }\n\n    #[\\Override]\n    public function visitVersionCondition(Node\\VersionConditionNode $node): string\n    {\n        return $this->line(\\sprintf('Version condition: %s %s', $node->operator, $node->version));\n    }\n\n    \/**\n     * Explains a `UnicodePropNode`.\n     *\n     * Purpose: This method describes a Unicode property escape (e.g., `\\p{L}`),\n     * explaining that it matches any character with a specific Unicode property. This\n     * is vital for patterns dealing with diverse character sets and their classifications.\n     *\n     * @param Node\\UnicodePropNode $node the Unicode property node to explain\n     *\n     * @return string a description of the Unicode property match\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        $type = str_starts_with($node->prop, '^') ? 'non-matching' : 'matching';\n        $prop = ltrim($node->prop, '^');\n\n        return $this->line(\\sprintf('Unicode Property: any character %s \"%s\"', $type, $prop));\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): string\n    {\n        return match ($node->type) {\n            Node\\CharLiteralType::UNICODE => $this->line('Unicode: '.$node->originalRepresentation),\n            Node\\CharLiteralType::UNICODE_NAMED => $this->line('Unicode named character: '.$this->extractCharLiteralDetail($node)),\n            Node\\CharLiteralType::OCTAL => $this->line('Octal: '.$node->originalRepresentation),\n            Node\\CharLiteralType::OCTAL_LEGACY => $this->line('Legacy Octal: \\\\'.$node->originalRepresentation),\n        };\n    }\n\n    \/**\n     * Explains a `PosixClassNode`.\n     *\n     * Purpose: This method describes a POSIX character class (e.g., `[:alpha:]`).\n     * It clarifies that a predefined set of characters (like letters or digits) is\n     * being matched, which is useful for common character group definitions.\n     *\n     * @param Node\\PosixClassNode $node the POSIX class node to explain\n     *\n     * @return string a description of the POSIX class\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return $this->line('POSIX Class: '.$node->class);\n    }\n\n    \/**\n     * Explains a `CommentNode`.\n     *\n     * Purpose: This method describes an inline regex comment `(?#...)`.\n     * It clarifies that the content is a comment, ignored by the regex engine,\n     * but present for human readability and documentation within the pattern.\n     *\n     * @param Node\\CommentNode $node the comment node to explain\n     *\n     * @return string the content of the comment\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        return $this->line(\\sprintf(\"Comment: '%s'\", $node->comment));\n    }\n\n    \/**\n     * Explains a `ConditionalNode`.\n     *\n     * Purpose: This method describes a conditional subpattern `(?(cond)yes|no)`,\n     * clearly laying out the condition, the \"yes\" pattern, and the optional \"no\" pattern.\n     * This helps in understanding the complex branching logic and context-dependent\n     * matching within the regex.\n     *\n     * @param Node\\ConditionalNode $node the conditional node to explain\n     *\n     * @return string a description of the conditional logic\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        $this->indentLevel++;\n        $cond = $node->condition->accept($this);\n        $yes = $node->yes->accept($this);\n\n        \/\/ Check if the 'no' branch is an empty literal node\n        $hasElseBranch = !($node->no instanceof Node\\LiteralNode && '' === $node->no->value);\n        $no = $hasElseBranch ? $node->no->accept($this) : '';\n\n        $this->indentLevel--;\n\n        if ('' === $no) {\n            return implode(\"\\n\", [\n                $this->line(\\sprintf('IF (%s) THEN', $cond)),\n                $yes,\n            ]);\n        }\n\n        return implode(\"\\n\", [\n            $this->line(\\sprintf('IF (%s) THEN', $cond)),\n            $yes,\n            $this->line('ELSE'),\n            $no,\n        ]);\n    }\n\n    \/**\n     * Explains a `SubroutineNode`.\n     *\n     * Purpose: This method describes a subroutine call (e.g., `(?R)`), explaining\n     * that it recursively calls another part of the pattern. This is important for\n     * understanding patterns that reuse or refer to other parts of themselves.\n     *\n     * @param Node\\SubroutineNode $node the subroutine node to explain\n     *\n     * @return string a description of the subroutine call\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        $ref = match ($node->reference) {\n            'R', '0' => 'the entire pattern',\n            default => 'group '.$node->reference,\n        };\n\n        return $this->line(\\sprintf('Subroutine Call: recurses to %s', $ref));\n    }\n\n    \/**\n     * Explains a `PcreVerbNode`.\n     *\n     * Purpose: This method describes a PCRE verb like `(*FAIL)`, which controls\n     * the backtracking process of the regex engine. It clarifies the specific\n     * directive being used to influence matching behavior.\n     *\n     * @param Node\\PcreVerbNode $node the PCRE verb node to explain\n     *\n     * @return string a description of the PCRE verb\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        return $this->line('PCRE Verb: (*'.$node->verb.')');\n    }\n\n    \/**\n     * Explains a `DefineNode`.\n     *\n     * Purpose: This method describes a `(?(DEFINE)...)` block, explaining that it\n     * defines subpatterns for later use in subroutines without matching anything itself.\n     * This helps in understanding how reusable components are structured within a complex regex.\n     *\n     * @param Node\\DefineNode $node the define node to explain\n     *\n     * @return string a description of the DEFINE block\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        $this->indentLevel++;\n        $content = $node->content->accept($this);\n        $this->indentLevel--;\n\n        return implode(\"\\n\", [\n            $this->line('DEFINE block (defines subpatterns without matching)'),\n            $content,\n            $this->line('End DEFINE Block'),\n        ]);\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        return $this->line(\\sprintf('PCRE Verb: (*LIMIT_MATCH=%d) - sets a match limit for backtracking control', $node->limit));\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        $arg = \\is_int($node->identifier) || !$node->isStringIdentifier\n            ? $node->identifier\n            : '\"'.$node->identifier.'\"';\n\n        return $this->line(\\sprintf('Callout: passes control to user function with argument %s', $arg));\n    }\n\n    private function explainQuantifierValue(string $q, string $type): string\n    {\n        $desc = match ($q) {\n            '*' => 'zero or more times',\n            '+' => 'one or more times',\n            '?' => 'zero or one time',\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    \\sprintf('at least %d times', $m[1]) :\n                    \\sprintf('between %d and %d times', $m[1], $m[2])\n                ) :\n                    \\sprintf('exactly %d times', $m[1])\n                ) :\n                'with quantifier '.$q, \/\/ Fallback\n        };\n\n        $desc .= match ($type) {\n            'lazy' => ' (as few as possible)',\n            'possessive' => ' (and do not backtrack)',\n            default => '',\n        };\n\n        return $desc;\n    }\n\n    private function indent(bool $withExtra = true): string\n    {\n        return str_repeat('  ', $this->indentLevel).($withExtra ? '  ' : '');\n    }\n\n    private function explainLiteral(string $value): string\n    {\n        return match ($value) {\n            ' ' => \"' ' (space)\",\n            \"\\t\" => \"'\\\\t' (tab)\",\n            \"\\n\" => \"'\\\\n' (newline)\",\n            \"\\r\" => \"'\\\\r' (carriage return)\",\n            default => ctype_print($value) ? \"'\".$value.\"'\" : '(non-printable char)',\n        };\n    }\n\n    private function extractCharLiteralDetail(Node\\CharLiteralNode $node): string\n    {\n        if (Node\\CharLiteralType::UNICODE_NAMED === $node->type) {\n            if (preg_match('\/^\\\\\\\\N\\\\{(.+)}$\/', $node->originalRepresentation, $matches)) {\n                return $matches[1];\n            }\n        }\n\n        return $node->originalRepresentation;\n    }\n\n    private function line(string $text): string\n    {\n        return $this->indent(false).$text;\n    }\n}\n",
    "NodeVisitor\/HtmlHighlighterVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Highlights regex syntax for HTML output using span tags with classes.\n *\/\nfinal class HtmlHighlighterVisitor extends HighlighterVisitor\n{\n    private const CLASSES = [\n        'meta' => 'regex-meta',\n        'quantifier' => 'regex-quantifier',\n        'type' => 'regex-type',\n        'anchor' => 'regex-anchor',\n        'literal' => 'regex-literal',\n    ];\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $inner = $node->child->accept($this);\n        $prefix = match ($node->type) {\n            Node\\GroupType::T_GROUP_NON_CAPTURING => '?:',\n            Node\\GroupType::T_GROUP_LOOKAHEAD_POSITIVE => '?=',\n            Node\\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => '?!',\n            Node\\GroupType::T_GROUP_LOOKBEHIND_POSITIVE => '?<=',\n            Node\\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => '?<!',\n            Node\\GroupType::T_GROUP_ATOMIC => '?>',\n            Node\\GroupType::T_GROUP_NAMED => \"?&lt;{$node->name}&gt;\",\n            default => '',\n        };\n        $opening = $this->wrap('('.$this->escape($prefix), 'meta');\n        $closing = $this->wrap(')', 'meta');\n\n        return $opening.$inner.$closing;\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['literal'].'\">'.htmlspecialchars($node->value).'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\'.$node->value.'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['meta'].'\">.<\/span>';\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['anchor'].'\">'.htmlspecialchars($node->value).'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\'.$node->value.'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $parts = $node->expression instanceof Node\\AlternationNode\n            ? $node->expression->alternatives\n            : [$node->expression];\n        $inner = '';\n        foreach ($parts as $part) {\n            $inner .= $part->accept($this);\n        }\n        $neg = $node->isNegated ? '^' : '';\n\n        return '<span class=\"'.self::CLASSES['meta'].'>['.htmlspecialchars($neg).'<\/span>'.$inner.'<span class=\"'.self::CLASSES['meta'].'\">]<\/span>';\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        $start = $node->start->accept($this);\n        $end = $node->end->accept($this);\n\n        return $start.'<span class=\"'.self::CLASSES['meta'].'\">-<\/span>'.$end;\n    }\n\n    \/\/ Implement other visit methods\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\'.htmlspecialchars($node->ref).'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\x'.$node->code.'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        $prop = $node->prop;\n        if (\\strlen($prop) > 1 || str_starts_with($prop, '^')) {\n            $prop = '{'.$prop.'}';\n        }\n\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\p'.htmlspecialchars($prop).'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">[:'.htmlspecialchars($node->class).':]<\/span>';\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['meta'].'\">(?#...)<\/span>';\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        $condition = $node->condition->accept($this);\n        $yes = $node->yes->accept($this);\n        $no = $node->no->accept($this);\n        $noPart = $no ? $this->wrap('|', 'meta').$no : '';\n\n        return $this->wrap('(?(', 'meta').$condition.$this->wrap(')', 'meta').$yes.$noPart.$this->wrap(')', 'meta');\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">(?'.htmlspecialchars($node->reference).')<\/span>';\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['meta'].'\">(*'.htmlspecialchars($node->verb).')<\/span>';\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        $inner = $node->content->accept($this);\n\n        return '<span class=\"'.self::CLASSES['meta'].'\">(?(DEFINE)<\/span>'.$inner.'<span class=\"'.self::CLASSES['meta'].'>)<\/span>';\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['meta'].'\">(*LIMIT_MATCH='.$node->limit.')<\/span>';\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        $content = $node->isStringIdentifier ? '\"'.htmlspecialchars((string) $node->identifier).'\"' : (string) $node->identifier;\n\n        return '<span class=\"'.self::CLASSES['meta'].'\">(?C'.$content.')<\/span>';\n    }\n\n    #[\\Override]\n    public function visitScriptRun(Node\\ScriptRunNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['meta'].'\">(*script_run:'.htmlspecialchars($node->script).')<\/span>';\n    }\n\n    #[\\Override]\n    public function visitVersionCondition(Node\\VersionConditionNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['meta'].'\">(?(VERSION&gt;='.$node->version.')<\/span>';\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\K<\/span>';\n    }\n\n    #[\\Override]\n    public function visitControlChar(Node\\ControlCharNode $node): string\n    {\n        return '<span class=\"'.self::CLASSES['type'].'\">\\\\c'.$node->char.'<\/span>';\n    }\n\n    #[\\Override]\n    public function visitClassOperation(Node\\ClassOperationNode $node): string\n    {\n        $left = $node->left->accept($this);\n        $right = $node->right->accept($this);\n        $op = Node\\ClassOperationType::INTERSECTION === $node->type ? '&&' : '--';\n\n        return '<span class=\"'.self::CLASSES['meta'].'\">[<\/span>'.$left.'<span class=\"'.self::CLASSES['meta'].'\">'.htmlspecialchars($op).'<\/span>'.$right.'<span class=\"'.self::CLASSES['meta'].'\">]<\/span>';\n    }\n\n    protected function wrap(string $content, string $type): string\n    {\n        return '<span class=\"'.self::CLASSES[$type].'\">'.$content.'<\/span>';\n    }\n\n    protected function escape(string $string): string\n    {\n        return htmlspecialchars($string);\n    }\n}\n",
    "NodeVisitor\/ComplexityScoreNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * High-performance visitor that calculates numeric complexity scores for regex patterns.\n *\n * This optimized visitor provides intelligent complexity analysis with caching and\n * streamlined scoring algorithms for maximum performance while detecting ReDoS patterns.\n *\n * @extends AbstractNodeVisitor<int>\n *\/\nfinal class ComplexityScoreNodeVisitor extends AbstractNodeVisitor\n{\n    \/\/ Optimized scoring constants\n    private const BASE_SCORE = 1;\n    private const UNBOUNDED_QUANTIFIER_SCORE = 10;\n    private const COMPLEX_CONSTRUCT_SCORE = 5;\n    private const NESTING_MULTIPLIER = 2;\n\n    \/\/ Intelligent caching for expensive operations\n    \/**\n     * @var array<string, bool>\n     *\/\n    private static array $unboundedQuantifierCache = [];\n\n    \/\/ Minimal state tracking\n    private int $quantifierDepth = 0;\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): int\n    {\n        \/\/ Reset state for this run\n        $this->quantifierDepth = 0;\n\n        \/\/ The score of a regex is the score of its pattern\n        return $node->pattern->accept($this);\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): int\n    {\n        \/\/ Optimized: sum all alternatives with base score\n        $score = self::BASE_SCORE;\n        foreach ($node->alternatives as $alt) {\n            $score += $alt->accept($this);\n        }\n\n        return $score;\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): int\n    {\n        \/\/ Optimized: direct sum of all children\n        $score = 0;\n        foreach ($node->children as $child) {\n            $score += $child->accept($this);\n        }\n\n        return $score;\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): int\n    {\n        $childScore = $node->child->accept($this);\n\n        \/\/ Lookarounds are considered complex - optimized enum check\n        return match ($node->type) {\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => self::COMPLEX_CONSTRUCT_SCORE + $childScore,\n            default => self::BASE_SCORE + $childScore,\n        };\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): int\n    {\n        $quant = $node->quantifier;\n        $isUnbounded = $this->isUnboundedQuantifier($quant);\n        $score = 0;\n\n        if ($isUnbounded) {\n            $score += self::UNBOUNDED_QUANTIFIER_SCORE;\n            if ($this->quantifierDepth > 0) {\n                \/\/ Exponentially penalize nested unbounded quantifiers (ReDoS detection)\n                $score *= (self::NESTING_MULTIPLIER * $this->quantifierDepth);\n            }\n            $this->quantifierDepth++;\n        } else {\n            \/\/ Bounded quantifiers are simpler\n            $score += self::BASE_SCORE;\n        }\n\n        \/\/ Add the score of the quantified node\n        $score += $node->node->accept($this);\n\n        if ($isUnbounded) {\n            $this->quantifierDepth--;\n        }\n\n        return $score;\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): int\n    {\n        \/\/ Optimized: sum parts inside character class\n        $score = self::BASE_SCORE;\n        $expression = $node->expression;\n\n        if ($expression instanceof Node\\AlternationNode) {\n            foreach ($expression->alternatives as $part) {\n                $score += $part->accept($this);\n            }\n        } else {\n            $score += $expression->accept($this);\n        }\n\n        return $score;\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): int\n    {\n        return self::COMPLEX_CONSTRUCT_SCORE;\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): int\n    {\n        \/\/ Conditionals are highly complex - optimized calculation\n        return self::COMPLEX_CONSTRUCT_SCORE * 2\n            + $node->condition->accept($this)\n            + $node->yes->accept($this)\n            + $node->no->accept($this);\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): int\n    {\n        \/\/ Subroutines\/recursion are highly complex\n        return self::COMPLEX_CONSTRUCT_SCORE * 2;\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): int\n    {\n        \/\/ Optimized: range score includes start and end nodes\n        return self::BASE_SCORE + $node->start->accept($this) + $node->end->accept($this);\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): int\n    {\n        \/\/ Comments do not add to complexity\n        return 0;\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): int\n    {\n        return self::COMPLEX_CONSTRUCT_SCORE;\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): int\n    {\n        \/\/ DEFINE blocks add complexity from their content\n        return self::COMPLEX_CONSTRUCT_SCORE + $node->content->accept($this);\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): int\n    {\n        return self::COMPLEX_CONSTRUCT_SCORE;\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): int\n    {\n        \/\/ Callouts introduce external logic and break regex flow, making them complex.\n        return self::COMPLEX_CONSTRUCT_SCORE;\n    }\n\n    \/**\n     * High-performance cached unbounded quantifier detection.\n     *\/\n    private function isUnboundedQuantifier(string $quant): bool\n    {\n        \/\/ Return cached result if available\n        if (isset(self::$unboundedQuantifierCache[$quant])) {\n            return self::$unboundedQuantifierCache[$quant];\n        }\n\n        \/\/ Fast array lookup for common cases\n        if (\\in_array($quant, ['*', '+'], true)) {\n            return self::$unboundedQuantifierCache[$quant] = true;\n        }\n\n        \/\/ Regex check for {n,} pattern\n        $isUnbounded = 1 === preg_match('\/^\\{\\d++,\\}$\/', $quant);\n\n        return self::$unboundedQuantifierCache[$quant] = $isUnbounded;\n    }\n}\n",
    "NodeVisitor\/ReDoSProfileNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\ReDoS\\CharSetAnalyzer;\nuse RegexParser\\ReDoS\\ReDoSConfidence;\nuse RegexParser\\ReDoS\\ReDoSFinding;\nuse RegexParser\\ReDoS\\ReDoSSeverity;\n\n\/**\n * Analyzes the AST to detect ReDoS vulnerabilities.\n *\n * @extends AbstractNodeVisitor<ReDoSSeverity>\n *\/\nfinal class ReDoSProfileNodeVisitor extends AbstractNodeVisitor\n{\n    private int $unboundedQuantifierDepth = 0;\n\n    \/**\n     * Tracks total nesting of quantifiers (bounded or not) to detect LOW risks.\n     *\/\n    private int $totalQuantifierDepth = 0;\n\n    \/**\n     * Stores all detected ReDoS vulnerabilities during the AST traversal.\n     *\n     * @var list<ReDoSFinding>\n     *\/\n    private array $vulnerabilities = [];\n\n    private bool $inAtomicGroup = false;\n\n    private ?Node\\NodeInterface $previousNode = null;\n\n    private ?Node\\NodeInterface $nextNode = null;\n\n    private bool $backrefLoopDetected = false;\n\n    public function __construct(\n        private readonly CharSetAnalyzer $charSetAnalyzer = new CharSetAnalyzer(),\n    ) {}\n\n    \/**\n     * @return array{\n     *     severity: ReDoSSeverity,\n     *     recommendations: array<string>,\n     *     vulnerablePattern: ?string,\n     *     trigger: ?string,\n     *     confidence: ?ReDoSConfidence,\n     *     falsePositiveRisk: ?string,\n     *     findings: array<ReDoSFinding>\n     * }\n     *\/\n    public function getResult(): array\n    {\n        $maxSeverity = ReDoSSeverity::SAFE;\n        $recommendations = [];\n        $pattern = null;\n        $trigger = null;\n        $confidence = null;\n        $falsePositiveRisk = null;\n\n        foreach ($this->vulnerabilities as $vuln) {\n            if ($this->severityGreaterThan($vuln->severity, $maxSeverity)) {\n                $maxSeverity = $vuln->severity;\n                $pattern = $vuln->pattern;\n                $trigger = $vuln->trigger;\n                $confidence = $vuln->confidence;\n                $falsePositiveRisk = $vuln->falsePositiveRisk;\n            }\n            $recommendations[] = null !== $vuln->suggestedRewrite\n                ? $vuln->message.' Suggested: '.$vuln->suggestedRewrite\n                : $vuln->message;\n        }\n\n        if ($this->backrefLoopDetected) {\n            $maxSeverity = $this->maxSeverity($maxSeverity, ReDoSSeverity::CRITICAL);\n        }\n\n        return [\n            'severity' => $maxSeverity,\n            'recommendations' => array_unique($recommendations),\n            'vulnerablePattern' => $pattern,\n            'trigger' => $trigger,\n            'confidence' => $confidence,\n            'falsePositiveRisk' => $falsePositiveRisk,\n            'findings' => $this->vulnerabilities,\n        ];\n    }\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): ReDoSSeverity\n    {\n        $this->unboundedQuantifierDepth = 0;\n        $this->totalQuantifierDepth = 0;\n        $this->vulnerabilities = [];\n        $this->inAtomicGroup = false;\n        $this->previousNode = null;\n        $this->nextNode = null;\n        $this->backrefLoopDetected = false;\n\n        return $node->pattern->accept($this);\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): ReDoSSeverity\n    {\n        \/\/ Save the current atomic state to restore it later\n        $wasAtomic = $this->inAtomicGroup;\n        $boundarySeparatedPrev = $this->hasMutuallyExclusiveBoundary($this->previousNode, $node->node);\n        $boundarySeparatedNext = $this->hasForwardMutuallyExclusiveBoundary($node->node, $this->nextNode);\n        $boundarySeparated = $boundarySeparatedPrev || $boundarySeparatedNext;\n\n        $controlVerbShield = $this->hasTrailingBacktrackingControl($node->node);\n\n        \/\/ If the quantifier is possessive (*+, ++), its content is implicitly atomic.\n        \/\/ This means it does not backtrack, preventing ReDoS in nested structures.\n        if (QuantifierType::T_POSSESSIVE === $node->type || $controlVerbShield) {\n            $this->inAtomicGroup = true;\n        }\n\n        \/\/ If we are inside an atomic group (explicit or via possessive quantifier),\n        \/\/ we visit the child without ReDoS checks (as backtracking is disabled),\n        \/\/ then restore the state and return immediately.\n        if ($this->inAtomicGroup) {\n            $result = $node->node->accept($this);\n            $this->inAtomicGroup = $wasAtomic; \/\/ Restore state is crucial here!\n\n            return $controlVerbShield ? $this->reduceSeverity($result, ReDoSSeverity::LOW) : $result;\n        }\n\n        \/\/ --- Standard ReDoS logic for non-atomic quantifiers ---\n\n        $this->totalQuantifierDepth++;\n        $isUnbounded = $this->isUnbounded($node->quantifier);\n\n        \/\/ Check if the immediate target is an atomic group (e.g., (? >...)+)\n        $isTargetAtomic = $node->node instanceof Node\\GroupNode && GroupType::T_GROUP_ATOMIC === $node->node->type;\n\n        $severity = ReDoSSeverity::SAFE;\n        $entersUnbounded = $isUnbounded && !$isTargetAtomic;\n        $isNestedUnbounded = $entersUnbounded && $this->unboundedQuantifierDepth > 0;\n\n        if ($entersUnbounded) {\n            $this->unboundedQuantifierDepth++;\n\n            if ($this->hasBackrefLoop($node->node)) {\n                $this->backrefLoopDetected = true;\n                $severity = ReDoSSeverity::CRITICAL;\n                $this->addVulnerability(\n                    ReDoSSeverity::CRITICAL,\n                    'Unbounded quantifier combined with backreferences to variable-length captures can cause catastrophic backtracking.',\n                    $node,\n                    'Use atomic groups (?>...) or possessive quantifiers around the quantified token.',\n                    ReDoSConfidence::HIGH,\n                    'Low false-positive risk; nested backtracking with backreferences is a known hotspot.',\n                );\n            }\n\n            if ($isNestedUnbounded) {\n                $severity = $boundarySeparated ? ReDoSSeverity::LOW : ReDoSSeverity::CRITICAL;\n                if (!$boundarySeparated) {\n                    $this->addVulnerability(\n                        ReDoSSeverity::CRITICAL,\n                        'Nested unbounded quantifiers detected. This allows exponential backtracking. Consider using atomic groups (?>...) or possessive quantifiers (*+, ++).',\n                        $node,\n                        'Replace inner quantifiers with possessive variants or wrap them in (?>...).',\n                        ReDoSConfidence::HIGH,\n                        'Low false-positive risk; nested unbounded quantifiers are a classic ReDoS pattern.',\n                    );\n                }\n            } else {\n                $severity = $boundarySeparated ? ReDoSSeverity::LOW : ReDoSSeverity::MEDIUM;\n                if (!$boundarySeparated) {\n                    $this->addVulnerability(\n                        ReDoSSeverity::MEDIUM,\n                        'Unbounded quantifier detected. May cause backtracking on non-matching input. Consider making it possessive (*+) or using atomic groups (?>...).',\n                        $node,\n                        'Consider using possessive quantifiers or atomic groups to limit backtracking.',\n                        ReDoSConfidence::MEDIUM,\n                        'Medium false-positive risk; depends on input distribution and surrounding tokens.',\n                    );\n                }\n            }\n        } else {\n            if ($this->isLargeBounded($node->quantifier)) {\n                $severity = ReDoSSeverity::LOW;\n                $this->addVulnerability(\n                    ReDoSSeverity::LOW,\n                    'Large bounded quantifier detected (>1000). May cause slow matching. Consider reducing the upper bound.',\n                    $node,\n                    'Reduce the upper bound or pre-validate input length.',\n                    ReDoSConfidence::LOW,\n                    'High false-positive risk; bounded quantifiers may still be safe in context.',\n                );\n            } elseif ($this->totalQuantifierDepth > 1) {\n                $severity = ReDoSSeverity::LOW;\n                $this->addVulnerability(\n                    ReDoSSeverity::LOW,\n                    'Nested bounded quantifiers detected. May cause polynomial backtracking. Consider simplifying the pattern or using atomic groups (?>...).',\n                    $node,\n                    'Flatten nested quantifiers or introduce atomic groups.',\n                    ReDoSConfidence::LOW,\n                    'Medium false-positive risk; bounded quantifiers are often acceptable.',\n                );\n            }\n        }\n\n        $childPrevious = $this->previousNode;\n        $childNext = $this->nextNode;\n        $this->previousNode = null;\n        $this->nextNode = null;\n        $childSeverity = $node->node->accept($this);\n        $this->previousNode = $childPrevious;\n        $this->nextNode = $childNext;\n\n        if ($entersUnbounded && !$boundarySeparated && ReDoSSeverity::HIGH === $childSeverity) {\n            $severity = ReDoSSeverity::CRITICAL;\n            $this->addVulnerability(\n                ReDoSSeverity::CRITICAL,\n                'Critical nesting of quantifiers detected (Star Height > 1). This is a classic ReDoS vulnerability. Refactor the pattern to avoid nested unbounded quantifiers over the same subpattern.',\n                $node,\n                'Use atomic groups or restructure the repetition to be deterministic.',\n                ReDoSConfidence::HIGH,\n                'Low false-positive risk; star-height > 1 patterns are highly suspect.',\n            );\n        }\n\n        if ($entersUnbounded) {\n            $this->unboundedQuantifierDepth--;\n        }\n        $this->totalQuantifierDepth--;\n\n        \/\/ Restore state (just in case, though the early return handles the true case)\n        $this->inAtomicGroup = $wasAtomic;\n\n        return $this->maxSeverity($severity, $childSeverity);\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): ReDoSSeverity\n    {\n        $max = ReDoSSeverity::SAFE;\n        $previous = $this->previousNode;\n        $next = $this->nextNode;\n\n        if ($this->unboundedQuantifierDepth > 0 && $this->hasOverlappingAlternatives($node)) {\n            $this->addVulnerability(\n                ReDoSSeverity::CRITICAL,\n                'Overlapping alternation branches inside a quantifier. e.g. (a|a)* or (ab|a)*. This can lead to catastrophic backtracking.',\n                $node,\n                'Make alternatives mutually exclusive or order longer alternatives first.',\n                ReDoSConfidence::HIGH,\n                'Low false-positive risk; overlapping alternations are a known backtracking trigger.',\n            );\n            $max = ReDoSSeverity::CRITICAL;\n        }\n\n        foreach ($node->alternatives as $alt) {\n            $this->previousNode = null;\n            $this->nextNode = null;\n            $max = $this->maxSeverity($max, $alt->accept($this));\n        }\n\n        $this->previousNode = $previous;\n        $this->nextNode = $next;\n\n        return $max;\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): ReDoSSeverity\n    {\n        $wasAtomic = $this->inAtomicGroup;\n        $previous = $this->previousNode;\n        $next = $this->nextNode;\n\n        if (GroupType::T_GROUP_ATOMIC === $node->type) {\n            $this->inAtomicGroup = true;\n        }\n\n        $this->previousNode = null;\n        $this->nextNode = null;\n        $severity = $node->child->accept($this);\n        $this->previousNode = $previous;\n        $this->nextNode = $next;\n\n        $this->inAtomicGroup = $wasAtomic;\n\n        return $severity;\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): ReDoSSeverity\n    {\n        $max = ReDoSSeverity::SAFE;\n        $previous = $this->previousNode;\n        $next = $this->nextNode;\n        $last = null;\n        $total = \\count($node->children);\n        foreach ($node->children as $index => $child) {\n            $this->previousNode = $last;\n            $this->nextNode = $index + 1 < $total ? $node->children[$index + 1] : null;\n            $max = $this->maxSeverity($max, $child->accept($this));\n            $last = $child;\n        }\n\n        $this->previousNode = $previous;\n        $this->nextNode = $next;\n\n        return $max;\n    }\n\n    \/**\n     * Visits a LiteralNode. Literal characters are inherently safe from ReDoS.\n     *\n     * Purpose: Literal characters (e.g., 'a', 'hello') match themselves directly\n     * and do not involve any backtracking or repetition that could lead to ReDoS.\n     * Therefore, this method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\LiteralNode $node the `LiteralNode` representing a literal character or string\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a CharTypeNode. Character types are inherently safe from ReDoS.\n     *\n     * Purpose: Predefined character types (e.g., `\\d`, `\\s`, `\\w`) match a single\n     * character from a defined set and do not introduce backtracking issues on their own.\n     * Therefore, this method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\CharTypeNode $node the `CharTypeNode` representing a predefined character type\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a DotNode. The wildcard dot is inherently safe from ReDoS.\n     *\n     * Purpose: The dot (`.`) matches any single character (except newline by default)\n     * and does not introduce backtracking issues on its own. Therefore, this method\n     * always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\DotNode $node the `DotNode` representing the wildcard dot character\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits an AnchorNode. Anchors are inherently safe from ReDoS.\n     *\n     * Purpose: Positional anchors (e.g., `^`, `$`, `\\b`) assert a position in the string\n     * but do not consume characters or involve repetition. They are therefore safe from ReDoS.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\AnchorNode $node the `AnchorNode` representing a positional anchor\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits an AssertionNode. Assertions are inherently safe from ReDoS.\n     *\n     * Purpose: Zero-width assertions (e.g., `\\b`, `\\A`) check for conditions without\n     * consuming characters or involving repetition. They are therefore safe from ReDoS.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\AssertionNode $node the `AssertionNode` representing a zero-width assertion\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a KeepNode. The `\\K` assertion is inherently safe from ReDoS.\n     *\n     * Purpose: The `\\K` assertion resets the starting point of the match but does not\n     * consume characters or involve repetition in a way that leads to ReDoS.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\KeepNode $node the `KeepNode` representing the `\\K` assertion\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a CharClassNode. Character classes are inherently safe from ReDoS.\n     *\n     * Purpose: Character classes (e.g., `[a-z]`, `[^0-9]`) match a single character\n     * from a defined set and do not introduce backtracking issues on their own.\n     * Therefore, this method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\CharClassNode $node the `CharClassNode` representing a character class\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a RangeNode. Character ranges are inherently safe from ReDoS.\n     *\n     * Purpose: Character ranges (e.g., `a-z` within a character class) match a single\n     * character from a defined range and do not introduce backtracking issues on their own.\n     * Therefore, this method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\RangeNode $node the `RangeNode` representing a character range\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a BackrefNode. Backreferences are generally safe from ReDoS on their own.\n     *\n     * Purpose: Backreferences (e.g., `\\1`, `\\k<name>`) match previously captured text.\n     * While they can be part of complex patterns that lead to ReDoS, the backreference\n     * itself does not introduce the vulnerability. This method returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\BackrefNode $node the `BackrefNode` representing a backreference\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a UnicodeNode. Unicode character escapes are inherently safe from ReDoS.\n     *\n     * Purpose: Unicode character escapes (e.g., `\\x{2603}`) represent a single, specific\n     * character and do not introduce backtracking or repetition issues.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\UnicodeNode $node the `UnicodeNode` representing a Unicode character escape\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a UnicodePropNode. Unicode properties are inherently safe from ReDoS.\n     *\n     * Purpose: Unicode character properties (e.g., `\\p{L}`) match a single character\n     * based on its property and do not introduce backtracking or repetition issues on their own.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\UnicodePropNode $node the `UnicodePropNode` representing a Unicode property\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a PosixClassNode. POSIX character classes are inherently safe from ReDoS.\n     *\n     * Purpose: POSIX character classes (e.g., `[:alpha:]`) match a single character\n     * from a defined set and do not introduce backtracking or repetition issues on their own.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\PosixClassNode $node the `PosixClassNode` representing a POSIX character class\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a CommentNode. Comments are ignored by the regex engine and are safe from ReDoS.\n     *\n     * Purpose: Comments within a regex (e.g., `(?#comment)`) do not affect the matching\n     * behavior and thus cannot introduce ReDoS vulnerabilities.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\CommentNode $node the `CommentNode` representing an inline comment\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a PcreVerbNode. PCRE verbs are generally safe from ReDoS on their own.\n     *\n     * Purpose: PCRE control verbs (e.g., `(*FAIL)`, `(*COMMIT)`) influence the regex\n     * engine's behavior but do not typically introduce ReDoS vulnerabilities directly.\n     * This method always returns `ReDoSSeverity::SAFE`.\n     *\n     * @param Node\\PcreVerbNode $node the `PcreVerbNode` representing a PCRE verb\n     *\n     * @return ReDoSSeverity always `ReDoSSeverity::SAFE`\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): ReDoSSeverity\n    {\n        return $this->maxSeverity(\n            $node->yes->accept($this),\n            $node->no->accept($this),\n        );\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): ReDoSSeverity\n    {\n        $this->addVulnerability(\n            ReDoSSeverity::MEDIUM,\n            'Subroutines can lead to complex backtracking and potential ReDoS if not used carefully, especially with recursion. Review the referenced pattern.',\n            $node,\n            'Avoid excessive recursion or add atomic groups around recursive parts.',\n            ReDoSConfidence::MEDIUM,\n            'Medium false-positive risk; recursion depth and input shape matter.',\n        );\n\n        return ReDoSSeverity::MEDIUM;\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): ReDoSSeverity\n    {\n        \/\/ Analyze the content of the DEFINE block for ReDoS vulnerabilities\n        return $node->content->accept($this);\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Visits a CalloutNode and treats it as neutral for ReDoS purposes.\n     *\n     * Callouts delegate to user code without changing the regex's matching language,\n     * so they are considered safe in this static analysis.\n     *\/\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    \/**\n     * Checks if a given quantifier is unbounded (e.g., `*`, `+`, `{n,}`).\n     *\n     * Purpose: This helper method determines if a quantifier allows for an infinite\n     * number of repetitions. This is a key factor in identifying potential ReDoS\n     * vulnerabilities, as unbounded quantifiers are often involved in catastrophic backtracking.\n     *\n     * @param string $quantifier The quantifier string (e.g., `*`, `+`, `{1,5}`).\n     *\n     * @return bool true if the quantifier is unbounded, false otherwise\n     *\/\n    private function isUnbounded(string $quantifier): bool\n    {\n        if (str_contains($quantifier, '*') || str_contains($quantifier, '+')) {\n            return true;\n        }\n\n        if (str_contains($quantifier, ',')) {\n            \/\/ Check for {n,} (unbounded upper limit)\n            return !preg_match('\/,\\d++\\}$\/', $quantifier);\n        }\n\n        return false;\n    }\n\n    \/**\n     * Checks if a given quantifier is bounded but allows for a very large number of\n     * repetitions.\n     *\n     * Purpose: While not as dangerous as unbounded quantifiers, very large bounded quantifiers\n     * (e.g., `{1,10000}`) can still lead to performance issues and potential denial of service\n     * if the regex engine has to backtrack extensively. This method helps flag such cases.\n     *\n     * @param string $quantifier The quantifier string (e.g., `{1,5}`, `{1000}`).\n     *\n     * @return bool true if the quantifier is bounded and large, false otherwise\n     *\/\n    private function isLargeBounded(string $quantifier): bool\n    {\n        if (preg_match('\/\\{(\\d++)(?:,(\\d++))?\\}\/', $quantifier, $m)) {\n            $max = isset($m[2]) ? (int) $m[2] : (int) $m[1];\n\n            return $max > 1000;\n        }\n\n        return false;\n    }\n\n    \/**\n     * Determines if an AlternationNode contains overlapping alternatives.\n     *\n     * Purpose: This complex helper method detects a common ReDoS pattern where different\n     * branches of an alternation can match the same prefix (e.g., `(ab|a)`). When such\n     * an alternation is quantified, it can lead to exponential backtracking. It analyzes\n     * the initial characters of each alternative using `CharSetAnalyzer` to find overlaps.\n     *\n     * @param Node\\AlternationNode $node the `AlternationNode` to check for overlaps\n     *\n     * @return bool true if overlapping alternatives are found, false otherwise\n     *\/\n    private function hasOverlappingAlternatives(Node\\AlternationNode $node): bool\n    {\n        $sets = [];\n\n        foreach ($node->alternatives as $alt) {\n            $set = $this->charSetAnalyzer->firstChars($alt);\n\n            if ($set->isUnknown() || $this->startsWithDot($alt)) {\n                if (!empty($sets)) {\n                    return true;\n                }\n                $sets[] = $set;\n\n                continue;\n            }\n\n            foreach ($sets as $existing) {\n                if ($set->intersects($existing)) {\n                    return true;\n                }\n            }\n\n            $sets[] = $set;\n        }\n\n        return false;\n    }\n\n    \/**\n     * Generates a \"signature\" for the starting element of a node, used for overlap detection.\n     *\n     * Purpose: This helper method is used by `hasOverlappingAlternatives` to quickly\n     * determine if two different regex branches start with a potentially overlapping pattern.\n     * It currently distinguishes only the \"match anything\" prefix (dot) and delegates detailed character overlap\n     * checks to `CharSetAnalyzer`.\n     *\n     * @param Node\\NodeInterface $node the AST node to get the prefix signature for\n     *\n     * @return string A string representing the prefix signature (e.g., 'DOT' or empty if not applicable).\n     *\/\n    private function getPrefixSignature(Node\\NodeInterface $node): string\n    {\n        if ($node instanceof Node\\DotNode) {\n            return 'DOT';\n        }\n        if ($node instanceof Node\\SequenceNode && !empty($node->children)) {\n            return $this->getPrefixSignature($node->children[0]);\n        }\n        if ($node instanceof Node\\GroupNode) {\n            return $this->getPrefixSignature($node->child);\n        }\n        if ($node instanceof Node\\QuantifierNode) {\n            return $this->getPrefixSignature($node->node);\n        }\n\n        return '';\n    }\n\n    private function startsWithDot(Node\\NodeInterface $node): bool\n    {\n        return 'DOT' === $this->getPrefixSignature($node);\n    }\n\n    private function hasTrailingBacktrackingControl(Node\\NodeInterface $node): bool\n    {\n        $verbNode = $this->extractTrailingVerb($node);\n        if (null === $verbNode) {\n            return false;\n        }\n\n        $verbName = strtoupper(explode(':', $verbNode->verb, 2)[0]);\n\n        return \\in_array($verbName, ['COMMIT', 'PRUNE', 'SKIP'], true);\n    }\n\n    private function extractTrailingVerb(Node\\NodeInterface $node): ?Node\\PcreVerbNode\n    {\n        if ($node instanceof Node\\PcreVerbNode) {\n            return $node;\n        }\n\n        if ($node instanceof Node\\SequenceNode && !empty($node->children)) {\n            $last = $node->children[\\count($node->children) - 1];\n\n            return $this->extractTrailingVerb($last);\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->extractTrailingVerb($node->child);\n        }\n\n        return null;\n    }\n\n    private function hasMutuallyExclusiveBoundary(?Node\\NodeInterface $previous, Node\\NodeInterface $current): bool\n    {\n        if (null === $previous) {\n            return false;\n        }\n\n        $previousTail = $this->charSetAnalyzer->lastChars($previous);\n        $currentHead = $this->charSetAnalyzer->firstChars($current);\n\n        if ($previousTail->isUnknown() || $currentHead->isUnknown()) {\n            return false;\n        }\n\n        return !$previousTail->intersects($currentHead);\n    }\n\n    private function hasForwardMutuallyExclusiveBoundary(Node\\NodeInterface $current, ?Node\\NodeInterface $next): bool\n    {\n        if (null === $next) {\n            return false;\n        }\n\n        $currentTail = $this->charSetAnalyzer->lastChars($current);\n        $nextHead = $this->charSetAnalyzer->firstChars($next);\n\n        if ($currentTail->isUnknown() || $nextHead->isUnknown()) {\n            return false;\n        }\n\n        return !$currentTail->intersects($nextHead);\n    }\n\n    private function reduceSeverity(ReDoSSeverity $severity, ReDoSSeverity $cap): ReDoSSeverity\n    {\n        return $this->severityGreaterThan($severity, $cap) ? $cap : $severity;\n    }\n\n    \/**\n     * Adds a detected ReDoS vulnerability to the internal list.\n     *\/\n    private function addVulnerability(\n        ReDoSSeverity $severity,\n        string $message,\n        Node\\NodeInterface $triggerNode,\n        ?string $suggestedRewrite = null,\n        ReDoSConfidence $confidence = ReDoSConfidence::MEDIUM,\n        ?string $falsePositiveRisk = null,\n    ): void {\n        $pattern = $this->compileNode($triggerNode);\n        $trigger = $this->describeTrigger($triggerNode);\n\n        $this->vulnerabilities[] = new ReDoSFinding(\n            $severity,\n            $message,\n            $pattern,\n            $trigger,\n            $suggestedRewrite,\n            $confidence,\n            $falsePositiveRisk,\n        );\n    }\n\n    private function compileNode(Node\\NodeInterface $node): string\n    {\n        return $node->accept(new CompilerNodeVisitor());\n    }\n\n    private function describeTrigger(Node\\NodeInterface $node): string\n    {\n        return match (true) {\n            $node instanceof Node\\QuantifierNode => 'quantifier '.$node->quantifier,\n            $node instanceof Node\\AlternationNode => 'alternation',\n            $node instanceof Node\\GroupNode => 'group',\n            $node instanceof Node\\SubroutineNode => 'subroutine',\n            default => $node::class,\n        };\n    }\n\n    \/**\n     * Compares two ReDoSSeverity values to check if the first is greater than\n     * the second.\n     *\n     * Purpose: This helper method provides a consistent way to compare severity levels,\n     * which are represented by an enum. It's used to determine the highest severity\n     * encountered during the AST traversal.\n     *\n     * @param ReDoSSeverity $a the first severity level to compare\n     * @param ReDoSSeverity $b the second severity level to compare\n     *\n     * @return bool true if severity `$a` is greater than severity `$b`, false otherwise\n     *\/\n    private function severityGreaterThan(ReDoSSeverity $a, ReDoSSeverity $b): bool\n    {\n        $levels = [\n            ReDoSSeverity::SAFE->value => 0,\n            ReDoSSeverity::LOW->value => 1,\n            ReDoSSeverity::UNKNOWN->value => 2,\n            ReDoSSeverity::MEDIUM->value => 3,\n            ReDoSSeverity::HIGH->value => 4,\n            ReDoSSeverity::CRITICAL->value => 5,\n        ];\n\n        return $levels[$a->value] > $levels[$b->value];\n    }\n\n    \/**\n     * Returns the higher of two ReDoSSeverity values.\n     *\n     * Purpose: This helper method simplifies finding the maximum severity level\n     * when combining results from different parts of the AST.\n     *\n     * @param ReDoSSeverity $a the first severity level\n     * @param ReDoSSeverity $b the second severity level\n     *\n     * @return ReDoSSeverity the higher of the two severity levels\n     *\/\n    private function maxSeverity(ReDoSSeverity $a, ReDoSSeverity $b): ReDoSSeverity\n    {\n        return $this->severityGreaterThan($a, $b) ? $a : $b;\n    }\n\n    \/**\n     * Detects if a subtree contains a backreference and a variable-length capturing group,\n     * which can lead to catastrophic backtracking when repeated.\n     *\/\n    private function hasBackrefLoop(Node\\NodeInterface $node): bool\n    {\n        $state = $this->analyzeBackrefLoop($node);\n\n        return $state['hasBackref'] && $state['hasVariableCapture'];\n    }\n\n    \/**\n     * @return array{hasBackref: bool, hasVariableCapture: bool}\n     *\/\n    private function analyzeBackrefLoop(Node\\NodeInterface $node): array\n    {\n        $hasBackref = $node instanceof Node\\BackrefNode;\n        $hasVariableCapture = false;\n\n        if ($node instanceof Node\\GroupNode && $this->isCapturingGroup($node)) {\n            [$min, $max] = $this->lengthRange($node->child);\n            if (null === $max || $min !== $max) {\n                $hasVariableCapture = true;\n            }\n        }\n\n        $children = match (true) {\n            $node instanceof Node\\SequenceNode => $node->children,\n            $node instanceof Node\\AlternationNode => $node->alternatives,\n            $node instanceof Node\\QuantifierNode => [$node->node],\n            $node instanceof Node\\GroupNode => [$node->child],\n            $node instanceof Node\\ConditionalNode => [$node->condition, $node->yes, $node->no],\n            default => [],\n        };\n\n        foreach ($children as $child) {\n            $childState = $this->analyzeBackrefLoop($child);\n            $hasBackref = $hasBackref || $childState['hasBackref'];\n            $hasVariableCapture = $hasVariableCapture || $childState['hasVariableCapture'];\n        }\n\n        return [\n            'hasBackref' => $hasBackref,\n            'hasVariableCapture' => $hasVariableCapture,\n        ];\n    }\n\n    \/**\n     * @return array{0:int, 1:int|null}\n     *\/\n    private function lengthRange(Node\\NodeInterface $node): array\n    {\n        if ($node instanceof Node\\LiteralNode) {\n            $len = \\strlen($node->value);\n\n            return [$len, $len];\n        }\n\n        if ($node instanceof Node\\CharTypeNode\n            || $node instanceof Node\\DotNode\n            || $node instanceof Node\\CharClassNode\n            || $node instanceof Node\\RangeNode\n            || $node instanceof Node\\UnicodeNode\n            || $node instanceof Node\\UnicodePropNode\n            || $node instanceof Node\\CharLiteralNode\n            || $node instanceof Node\\PosixClassNode\n        ) {\n            return [1, 1];\n        }\n\n        if ($node instanceof Node\\AnchorNode\n            || $node instanceof Node\\AssertionNode\n            || $node instanceof Node\\KeepNode\n            || $node instanceof Node\\PcreVerbNode\n            || $node instanceof Node\\CommentNode\n            || $node instanceof Node\\CalloutNode\n        ) {\n            return [0, 0];\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            $min = 0;\n            $max = 0;\n            foreach ($node->children as $child) {\n                [$cMin, $cMax] = $this->lengthRange($child);\n                $min += $cMin;\n                $max = null === $max || null === $cMax ? null : $max + $cMax;\n            }\n\n            return [$min, $max];\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            $min = null;\n            $max = 0;\n            foreach ($node->alternatives as $child) {\n                [$cMin, $cMax] = $this->lengthRange($child);\n                $min = null === $min ? $cMin : min($min, $cMin);\n                $max = null === $max || null === $cMax ? null : max($max, $cMax);\n            }\n\n            return [$min ?? 0, $max];\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->lengthRange($node->child);\n        }\n\n        if ($node instanceof Node\\QuantifierNode) {\n            [$cMin, $cMax] = $this->lengthRange($node->node);\n            [$qMin, $qMax] = $this->quantifierBounds($node->quantifier);\n\n            $min = $cMin * $qMin;\n            $max = null === $cMax || null === $qMax ? null : $cMax * $qMax;\n\n            return [$min, $max];\n        }\n\n        if ($node instanceof Node\\BackrefNode || $node instanceof Node\\SubroutineNode) {\n            return [0, null];\n        }\n\n        return [0, null];\n    }\n\n    \/**\n     * @return array{0:int, 1:int|null}\n     *\/\n    private function quantifierBounds(string $quantifier): array\n    {\n        if ('*' === $quantifier) {\n            return [0, null];\n        }\n        if ('+' === $quantifier) {\n            return [1, null];\n        }\n        if ('?' === $quantifier) {\n            return [0, 1];\n        }\n\n        if (preg_match('\/^\\\\{(\\\\d++),(\\\\d++)\\\\}$\/', $quantifier, $m)) {\n            return [(int) $m[1], (int) $m[2]];\n        }\n\n        if (preg_match('\/^\\\\{(\\\\d++),\\\\}$\/', $quantifier, $m)) {\n            return [(int) $m[1], null];\n        }\n\n        if (preg_match('\/^\\\\{(\\\\d++)\\\\}$\/', $quantifier, $m)) {\n            return [(int) $m[1], (int) $m[1]];\n        }\n\n        return [0, null];\n    }\n\n    private function isCapturingGroup(Node\\GroupNode $group): bool\n    {\n        return \\in_array($group->type, [\n            GroupType::T_GROUP_CAPTURING,\n            GroupType::T_GROUP_NAMED,\n            GroupType::T_GROUP_BRANCH_RESET,\n        ], true);\n    }\n}\n",
    "NodeVisitor\/ModernizerNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Modernizes legacy or messy regular expressions into clean, concise PCRE2-compliant patterns.\n *\n * @extends AbstractNodeVisitor<\\RegexParser\\Node\\NodeInterface>\n *\/\nfinal class ModernizerNodeVisitor extends AbstractNodeVisitor\n{\n    private string $delimiter = '\/';\n\n    #[\\Override]\n    public function visitRegex(\\RegexParser\\Node\\RegexNode $node)\n    {\n        $this->delimiter = $node->delimiter;\n\n        return new \\RegexParser\\Node\\RegexNode(\n            $node->pattern->accept($this),\n            $node->flags,\n            $node->delimiter,\n            $node->getStartPosition(),\n            $node->getEndPosition(),\n        );\n    }\n\n    #[\\Override]\n    public function visitCharClass(\\RegexParser\\Node\\CharClassNode $node)\n    {\n        $parts = $node->expression instanceof \\RegexParser\\Node\\AlternationNode\n            ? $node->expression->alternatives\n            : [$node->expression];\n\n        \/\/ Check for \\d equivalent: [0-9]\n        if (!$node->isNegated && 1 === \\count($parts) && $parts[0] instanceof \\RegexParser\\Node\\RangeNode) {\n            $range = $parts[0];\n            if ($range->start instanceof \\RegexParser\\Node\\LiteralNode && $range->end instanceof \\RegexParser\\Node\\LiteralNode\n                && '0' === $range->start->value && '9' === $range->end->value) {\n                return new \\RegexParser\\Node\\CharTypeNode('d', $node->getStartPosition(), $node->getEndPosition());\n            }\n        }\n\n        \/\/ Check for \\s equivalent: [\\t\\n\\r\\f\\v]\n        if (!$node->isNegated && 5 === \\count($parts)) {\n            $whitespaceChars = [\"\\t\", \"\\n\", \"\\r\", \"\\f\", \"\\v\"];\n            $foundChars = [];\n            foreach ($parts as $part) {\n                if ($part instanceof \\RegexParser\\Node\\LiteralNode && \\in_array($part->value, $whitespaceChars, true)) {\n                    $foundChars[] = $part->value;\n                }\n            }\n            if (5 === \\count($foundChars) && $foundChars === $whitespaceChars) {\n                return new \\RegexParser\\Node\\CharTypeNode('s', $node->getStartPosition(), $node->getEndPosition());\n            }\n        }\n\n        \/\/ For other cases, keep as is but modernize parts\n        $modernizedParts = array_map(fn ($part) => $part->accept($this), $parts);\n        $expression = 1 === \\count($modernizedParts)\n            ? $modernizedParts[0]\n            : new \\RegexParser\\Node\\AlternationNode($modernizedParts, $node->getStartPosition(), $node->getEndPosition());\n\n        return new \\RegexParser\\Node\\CharClassNode($expression, $node->isNegated, $node->getStartPosition(), $node->getEndPosition());\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): Node\\NodeInterface\n    {\n        $value = $node->value;\n\n        \/\/ Remove unnecessary escaping\n        if (str_starts_with($value, '\\\\')) {\n            $char = substr($value, 1);\n            \/\/ Meta chars that need escaping: . \\ + * ? ^ $ ( ) [ ] { } | \/ (if delimiter)\n            $metaChars = ['.', '\\\\', '+', '*', '?', '^', '$', '(', ')', '[', ']', '{', '}', '|'];\n            if ('\/' !== $this->delimiter && $this->delimiter !== $char) {\n                $metaChars[] = $this->delimiter;\n            }\n            if (!\\in_array($char, $metaChars, true)) {\n                \/\/ Safe to unescape\n                return new Node\\LiteralNode($char, $node->getStartPosition(), $node->getEndPosition());\n            }\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): Node\\NodeInterface\n    {\n        \/\/ Unwrap redundant non-capturing groups: (?:expr) -> expr if not quantified\n        \/\/ Assume safe for non-capturing groups without name or flags\n        if (Node\\GroupType::T_GROUP_NON_CAPTURING === $node->type && null === $node->name && null === $node->flags) {\n            return $node->child->accept($this);\n        }\n\n        return new Node\\GroupNode(\n            $node->child->accept($this),\n            $node->type,\n            $node->name,\n            $node->flags,\n            $node->getStartPosition(),\n            $node->getEndPosition(),\n        );\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): Node\\NodeInterface\n    {\n        $ref = $node->ref;\n        \/\/ Convert \\1 to \\g{1}\n        if (is_numeric($ref)) {\n            return new Node\\BackrefNode('\\g{'.$ref.'}', $node->getStartPosition(), $node->getEndPosition());\n        }\n\n        return $node;\n    }\n\n    \/\/ For other nodes, just recurse or return as is\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): Node\\NodeInterface\n    {\n        $alternatives = array_map(fn ($alt) => $alt->accept($this), $node->alternatives);\n\n        return new Node\\AlternationNode($alternatives, $node->getStartPosition(), $node->getEndPosition());\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): Node\\NodeInterface\n    {\n        $children = array_map(fn ($n) => $n->accept($this), $node->children);\n\n        return new Node\\SequenceNode($children, $node->getStartPosition(), $node->getEndPosition());\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): Node\\NodeInterface\n    {\n        return new Node\\QuantifierNode(\n            $node->node->accept($this),\n            $node->quantifier,\n            $node->type,\n            $node->getStartPosition(),\n            $node->getEndPosition(),\n        );\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitConditional(\\RegexParser\\Node\\ConditionalNode $node)\n    {\n        \/\/ @phpstan-ignore if.alwaysTrue\n        if ($node->no) {\n            $noBranch = $node->no->accept($this);\n        } else {\n            $noBranch = null;\n        }\n\n        return new \\RegexParser\\Node\\ConditionalNode(\n            $node->condition->accept($this),\n            $node->yes->accept($this),\n            $noBranch,\n            $node->getStartPosition(),\n            $node->getEndPosition(),\n        );\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitScriptRun(Node\\ScriptRunNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitVersionCondition(Node\\VersionConditionNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitControlChar(Node\\ControlCharNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitClassOperation(Node\\ClassOperationNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/\/ Add other visit methods as needed, default to parent\n}\n",
    "NodeVisitor\/MermaidNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Generates a Mermaid.js flowchart to visualize the regex structure.\n *\n * Purpose: This visitor is a powerful debugging and documentation tool that translates\n * the AST into a visual flowchart using Mermaid.js syntax. It's the engine behind the\n * `Regex::visualize()` method. For contributors, this class is an excellent example of\n * how to perform a complex transformation on the AST to produce a structured, text-based\n * output. Each `visit` method is responsible for creating the correct Mermaid.js syntax\n * for a specific AST node.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nfinal class MermaidNodeVisitor extends AbstractNodeVisitor\n{\n    private int $nodeCounter = 0;\n\n    \/**\n     * @var list<string>\n     *\/\n    private array $lines = [];\n\n    \/**\n     * Generates the graph for the root `RegexNode`.\n     *\n     * Purpose: This is the entry point for the graph generation. It initializes the\n     * Mermaid.js graph definition, creates the root node representing the entire\n     * regex (including its flags), and then recursively calls the visitor on the\n     * main pattern.\n     *\n     * @param Node\\RegexNode $node the root node of the AST\n     *\n     * @return string The complete Mermaid.js graph definition.\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        $this->nodeCounter = 0;\n        $this->lines = [];\n        $this->lines[] = 'graph TD;';\n\n        $nodeId = $this->nextNodeId();\n        $flags = $node->flags ?: 'none';\n        $this->lines[] = \\sprintf('    %s[\"Regex: %s\"]', $nodeId, $this->escape($flags));\n\n        $childId = $node->pattern->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n\n        return implode(\"\\n\", $this->lines);\n    }\n\n    \/**\n     * Generates the graph node for an `AlternationNode`.\n     *\n     * Purpose: This method creates a diamond-shaped \"Alternation\" node in the graph\n     * and then draws arrows from it to each of its alternative branches, clearly\n     * visualizing the \"either\/or\" logic.\n     *\n     * @param Node\\AlternationNode $node the alternation node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s{\"Alternation\"}', $nodeId);\n\n        foreach ($node->alternatives as $child) {\n            $childId = $child->accept($this);\n            $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n        }\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `SequenceNode`.\n     *\n     * Purpose: This method creates a \"Sequence\" node and then draws arrows to each\n     * of its children in order, visualizing the sequential nature of the components.\n     *\n     * @param Node\\SequenceNode $node the sequence node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Sequence\"]', $nodeId);\n\n        foreach ($node->children as $child) {\n            $childId = $child->accept($this);\n            $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n        }\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `GroupNode`.\n     *\n     * Purpose: This method creates a node representing a group, labeling it with its\n     * type (e.g., capturing, lookahead) and name, and then connects it to the\n     * subgraph representing the group's contents.\n     *\n     * @param Node\\GroupNode $node the group node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $label = \\sprintf('Group: %s', $node->type->value);\n        $name = $node->name ? ' ('.$node->name.')' : '';\n        $this->lines[] = \\sprintf('    %s(\"%s%s\")', $nodeId, $this->escape($label), $this->escape($name));\n\n        $childId = $node->child->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `QuantifierNode`.\n     *\n     * Purpose: This method creates a node representing a quantifier (e.g., `*`, `+`),\n     * and connects it to the node that it modifies.\n     *\n     * @param Node\\QuantifierNode $node the quantifier node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $label = \\sprintf('Quantifier: %s', $node->quantifier);\n        $this->lines[] = \\sprintf('    %s[\"%s\"]', $nodeId, $this->escape($label));\n\n        $childId = $node->node->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `LiteralNode`.\n     *\n     * Purpose: This method creates a simple node representing a literal character or string.\n     *\n     * @param Node\\LiteralNode $node the literal node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $value = '' === $node->value ? '(empty)' : $node->value;\n        $this->lines[] = \\sprintf('    %s[\"Literal: %s\"]', $nodeId, $this->escape($value));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `CharTypeNode`.\n     *\n     * Purpose: This method creates a node for a character type like `\\d` or `\\s`.\n     *\n     * @param Node\\CharTypeNode $node the character type node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"CharType: \\\\%s\"]', $nodeId, $this->escape($node->value));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `DotNode`.\n     *\n     * Purpose: This method creates a node for the \"any character\" wildcard (`.`).\n     *\n     * @param Node\\DotNode $node the dot node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Dot: any char\"]', $nodeId);\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for an `AnchorNode`.\n     *\n     * Purpose: This method creates a circular node for an anchor like `^` or `$`.\n     *\n     * @param Node\\AnchorNode $node the anchor node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s((\"Anchor: %s\"))', $nodeId, $this->escape($node->value));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for an `AssertionNode`.\n     *\n     * Purpose: This method creates a node for a zero-width assertion like `\\b`.\n     *\n     * @param Node\\AssertionNode $node the assertion node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Assertion: %s\"]', $nodeId, $this->escape($node->value));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `KeepNode`.\n     *\n     * Purpose: This method creates a node for the `\\K` (keep) assertion.\n     *\n     * @param Node\\KeepNode $node the keep node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Keep: \\\\K\"]', $nodeId);\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `CharClassNode`.\n     *\n     * Purpose: This method creates a node for a character class `[...]`, indicating if\n     * it is negated, and then connects it to the nodes representing its contents.\n     *\n     * @param Node\\CharClassNode $node the character class node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $label = 'CharClass'.($node->isNegated ? ' [NOT]' : '');\n        $this->lines[] = \\sprintf('    %s[\"%s\"]', $nodeId, $label);\n\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        foreach ($parts as $child) {\n            $childId = $child->accept($this);\n            $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n        }\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `RangeNode`.\n     *\n     * Purpose: This method creates a \"Range\" node and connects it to the start and\n     * end points of the range (e.g., `a` and `z` in `a-z`).\n     *\n     * @param Node\\RangeNode $node the range node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Range\"]', $nodeId);\n\n        $startId = $node->start->accept($this);\n        $endId = $node->end->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|from| %s', $nodeId, $startId);\n        $this->lines[] = \\sprintf('    %s -->|to| %s', $nodeId, $endId);\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `BackrefNode`.\n     *\n     * Purpose: This method creates a node for a backreference like `\\1`.\n     *\n     * @param Node\\BackrefNode $node the backreference node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Backref: %s\"]', $nodeId, $this->escape($node->ref));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `UnicodeNode`.\n     *\n     * Purpose: This method creates a node for a Unicode character escape.\n     *\n     * @param Node\\UnicodeNode $node the Unicode node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Unicode: %s\"]', $nodeId, $this->escape($node->code));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `UnicodePropNode`.\n     *\n     * Purpose: This method creates a node for a Unicode property escape like `\\p{L}`.\n     *\n     * @param Node\\UnicodePropNode $node the Unicode property node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"UnicodeProp: %s\"]', $nodeId, $this->escape($node->prop));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `PosixClassNode`.\n     *\n     * Purpose: This method creates a node for a POSIX character class like `[:alpha:]`.\n     *\n     * @param Node\\PosixClassNode $node the POSIX class node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"PosixClass: %s\"]', $nodeId, $this->escape($node->class));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `CommentNode`.\n     *\n     * Purpose: This method creates a node representing an inline comment.\n     *\n     * @param Node\\CommentNode $node the comment node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $comment = substr($node->comment, 0, 20);\n        $this->lines[] = \\sprintf('    %s[\"Comment: %s\"]', $nodeId, $this->escape($comment));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph nodes for a `ConditionalNode`.\n     *\n     * Purpose: This method creates a diamond-shaped \"Conditional\" node and connects it\n     * to its three branches: the condition, the \"yes\" pattern, and the \"no\" pattern.\n     *\n     * @param Node\\ConditionalNode $node the conditional node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s{{\"Conditional\"}}', $nodeId);\n\n        $condId = $node->condition->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|condition| %s', $nodeId, $condId);\n\n        $yesId = $node->yes->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|yes| %s', $nodeId, $yesId);\n\n        $noId = $node->no->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|no| %s', $nodeId, $noId);\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `SubroutineNode`.\n     *\n     * Purpose: This method creates a node for a subroutine call like `(?R)`.\n     *\n     * @param Node\\SubroutineNode $node the subroutine node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Subroutine: %s\"]', $nodeId, $this->escape($node->reference));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `PcreVerbNode`.\n     *\n     * Purpose: This method creates a node for a PCRE verb like `(*FAIL)`.\n     *\n     * @param Node\\PcreVerbNode $node the PCRE verb node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"PcreVerb: %s\"]', $nodeId, $this->escape($node->verb));\n\n        return $nodeId;\n    }\n\n    \/**\n     * Generates the graph node for a `DefineNode`.\n     *\n     * Purpose: This method creates a node for a `(?(DEFINE)...)` block.\n     *\n     * @param Node\\DefineNode $node the define node to visualize\n     *\n     * @return string the unique ID of the generated graph node\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"DEFINE Block\"]', $nodeId);\n\n        $contentId = $node->content->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $contentId);\n\n        return $nodeId;\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"LimitMatch: %d\"]', $nodeId, $node->limit);\n\n        return $nodeId;\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        $label = match (true) {\n            \\is_int($node->identifier) => '(?C'.$node->identifier.')',\n            $node->isStringIdentifier => '(?C\"'.$node->identifier.'\")',\n            default => '(?C'.$node->identifier.')',\n        };\n\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Callout: %s\"]', $nodeId, $this->escape($label));\n\n        return $nodeId;\n    }\n\n    private function nextNodeId(): string\n    {\n        return 'node'.($this->nodeCounter++);\n    }\n\n    private function escape(string $value): string\n    {\n        return htmlspecialchars($value, \\ENT_QUOTES | \\ENT_HTML5, 'UTF-8');\n    }\n}\n",
    "NodeVisitor\/DumperNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Dumps the Abstract Syntax Tree (AST) into a human-readable string format.\n *\n * Purpose: This visitor is a primary debugging tool for contributors. It traverses the\n * AST and generates an indented, hierarchical representation of the nodes. This allows\n * you to visually inspect the structure of the tree that the `Parser` produces, which is\n * essential for verifying that a regex is parsed correctly or for understanding how a\n * new node type fits into the overall structure.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nfinal class DumperNodeVisitor extends AbstractNodeVisitor\n{\n    private int $indent = 0;\n\n    \/**\n     * Dumps the root `RegexNode`.\n     *\n     * Purpose: This is the entry point for the dumping process. It formats the top-level\n     * node, including its delimiters and flags, and then recursively calls the visitor\n     * on its child pattern. This method provides a high-level overview of the entire\n     * parsed regular expression.\n     *\n     * @param Node\\RegexNode $node the root node of the AST\n     *\n     * @return string the string representation of the entire AST\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        $str = \"Regex(delimiter: {$node->delimiter}, flags: {$node->flags})\\n\";\n        $this->indent += 2;\n        $str .= $node->pattern->accept($this);\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    \/**\n     * Dumps an `AlternationNode`.\n     *\n     * Purpose: This method visualizes an alternation (`|`). It prints the \"Alternation\"\n     * label and then recursively dumps each of its alternative child sequences, clearly\n     * showing the different branches the regex can take. This helps in understanding\n     * the \"OR\" logic within the pattern.\n     *\n     * @param Node\\AlternationNode $node the alternation node to dump\n     *\n     * @return string the string representation of the alternation and its children\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        $str = str_repeat(' ', $this->indent).\"Alternation:\\n\";\n        $this->indent += 2;\n        foreach ($node->alternatives as $alt) {\n            $str .= str_repeat(' ', $this->indent).$alt->accept($this).\"\\n\";\n        }\n        $this->indent -= 2;\n\n        return rtrim($str, \"\\n\");\n    }\n\n    \/**\n     * Dumps a `SequenceNode`.\n     *\n     * Purpose: This method visualizes a sequence of consecutive regex components. It\n     * prints the \"Sequence\" label and then recursively dumps each child node in order,\n     * showing how the components are arranged sequentially. This helps in understanding\n     * the \"AND\" logic within the pattern.\n     *\n     * @param Node\\SequenceNode $node the sequence node to dump\n     *\n     * @return string the string representation of the sequence and its children\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        $str = str_repeat(' ', $this->indent).\"Sequence:\\n\";\n        $this->indent += 2;\n        foreach ($node->children as $child) {\n            $str .= str_repeat(' ', $this->indent).$child->accept($this).\"\\n\";\n        }\n        $this->indent -= 2;\n\n        return rtrim($str, \"\\n\");\n    }\n\n    \/**\n     * Dumps a `GroupNode`.\n     *\n     * Purpose: This method visualizes any type of group, such as capturing `(...)`,\n     * non-capturing `(?:...)`, or lookaheads `(?=...)`. It prints the group's type,\n     * name (if any), and flags, then recursively dumps the child expression inside\n     * the group. This provides insight into the grouping and sub-pattern structure.\n     *\n     * @param Node\\GroupNode $node the group node to dump\n     *\n     * @return string the string representation of the group and its child\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $name = $node->name ?? '';\n        $flags = $node->flags ?? '';\n\n        \/\/ Only include \"name:\" label if name is not empty\n        $nameStr = ('' !== $name) ? \" name: {$name}\" : '';\n        $str = \"Group(type: {$node->type->value}{$nameStr} flags: {$flags})\\n\";\n        $this->indent += 2;\n        $str .= $node->child->accept($this);\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    \/**\n     * Dumps a `QuantifierNode`.\n     *\n     * Purpose: This method visualizes a quantifier like `*`, `+`, or `{2,5}`. It\n     * prints the quantifier's token and type (greedy, lazy, possessive), then\n     * recursively dumps the node that the quantifier applies to. This helps in\n     * understanding the repetition rules applied to a specific pattern element.\n     *\n     * @param Node\\QuantifierNode $node the quantifier node to dump\n     *\n     * @return string the string representation of the quantifier and its child\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        return \"Quantifier(quant: {$node->quantifier}, type: {$node->type->value})\\n\".$this->indent(\n            $node->node->accept($this),\n        );\n    }\n\n    \/**\n     * Dumps a `LiteralNode`.\n     *\n     * Purpose: This method visualizes a literal character or string. It simply\n     * prints \"Literal\" followed by the literal value itself. This is the most\n     * basic building block of a regex, representing exact character matches.\n     *\n     * @param Node\\LiteralNode $node the literal node to dump\n     *\n     * @return string the string representation of the literal\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        return \"Literal('{$node->value}')\";\n    }\n\n    \/**\n     * Dumps a `CharTypeNode`.\n     *\n     * Purpose: This method visualizes a character type escape sequence like `\\d` or `\\s`.\n     * It prints \"CharType\" followed by the escaped sequence. This helps in understanding\n     * the shorthand character classes used in the pattern.\n     *\n     * @param Node\\CharTypeNode $node the character type node to dump\n     *\n     * @return string the string representation of the character type\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        return \"CharType('\\\\{$node->value}')\";\n    }\n\n    \/**\n     * Dumps a `DotNode`.\n     *\n     * Purpose: This method visualizes the \"any character\" wildcard (`.`).\n     * It represents a single character match, excluding newlines by default.\n     *\n     * @param Node\\DotNode $node the dot node to dump\n     *\n     * @return string the string representation of the dot\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        return 'Dot(.)';\n    }\n\n    \/**\n     * Dumps an `AnchorNode`.\n     *\n     * Purpose: This method visualizes an anchor like `^` or `$`. Anchors assert\n     * a position in the string without consuming characters.\n     *\n     * @param Node\\AnchorNode $node the anchor node to dump\n     *\n     * @return string the string representation of the anchor\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        return \"Anchor({$node->value})\";\n    }\n\n    \/**\n     * Dumps an `AssertionNode`.\n     *\n     * Purpose: This method visualizes a zero-width assertion like `\\b` (word boundary)\n     * or `\\A` (start of subject). These assertions check for conditions without\n     * consuming any characters.\n     *\n     * @param Node\\AssertionNode $node the assertion node to dump\n     *\n     * @return string the string representation of the assertion\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        return \"Assertion(\\\\{$node->value})\";\n    }\n\n    \/**\n     * Dumps a `KeepNode`.\n     *\n     * Purpose: This method visualizes the `\\K` (keep) escape sequence, which resets\n     * the beginning of the reported match. This is important for understanding how\n     * the final matched string is determined.\n     *\n     * @param Node\\KeepNode $node the keep node to dump\n     *\n     * @return string the string representation of the keep node\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        return 'Keep(\\K)';\n    }\n\n    \/**\n     * Dumps a `CharClassNode`.\n     *\n     * Purpose: This method visualizes a character class `[...]`. It indicates whether\n     * the class is negated and then recursively dumps each of the components inside\n     * the class (e.g., literals, ranges, character types). This helps in understanding\n     * the set of characters that can be matched at a given point.\n     *\n     * @param Node\\CharClassNode $node the character class node to dump\n     *\n     * @return string the string representation of the character class and its parts\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        $neg = $node->isNegated ? '^' : '';\n        $str = \"CharClass({$neg})\\n\";\n        $this->indent += 2;\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        foreach ($parts as $part) {\n            $str .= $this->indent($part->accept($this)).\"\\n\";\n        }\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    \/**\n     * Dumps a `RangeNode`.\n     *\n     * Purpose: This method visualizes a range within a character class, like `a-z`.\n     * It recursively dumps the start and end nodes of the range, providing a clear\n     * view of the character sequence being matched.\n     *\n     * @param Node\\RangeNode $node the range node to dump\n     *\n     * @return string the string representation of the range\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        return \"Range({$node->start->accept($this)} - {$node->end->accept($this)})\";\n    }\n\n    \/**\n     * Dumps a `BackrefNode`.\n     *\n     * Purpose: This method visualizes a backreference, like `\\1` or `\\k<name>`.\n     * It shows which captured group is being referenced, which is crucial for\n     * understanding patterns that match repeated text.\n     *\n     * @param Node\\BackrefNode $node the backreference node to dump\n     *\n     * @return string the string representation of the backreference\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        return \"Backref(\\\\{$node->ref})\";\n    }\n\n    \/**\n     * Dumps a `UnicodeNode`.\n     *\n     * Purpose: This method visualizes a Unicode character escape, like `\\x{...}`.\n     * It shows the hexadecimal code point of the character being matched, which\n     * is important for internationalized regexes.\n     *\n     * @param Node\\UnicodeNode $node the Unicode node to dump\n     *\n     * @return string the string representation of the Unicode character\n     *\/\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): string\n    {\n        return \"Unicode({$node->code})\";\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): string\n    {\n        $type = match ($node->type) {\n            Node\\CharLiteralType::OCTAL => 'Octal',\n            Node\\CharLiteralType::OCTAL_LEGACY => 'OctalLegacy',\n            Node\\CharLiteralType::UNICODE => 'Unicode',\n            Node\\CharLiteralType::UNICODE_NAMED => 'UnicodeNamed',\n        };\n\n        \/\/ For display, use original representation to show the escape\n        return \"{$type}({$node->originalRepresentation})\";\n    }\n\n    #[\\Override]\n    public function visitClassOperation(Node\\ClassOperationNode $node): string\n    {\n        $op = Node\\ClassOperationType::INTERSECTION === $node->type ? '&&' : '--';\n\n        return \"ClassOperation({$op}, \".$node->left->accept($this).', '.$node->right->accept($this).')';\n    }\n\n    #[\\Override]\n    public function visitControlChar(Node\\ControlCharNode $node): string\n    {\n        return \"ControlChar({$node->char})\";\n    }\n\n    #[\\Override]\n    public function visitScriptRun(Node\\ScriptRunNode $node): string\n    {\n        return \"ScriptRun({$node->script})\";\n    }\n\n    #[\\Override]\n    public function visitVersionCondition(Node\\VersionConditionNode $node): string\n    {\n        return \"VersionCondition({$node->operator}, {$node->version})\";\n    }\n\n    \/**\n     * Dumps a `UnicodePropNode`.\n     *\n     * Purpose: This method visualizes a Unicode property escape, like `\\p{L}`.\n     * It shows the Unicode property being matched (e.g., \"Letter\", \"Number\"),\n     * which is vital for patterns dealing with diverse character sets.\n     *\n     * @param Node\\UnicodePropNode $node the Unicode property node to dump\n     *\n     * @return string the string representation of the Unicode property\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        return \"UnicodeProp(\\\\p{{$node->prop}})\";\n    }\n\n    \/**\n     * Dumps a `PosixClassNode`.\n     *\n     * Purpose: This method visualizes a POSIX character class, like `[:alpha:]`.\n     * It shows the name of the POSIX class, which represents predefined sets of\n     * characters (e.g., letters, digits).\n     *\n     * @param Node\\PosixClassNode $node the POSIX class node to dump\n     *\n     * @return string the string representation of the POSIX class\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return \"PosixClass([[:{$node->class}:]])\";\n    }\n\n    \/**\n     * Dumps a `CommentNode`.\n     *\n     * Purpose: This method visualizes an inline comment, like `(?#...)`.\n     * It shows the content of the comment, which is ignored by the regex engine\n     * but important for human readability and documentation.\n     *\n     * @param Node\\CommentNode $node the comment node to dump\n     *\n     * @return string the string representation of the comment\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        return \"Comment('{$node->comment}')\";\n    }\n\n    \/**\n     * Dumps a `ConditionalNode`.\n     *\n     * Purpose: This method visualizes a conditional subpattern, like `(?(cond)yes|no)`.\n     * It recursively dumps the condition, the \"yes\" pattern, and the \"no\" pattern,\n     * providing a clear view of the branching logic within the regex.\n     *\n     * @param Node\\ConditionalNode $node the conditional node to dump\n     *\n     * @return string the string representation of the conditional structure\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        $str = \"Conditional:\\n\";\n        $this->indent += 2;\n        $str .= $this->indent('Condition: '.$node->condition->accept($this)).\"\\n\";\n        $str .= $this->indent('Yes: '.$node->yes->accept($this)).\"\\n\";\n        $str .= $this->indent('No: '.$node->no->accept($this)).\"\\n\";\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    \/**\n     * Dumps a `SubroutineNode`.\n     *\n     * Purpose: This method visualizes a subroutine call, like `(?R)` or `(?&name)`.\n     * It shows the reference and syntax used, which is important for understanding\n     * how parts of the regex are reused or called recursively.\n     *\n     * @param Node\\SubroutineNode $node the subroutine node to dump\n     *\n     * @return string the string representation of the subroutine call\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        return \"Subroutine(ref: {$node->reference}, syntax: '{$node->syntax}')\";\n    }\n\n    \/**\n     * Dumps a `PcreVerbNode`.\n     *\n     * Purpose: This method visualizes a PCRE verb, like `(*FAIL)` or `(*MARK)`.\n     * It shows the specific verb and its arguments, which are crucial for understanding\n     * how the regex engine's backtracking behavior is controlled.\n     *\n     * @param Node\\PcreVerbNode $node the PCRE verb node to dump\n     *\n     * @return string the string representation of the verb\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        return \"PcreVerb(value: {$node->verb})\";\n    }\n\n    \/**\n     * Dumps a `DefineNode`.\n     *\n     * .     *\n     * Purpose: This method visualizes a `(?(DEFINE)...)` group, which is used to\n     * define subroutines that are not executed in place. It recursively dumps the\n     * content of the define block, showing the reusable patterns.\n     *\n     * @param Node\\DefineNode $node the define node to dump\n     *\n     * @return string the string representation of the define group\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        $str = \"Define:\\n\";\n        $this->indent += 2;\n        $str .= $this->indent('Content: '.$node->content->accept($this)).\"\\n\";\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        return \"LimitMatch(limit: {$node->limit})\";\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        $identifier = \\is_string($node->identifier) ? \"'{$node->identifier}'\" : $node->identifier;\n\n        return \"Callout({$identifier})\";\n    }\n\n    private function indent(string $str): string\n    {\n        $indentStr = str_repeat(' ', $this->indent);\n\n        return $indentStr.str_replace(\"\\n\", \"\\n\".$indentStr, $str);\n    }\n}\n",
    "NodeVisitor\/SampleGeneratorNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * A visitor that generates a random sample string that matches the AST.\n *\n * @extends AbstractNodeVisitor<string>\n *\/\nfinal class SampleGeneratorNodeVisitor extends AbstractNodeVisitor\n{\n    private const MAX_RECURSION_DEPTH = 2;\n\n    private ?int $seed = null;\n\n    \/**\n     * Stores generated text from capturing groups.\n     * Keyed by both numeric index and name (if available).\n     *\n     * @var array<int|string, string>\n     *\/\n    private array $captures = [];\n\n    private int $groupCounter = 1;\n\n    private int $recursionDepth = 0;\n\n    private ?Node\\NodeInterface $rootPattern = null;\n\n    \/**\n     * @var array<int, Node\\GroupNode>\n     *\/\n    private array $groupIndexMap = [];\n\n    \/**\n     * @var array<string, Node\\GroupNode>\n     *\/\n    private array $namedGroupMap = [];\n\n    \/**\n     * @var array<int, int>\n     *\/\n    private array $groupNumbers = [];\n\n    private int $groupDefinitionCounter = 1;\n\n    private int $totalGroupCount = 0;\n\n    \/**\n     * Constructs a new SampleGeneratorNodeVisitor.\n     *\n     * Purpose: Initializes the visitor with a maximum repetition limit. This limit is crucial\n     * for preventing infinite loops or excessively long sample strings when dealing with\n     * quantifiers like `*` (zero or more) or `+` (one or more), ensuring that sample generation\n     * remains practical and performant.\n     *\n     * @param int $maxRepetition The maximum number of times a quantifier like `*` or `+`\n     *                           should repeat its preceding element. This prevents\n     *                           excessively long or infinite samples.\n     *\/\n    public function __construct(private readonly int $maxRepetition = 3) {}\n\n    \/**\n     * Seeds the Mersenne Twister random number generator.\n     *\n     * Purpose: This method allows for deterministic sample generation. By setting a specific\n     * seed, you can ensure that the `SampleGeneratorNodeVisitor` will produce the exact same\n     * sample string for a given regex every time it's run with that seed. This is highly\n     * beneficial for reproducible testing and debugging.\n     *\n     * @param int $seed the integer seed value to use for the random number generator\n     *\/\n    public function setSeed(int $seed): void\n    {\n        $this->seed = $seed;\n        mt_srand($seed);\n    }\n\n    \/**\n     * Resets the random number generator to its default, unseeded state.\n     *\n     * Purpose: This method reverts the random number generator to its default behavior,\n     * where it is seeded with a truly random value (or based on the system time).\n     * This is useful when you want to generate different, non-reproducible samples\n     * after having previously set a specific seed.\n     *\/\n    public function resetSeed(): void\n    {\n        $this->seed = null;\n        mt_srand();\n    }\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): string\n    {\n        \/\/ Reset state for this run\n        $this->captures = [];\n        $this->groupCounter = 1;\n        $this->recursionDepth = 0;\n        $this->rootPattern = $node->pattern;\n        $this->groupIndexMap = [];\n        $this->namedGroupMap = [];\n        $this->groupNumbers = [];\n        $this->groupDefinitionCounter = 1;\n        $this->collectGroups($node->pattern);\n        $this->totalGroupCount = $this->groupDefinitionCounter - 1;\n\n        \/\/ Ensure we are seeded if the user expects it\n        if (null !== $this->seed) {\n            mt_srand($this->seed);\n        }\n\n        \/\/ Note: Flags (like \/i) are ignored, as we generate the sample\n        \/\/ from the literal pattern.\n        return $node->pattern->accept($this);\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): string\n    {\n        if (empty($node->alternatives)) {\n            return '';\n        }\n\n        \/\/ Pick one of the alternatives at random\n        $randomKey = mt_rand(0, \\count($node->alternatives) - 1);\n        $chosenAlt = $node->alternatives[$randomKey];\n\n        return $chosenAlt->accept($this);\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): string\n    {\n        $parts = array_map(fn ($child) => $child->accept($this), $node->children);\n\n        return implode('', $parts);\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        \/\/ Lookarounds are zero-width assertions and should not generate text\n        if (\\in_array($node->type, [\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n        ], true)) {\n            return '';\n        }\n\n        $result = $node->child->accept($this);\n\n        \/\/ Store the result if it's a capturing group\n        if (GroupType::T_GROUP_CAPTURING === $node->type) {\n            $groupIndex = $this->groupNumbers[spl_object_id($node)] ?? $this->groupCounter++;\n            $this->captures[$groupIndex] = $result;\n            $this->groupCounter = max($this->groupCounter, $groupIndex + 1);\n        } elseif (GroupType::T_GROUP_NAMED === $node->type) {\n            $groupIndex = $this->groupNumbers[spl_object_id($node)] ?? $this->groupCounter++;\n            $this->captures[$groupIndex] = $result;\n            if ($node->name) {\n                $this->captures[$node->name] = $result;\n            }\n            $this->groupCounter = max($this->groupCounter, $groupIndex + 1);\n        }\n\n        \/\/ For non-capturing, etc., just return the child's result\n        return $result;\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): string\n    {\n        [$min, $max] = $this->parseQuantifierRange($node->quantifier);\n\n        \/\/ Pick a random number of repetitions\n        try {\n            \/\/ $min and $max are guaranteed to be in the correct order\n            \/\/ by parseQuantifierRange()\n            $repeats = ($min === $max) ? $min : mt_rand($min, $max);\n        } catch (\\Throwable) {\n            $repeats = $min; \/\/ Fallback\n        }\n\n        $parts = [];\n        for ($i = 0; $i < $repeats; $i++) {\n            $parts[] = $node->node->accept($this);\n        }\n\n        return implode('', $parts);\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): string\n    {\n        return $node->value;\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): string\n    {\n        return $this->generateForCharType($node->value);\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): string\n    {\n        \/\/ Generate a random, simple, printable ASCII char\n        return $this->getRandomChar(['a', 'b', 'c', '1', '2', '3', ' ']);\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): string\n    {\n        \/\/ Anchors do not generate text\n        return '';\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): string\n    {\n        \/\/ Assertions do not generate text\n        return '';\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): string\n    {\n        \/\/ \\K does not generate text\n        return '';\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): string\n    {\n        if ($node->isNegated) {\n            \/\/ Generating for a negated class is complex.\n            \/\/ We'd have to know the full set of all possible chars\n            \/\/ (ASCII? Unicode?) and subtract the parts.\n            \/\/ For a sample, it's safer to return a known \"safe\" char\n            \/\/ that is unlikely to be in the negated set.\n            return '!'; \/\/ e.g., a \"safe\" punctuation mark\n        }\n\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        if (empty($parts)) {\n            \/\/ e.g., [] which can never match\n            throw new \\RuntimeException('Cannot generate sample for empty character class');\n        }\n\n        \/\/ Pick one of the parts at random\n        $randomKey = mt_rand(0, \\count($parts) - 1);\n\n        return $parts[$randomKey]->accept($this);\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): string\n    {\n        if (!$node->start instanceof Node\\LiteralNode || !$node->end instanceof Node\\LiteralNode) {\n            \/\/ Should be caught by Validator, but good to check\n            return $node->start->accept($this);\n        }\n\n        \/\/ Generate a random character within the ASCII range\n        try {\n            $ord1 = \\ord($node->start->value);\n            $ord2 = \\ord($node->end->value);\n\n            return \\chr(mt_rand($ord1, $ord2));\n        } catch (\\Throwable) {\n            \/\/ Fallback if ord() fails\n            return $node->start->value;\n        }\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): string\n    {\n        $ref = $node->ref;\n\n        \/\/ Check numeric reference first\n        if (ctype_digit($ref)) {\n            $key = (int) $ref;\n            if (isset($this->captures[$key])) {\n                return $this->captures[$key];\n            }\n        }\n\n        \/\/ Check numeric reference with \\\n        if (preg_match('\/^\\\\\\\\(\\d++)$\/', $ref, $matches)) {\n            $key = (int) $matches[1];\n            if (isset($this->captures[$key])) {\n                return $this->captures[$key];\n            }\n        }\n\n        \/\/ Check string\/named reference (e.g. for (?&name) conditionals)\n        if (isset($this->captures[$ref])) {\n            return $this->captures[$ref];\n        }\n\n        \/\/ Handle named \\k<name> or \\k{name} backrefs\n        \/\/ $ref is guaranteed to be a string here.\n        if (preg_match('\/^\\\\\\\\k<(\\w++)>$\/', $ref, $m) || preg_match('\/^\\\\\\\\k\\{(\\w++)\\}$\/', $ref, $m)) {\n            return $this->captures[$m[1]] ?? '';\n        }\n\n        \/\/ Backreference to a group that hasn't matched yet\n        \/\/ (or doesn't exist). In a real engine, this fails the match.\n        \/\/ For generation, we must return empty string.\n        return '';\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): string\n    {\n        if ($node->codePoint < 0 || $node->codePoint > 0x10FFFF) {\n            return '?';\n        }\n\n        try {\n            return mb_chr($node->codePoint, 'UTF-8');\n        } catch (\\Throwable) {\n            return '?';\n        }\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): string\n    {\n        \/\/ Too complex to generate a *random* char for a property.\n        \/\/ Return a known-good sample.\n        if (str_contains($node->prop, 'L')) { \/\/ 'L' (Letter)\n            return $this->getRandomChar(['a', 'b', 'c']);\n        }\n        if (str_contains($node->prop, 'N')) { \/\/ 'N' (Number)\n            return $this->getRandomChar(['1', '2', '3']);\n        }\n        if (str_contains($node->prop, 'P')) { \/\/ 'P' (Punctuation)\n            return $this->getRandomChar(['.', ',', '!']);\n        }\n\n        return $this->getRandomChar(['a', '1', '.']); \/\/ Generic fallback\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): string\n    {\n        return match (strtolower($node->class)) {\n            'alpha' => $this->getRandomChar(['a', 'b', 'C', 'Z']),\n            'alnum' => $this->getRandomChar(['a', 'Z', '1', '9']),\n            'digit' => $this->getRandomChar(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']),\n            'xdigit' => $this->getRandomChar(['0', '9', 'a', 'f', 'A', 'F']),\n            'space' => $this->getRandomChar([' ', \"\\t\", \"\\n\"]),\n            'lower' => $this->getRandomChar(['a', 'b', 'c', 'z']),\n            'upper' => $this->getRandomChar(['A', 'B', 'C', 'Z']),\n            'punct' => $this->getRandomChar(['.', '!', ',', '?']),\n            'word' => $this->getRandomChar(['a', 'Z', '0', '9', '_']),\n            'blank' => $this->getRandomChar([' ', \"\\t\"]),\n            'cntrl' => \"\\x00\", \/\/ Control character\n            'graph', 'print' => $this->getRandomChar(['!', '@', '#']),\n            default => $this->getRandomChar(['a', '1', ' ']),\n        };\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): string\n    {\n        \/\/ Comments do not generate text\n        return '';\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        \/\/ This is complex. Does the condition (e.g., group 1) exist?\n        \/\/ We'll randomly choose to satisfy the condition or not.\n        try {\n            $choice = mt_rand(0, 1);\n        } catch (\\Throwable) {\n            $choice = 0; \/\/ Fallback\n        }\n\n        if (1 === $choice) {\n            \/\/ Simulate \"YES\" path\n            return $node->yes->accept($this);\n        }\n\n        \/\/ Simulate \"NO\" path\n        return $node->no->accept($this);\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): string\n    {\n        if (null === $this->rootPattern || $this->rootPattern instanceof Node\\SubroutineNode) {\n            throw new \\LogicException('Sample generation for subroutines is not supported.');\n        }\n\n        if ($this->recursionDepth >= self::MAX_RECURSION_DEPTH) {\n            return '';\n        }\n\n        $target = $this->resolveSubroutineTarget($node);\n        if (null === $target) {\n            throw new \\LogicException('Sample generation for subroutines is not supported.');\n        }\n\n        $this->recursionDepth++;\n        $result = $target instanceof Node\\GroupNode ? $target->child->accept($this) : $target->accept($this);\n        $this->recursionDepth--;\n\n        return $result;\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): string\n    {\n        \/\/ Verbs do not generate text\n        return '';\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): string\n    {\n        \/\/ DEFINE blocks do not generate text, they only define subpatterns\n        return '';\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): string\n    {\n        return '';\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): string\n    {\n        \/\/ Callouts do not match characters, so they generate no sample text.\n        return '';\n    }\n\n    \/**\n     * Parses a quantifier string into its minimum and maximum repetition counts.\n     *\n     * Purpose: This helper method interprets the various quantifier syntaxes (e.g., `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}`)\n     * and converts them into a standardized `[min, max]` array. It also applies the `maxRepetition`\n     * limit to prevent excessively long samples for unbounded quantifiers.\n     *\n     * @param string $q The quantifier string (e.g., `*`, `+`, `{1,5}`).\n     *\n     * @return array{0: int, 1: int} an array containing the minimum and maximum repetition counts\n     *\/\n    private function parseQuantifierRange(string $q): array\n    {\n        $range = match ($q) {\n            '*' => [0, $this->maxRepetition],\n            '+' => [1, $this->maxRepetition],\n            '?' => [0, 1],\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    [(int) $m[1], (int) $m[1] + $this->maxRepetition] : \/\/ {n,}\n                    [(int) $m[1], (int) $m[2]] \/\/ {n,m}\n                ) :\n                    [(int) $m[1], (int) $m[1]] \/\/ {n}\n                ) :\n                \/\/ @codeCoverageIgnoreStart\n                [0, 0], \/\/ Fallback\n            \/\/ @codeCoverageIgnoreEnd\n        };\n\n        \/\/ Ensure min <= max, as Validator may not have run.\n        \/\/ This handles invalid cases like {5,2} and silences PHPStan\n        if ($range[1] < $range[0]) {\n            $range[1] = $range[0];\n        }\n\n        return $range;\n    }\n\n    \/**\n     * Selects a random character from a given array of characters.\n     *\n     * Purpose: This utility method provides a simple way to pick one character\n     * from a predefined set. It's used by various `visit` methods to generate\n     * a representative character when a specific type or class of character is needed.\n     *\n     * @param array<string> $chars an array of single-character strings to choose from\n     *\n     * @return string a randomly selected character from the input array, or '?' if the array is empty\n     *\/\n    private function getRandomChar(array $chars): string\n    {\n        if (empty($chars)) {\n            return '?'; \/\/ Safe fallback\n        }\n        $key = mt_rand(0, \\count($chars) - 1);\n\n        return $chars[$key];\n    }\n\n    \/**\n     * Generates a sample character for a given character type (e.g., `d`, `s`, `w`).\n     *\n     * Purpose: This helper method centralizes the logic for generating sample characters\n     * for various `\\d`, `\\s`, `\\w`, etc., character types. It provides a specific\n     * random character that fits the definition of the character type.\n     *\n     * @param string $type The character type identifier (e.g., 'd', 'D', 's', 'S').\n     *\n     * @return string a single character matching the specified type, or '?' as a fallback\n     *\/\n    private function generateForCharType(string $type): string\n    {\n        try {\n            return match ($type) {\n                'd' => (string) mt_rand(0, 9),\n                'D' => $this->getRandomChar(['a', ' ', '!']), \/\/ Not a digit\n                's' => $this->getRandomChar([' ', \"\\t\", \"\\n\"]),\n                'S' => $this->getRandomChar(['a', '1', '!']), \/\/ Not whitespace\n                'w' => $this->getRandomChar(['a', 'Z', '5', '_']),\n                'W' => $this->getRandomChar(['!', ' ', '@']), \/\/ Not word\n                'h' => $this->getRandomChar([' ', \"\\t\"]),\n                'H' => $this->getRandomChar(['a', '1', \"\\n\"]), \/\/ Not horiz space\n                'v' => \"\\n\", \/\/ vertical space\n                'V' => $this->getRandomChar(['a', '1', ' ']), \/\/ Not vert space\n                'R' => $this->getRandomChar([\"\\r\\n\", \"\\r\", \"\\n\"]),\n                default => '?',\n            };\n            \/\/ @codeCoverageIgnoreStart\n        } catch (\\Throwable) {\n            return '?'; \/\/ Fallback for mt_rand failure\n        }\n        \/\/ @codeCoverageIgnoreEnd\n    }\n\n    private function collectGroups(Node\\NodeInterface $node): void\n    {\n        if ($node instanceof Node\\GroupNode) {\n            if (\\in_array($node->type, [GroupType::T_GROUP_CAPTURING, GroupType::T_GROUP_NAMED], true)) {\n                $index = $this->groupDefinitionCounter++;\n                $this->groupIndexMap[$index] = $node;\n                $this->groupNumbers[spl_object_id($node)] = $index;\n                if (null !== $node->name) {\n                    $this->namedGroupMap[$node->name] = $node;\n                }\n            }\n\n            $this->collectGroups($node->child);\n\n            return;\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            foreach ($node->children as $child) {\n                $this->collectGroups($child);\n            }\n\n            return;\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            foreach ($node->alternatives as $alt) {\n                $this->collectGroups($alt);\n            }\n\n            return;\n        }\n\n        if ($node instanceof Node\\QuantifierNode) {\n            $this->collectGroups($node->node);\n\n            return;\n        }\n\n        if ($node instanceof Node\\ConditionalNode) {\n            $this->collectGroups($node->condition);\n            $this->collectGroups($node->yes);\n            $this->collectGroups($node->no);\n\n            return;\n        }\n\n        if ($node instanceof Node\\DefineNode) {\n            $this->collectGroups($node->content);\n        }\n    }\n\n    private function resolveSubroutineTarget(Node\\SubroutineNode $node): ?Node\\NodeInterface\n    {\n        $ref = $node->reference;\n\n        if ('R' === $ref || '0' === $ref) {\n            return $this->rootPattern;\n        }\n\n        if (str_starts_with($ref, 'R')) {\n            $ref = substr($ref, 1);\n            if ('' === $ref) {\n                return $this->rootPattern;\n            }\n        }\n\n        if (ctype_digit($ref)) {\n            $index = (int) $ref;\n\n            return $this->groupIndexMap[$index] ?? null;\n        }\n\n        if (str_starts_with($ref, '-') && ctype_digit(substr($ref, 1))) {\n            $resolvedIndex = $this->totalGroupCount + (int) $ref + 1;\n            if ($resolvedIndex >= 1) {\n                return $this->groupIndexMap[$resolvedIndex] ?? null;\n            }\n\n            return null;\n        }\n\n        return $this->namedGroupMap[$ref] ?? null;\n    }\n}\n",
    "NodeVisitor\/ArrayExplorerNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * Transforms the AST into a structured array tree suitable for UI visualization.\n *\n * @extends AbstractNodeVisitor<array<string, mixed>>\n *\/\nfinal class ArrayExplorerNodeVisitor extends AbstractNodeVisitor\n{\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): array\n    {\n        return [\n            'type' => 'Regex',\n            'label' => 'Pattern',\n            'detail' => $node->flags ? \"Flags: {$node->flags}\" : 'Global',\n            'icon' => 'fa-solid fa-globe',\n            'color' => 'text-indigo-600',\n            'bg' => 'bg-indigo-50',\n            'children' => [$node->pattern->accept($this)],\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): array\n    {\n        [$label, $icon, $color, $bg] = match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => ['Capturing Group', 'fa-solid fa-brackets-round', 'text-green-600', 'bg-green-50'],\n            GroupType::T_GROUP_NAMED => [\"Named Group: <span class='font-mono'>{$node->name}<\/span>\", 'fa-solid fa-tag', 'text-emerald-600', 'bg-emerald-50'],\n            GroupType::T_GROUP_NON_CAPTURING => ['Non-Capturing Group', 'fa-solid fa-ban', 'text-slate-500', 'bg-slate-50'],\n            GroupType::T_GROUP_ATOMIC => ['Atomic Group (?>...)', 'fa-solid fa-lock', 'text-red-500', 'bg-red-50'],\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => ['Positive Lookahead (?=...)', 'fa-solid fa-eye', 'text-blue-600', 'bg-blue-50'],\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => ['Negative Lookahead (?!...)', 'fa-solid fa-eye-slash', 'text-red-600', 'bg-red-50'],\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => ['Positive Lookbehind (?<=...)', 'fa-solid fa-chevron-left', 'text-blue-600', 'bg-blue-50'],\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => ['Negative Lookbehind (?<!...)', 'fa-solid fa-chevron-left', 'text-red-600', 'bg-red-50'],\n            default => [ucfirst(str_replace('_', ' ', $node->type->value)), 'fa-solid fa-layer-group', 'text-blue-500', 'bg-blue-50'],\n        };\n\n        return [\n            'type' => 'Group',\n            'label' => $label,\n            'icon' => $icon,\n            'color' => $color,\n            'bg' => $bg,\n            'children' => [$node->child->accept($this)],\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): array\n    {\n        return [\n            'type' => 'Quantifier',\n            'label' => 'Quantifier',\n            'detail' => \"{$node->quantifier} (\".ucfirst($node->type->value).')',\n            'icon' => 'fa-solid fa-rotate-right',\n            'color' => 'text-orange-600',\n            'bg' => 'bg-orange-50',\n            'children' => [$node->node->accept($this)],\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): array\n    {\n        return [\n            'type' => 'Sequence',\n            'label' => 'Sequence',\n            'icon' => 'fa-solid fa-arrow-right-long',\n            'color' => 'text-slate-400',\n            'children' => array_map(fn ($child) => $child->accept($this), $node->children),\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): array\n    {\n        return [\n            'type' => 'Alternation',\n            'label' => 'Alternation (OR)',\n            'icon' => 'fa-solid fa-code-branch',\n            'color' => 'text-purple-600',\n            'bg' => 'bg-purple-50',\n            'children' => array_map(fn ($child) => $child->accept($this), $node->alternatives),\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): array\n    {\n        return [\n            'type' => 'Literal',\n            'label' => 'Literal',\n            'detail' => $this->formatValue($node->value),\n            'icon' => 'fa-solid fa-font',\n            'color' => 'text-slate-700',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): array\n    {\n        $label = $node->isNegated ? 'Negative Character Set [^...]' : 'Character Set [...]';\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n\n        return [\n            'type' => 'CharClass',\n            'label' => $label,\n            'icon' => 'fa-solid fa-border-all',\n            'color' => $node->isNegated ? 'text-red-600' : 'text-teal-600',\n            'bg' => $node->isNegated ? 'bg-red-50' : 'bg-teal-50',\n            'children' => array_map(fn ($child) => $child->accept($this), $parts),\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): array\n    {\n        return [\n            'type' => 'Range',\n            'label' => 'Range',\n            'icon' => 'fa-solid fa-arrows-left-right',\n            'color' => 'text-teal-600',\n            'children' => [\n                $node->start->accept($this),\n                $node->end->accept($this),\n            ],\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): array\n    {\n        $map = [\n            'd' => 'Digit (0-9)', 'D' => 'Not Digit',\n            'w' => 'Word Char', 'W' => 'Not Word Char',\n            's' => 'Whitespace', 'S' => 'Not Whitespace',\n        ];\n\n        return [\n            'type' => 'CharType',\n            'label' => 'Character Type',\n            'detail' => '\\\\'.$node->value.' ('.($map[$node->value] ?? 'Custom').')',\n            'icon' => 'fa-solid fa-filter',\n            'color' => 'text-blue-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): array\n    {\n        return [\n            'type' => 'Dot',\n            'label' => 'Wildcard (Dot)',\n            'detail' => 'Any character',\n            'icon' => 'fa-solid fa-circle',\n            'color' => 'text-pink-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): array\n    {\n        $map = ['^' => 'Start of Line', '$' => 'End of Line', '\\A' => 'Start of String', '\\z' => 'End of String'];\n\n        return [\n            'type' => 'Anchor',\n            'label' => 'Anchor',\n            'detail' => $node->value.' ('.($map[$node->value] ?? 'Custom').')',\n            'icon' => 'fa-solid fa-anchor',\n            'color' => 'text-rose-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): array\n    {\n        return [\n            'type' => 'Assertion',\n            'label' => 'Assertion',\n            'detail' => '\\\\'.$node->value,\n            'icon' => 'fa-solid fa-check-double',\n            'color' => 'text-amber-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): array\n    {\n        return [\n            'type' => 'Backref',\n            'label' => 'Backreference',\n            'detail' => 'To group: '.$node->ref,\n            'icon' => 'fa-solid fa-clock-rotate-left',\n            'color' => 'text-cyan-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): array\n    {\n        return [\n            'type' => 'Unicode',\n            'label' => 'Unicode Character',\n            'detail' => $node->code,\n            'icon' => 'fa-solid fa-language',\n            'color' => 'text-violet-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): array\n    {\n        return [\n            'type' => 'UnicodeProp',\n            'label' => 'Unicode Property',\n            'detail' => '\\p{'.$node->prop.'}',\n            'icon' => 'fa-solid fa-globe-europe',\n            'color' => 'text-violet-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): array\n    {\n        return [\n            'type' => 'PosixClass',\n            'label' => 'POSIX Class',\n            'detail' => '[:'.$node->class.':]',\n            'icon' => 'fa-solid fa-box-archive',\n            'color' => 'text-slate-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): array\n    {\n        return [\n            'type' => 'Comment',\n            'label' => 'Comment',\n            'detail' => $node->comment,\n            'icon' => 'fa-solid fa-comment-slash',\n            'color' => 'text-gray-400',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): array\n    {\n        return [\n            'type' => 'Conditional',\n            'label' => 'Conditional (If-Then-Else)',\n            'icon' => 'fa-solid fa-code-fork',\n            'color' => 'text-fuchsia-600',\n            'bg' => 'bg-fuchsia-50',\n            'children' => [\n                ['label' => 'Condition', 'children' => [$node->condition->accept($this)]],\n                ['label' => 'If True', 'children' => [$node->yes->accept($this)]],\n                ['label' => 'If False', 'children' => [$node->no->accept($this)]],\n            ],\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): array\n    {\n        return [\n            'type' => 'Subroutine',\n            'label' => 'Subroutine',\n            'detail' => 'Call: '.$node->reference,\n            'icon' => 'fa-solid fa-recycle',\n            'color' => 'text-cyan-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): array\n    {\n        return [\n            'type' => 'PcreVerb',\n            'label' => 'Control Verb',\n            'detail' => '(*'.$node->verb.')',\n            'icon' => 'fa-solid fa-gamepad',\n            'color' => 'text-pink-500',\n            'isLeaf' => true,\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): array\n    {\n        return [\n            'type' => 'Define',\n            'label' => '(DEFINE) Block',\n            'icon' => 'fa-solid fa-book',\n            'color' => 'text-slate-500',\n            'children' => [$node->content->accept($this)],\n        ];\n    }\n\n    \/**\n     * @return array<string, mixed>\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): array\n    {\n        return [\n            'type' => 'Keep',\n            'label' => 'Keep (\\K)',\n            'detail' => 'Reset match start',\n            'icon' => 'fa-solid fa-scissors',\n            'color' => 'text-orange-500',\n            'isLeaf' => true,\n        ];\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): array\n    {\n        return [\n            'type' => 'LimitMatch',\n            'label' => 'Match Limit',\n            'detail' => '(*LIMIT_MATCH='.$node->limit.')',\n            'icon' => 'fa-solid fa-gauge-high',\n            'color' => 'text-red-500',\n            'isLeaf' => true,\n        ];\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): array\n    {\n        $detail = match (true) {\n            \\is_int($node->identifier) => '(?C'.$node->identifier.')',\n            $node->isStringIdentifier => '(?C\"'.$node->identifier.'\")',\n            default => '(?C'.$node->identifier.')',\n        };\n\n        return [\n            'type' => 'Callout',\n            'label' => 'Callout',\n            'detail' => $detail,\n            'icon' => 'fa-solid fa-plug',\n            'color' => 'text-amber-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    private function formatValue(string $value): string\n    {\n        $map = [\"\\n\" => '\\n', \"\\r\" => '\\r', \"\\t\" => '\\t'];\n\n        return '\"'.strtr($value, $map).'\"';\n    }\n}\n",
    "NodeVisitor\/ValidatorNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Exception\\SemanticErrorException;\nuse RegexParser\\GroupNumbering;\nuse RegexParser\\GroupNumberingCollector;\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Regex;\n\n\/**\n * High-performance validator for regex Abstract Syntax Trees with intelligent caching and optimization.\n *\n * This optimized validator provides comprehensive semantic validation while minimizing\n * computational overhead through intelligent caching and streamlined validation logic.\n *\n * @extends AbstractNodeVisitor<void>\n *\/\nfinal class ValidatorNodeVisitor extends AbstractNodeVisitor\n{\n    \/\/ Precomputed validation sets for maximum performance\n    private const VALID_ASSERTIONS = [\n        'A' => true, 'z' => true, 'Z' => true,\n        'G' => true, 'b' => true, 'B' => true,\n    ];\n\n    private const VALID_PCRE_VERBS = [\n        'FAIL' => true, 'ACCEPT' => true, 'COMMIT' => true,\n        'PRUNE' => true, 'SKIP' => true, 'THEN' => true,\n        'DEFINE' => true, 'MARK' => true,\n        'UTF8' => true, 'UTF' => true, 'UCP' => true,\n        'CR' => true, 'LF' => true, 'CRLF' => true,\n        'BSR_ANYCRLF' => true, 'BSR_UNICODE' => true,\n        'NO_AUTO_POSSESS' => true,\n        'LIMIT_MATCH' => true, 'LIMIT_RECURSION' => true,\n        'LIMIT_DEPTH' => true, 'LIMIT_HEAP' => true,\n        'LIMIT_LOOKBEHIND' => true,\n        'script_run' => true, 'atomic_script_run' => true,\n    ];\n\n    private const VALID_POSIX_CLASSES = [\n        'alnum' => true, 'alpha' => true, 'ascii' => true,\n        'blank' => true, 'cntrl' => true, 'digit' => true,\n        'graph' => true, 'lower' => true, 'print' => true,\n        'punct' => true, 'space' => true, 'upper' => true,\n        'word' => true, 'xdigit' => true,\n    ];\n\n    \/\/ Optimized state management with minimal memory footprint\n\n    private bool $inLookbehind = false;\n\n    private GroupNumbering $groupNumbering;\n\n    \/**\n     * @var list<int>\n     *\/\n    private array $captureSequence = [];\n\n    private int $captureIndex = 0;\n\n    private int $lookbehindLimit = 0;\n\n    private ?Node\\NodeInterface $previousNode = null;\n\n    private ?Node\\NodeInterface $nextNode = null;\n\n    \/\/ Intelligent caching for expensive validations\n    \/**\n     * @var array<string, bool>\n     *\/\n    private static array $unicodePropCache = [];\n\n    \/**\n     * @var array<string, array{0: int, 1: int}>\n     *\/\n    private static array $quantifierBoundsCache = [];\n\n    public function __construct(private readonly int $maxLookbehindLength = Regex::DEFAULT_MAX_LOOKBEHIND_LENGTH, private readonly ?string $pattern = null) {}\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): void\n    {\n        \/\/ Fast state reset with minimal allocations\n        $this->inLookbehind = false;\n        $this->groupNumbering = (new GroupNumberingCollector())->collect($node);\n        $this->captureSequence = $this->groupNumbering->captureSequence;\n        $this->captureIndex = 0;\n        $this->lookbehindLimit = $this->extractLookbehindLimit($node->pattern) ?? $this->maxLookbehindLength;\n        $this->previousNode = null;\n        $this->nextNode = null;\n\n        $node->pattern->accept($this);\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): void\n    {\n        \/\/ Note: PHP 7.3+ (PCRE2) supports variable-length lookbehinds,\n        \/\/ so we no longer enforce fixed-length or same-length alternation restrictions.\n\n        $previous = $this->previousNode;\n        $next = $this->nextNode;\n\n        foreach ($node->alternatives as $alt) {\n            $this->previousNode = null;\n            $this->nextNode = null;\n            $alt->accept($this);\n        }\n\n        $this->previousNode = $previous;\n        $this->nextNode = $next;\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): void\n    {\n        $previous = $this->previousNode;\n        $next = $this->nextNode;\n        $total = \\count($node->children);\n        $last = null;\n\n        foreach ($node->children as $index => $child) {\n            $this->previousNode = $last;\n            $this->nextNode = $index + 1 < $total ? $node->children[$index + 1] : null;\n            $child->accept($this);\n            $last = $child;\n        }\n\n        $this->previousNode = $previous;\n        $this->nextNode = $next;\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): void\n    {\n        $this->ensureGroupNumberingInitialized();\n\n        $wasInLookbehind = $this->inLookbehind;\n        $previous = $this->previousNode;\n        $next = $this->nextNode;\n\n        if (\\in_array(\n            $node->type,\n            [GroupType::T_GROUP_LOOKBEHIND_POSITIVE, GroupType::T_GROUP_LOOKBEHIND_NEGATIVE],\n            true,\n        )) {\n            $this->inLookbehind = true;\n            $this->validateLookbehindLength($node);\n        }\n\n        if (GroupType::T_GROUP_CAPTURING === $node->type || GroupType::T_GROUP_NAMED === $node->type) {\n            $this->captureIndex++;\n        }\n\n        $this->previousNode = null;\n        $this->nextNode = null;\n        $node->child->accept($this);\n        $this->previousNode = $previous;\n        $this->nextNode = $next;\n\n        $this->inLookbehind = $wasInLookbehind; \/\/ Restore state\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): void\n    {\n        \/\/ Fast cached quantifier bounds parsing\n        [$min, $max] = $this->getQuantifierBounds($node->quantifier);\n\n        \/\/ Early validation with clear error messages\n        if (-1 !== $max && $min > $max) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid quantifier range \"%s\": min > max.', $node->quantifier),\n                $node->startPosition,\n                'regex.quantifier.invalid_range',\n            );\n        }\n\n        $node->node->accept($this);\n    }\n\n    \/**\n     * Validates a `LiteralNode`.\n     *\n     * Purpose: Literal nodes generally do not require semantic validation beyond what\n     * the Lexer and Parser already handle (e.g., valid characters). This method serves\n     * as a placeholder for future, more complex literal-specific validations if needed.\n     *\n     * @param Node\\LiteralNode $node the literal node to validate\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): void\n    {\n        \/\/ No semantic validation needed for literals\n    }\n\n    \/**\n     * Validates a `CharTypeNode`.\n     *\n     * Purpose: Character type nodes (e.g., `\\d`, `\\s`) are typically validated at the\n     * Lexer\/Parser level for syntactic correctness. This method serves as a placeholder\n     * for any future semantic checks specific to character types.\n     *\n     * @param Node\\CharTypeNode $node the character type node to validate\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): void\n    {\n        \/\/ No semantic validation needed for char types\n    }\n\n    \/**\n     * Validates a `DotNode`.\n     *\n     * Purpose: The dot wildcard (`.`) is a fundamental regex element and typically\n     * does not require semantic validation beyond its basic existence. This method\n     * serves as a placeholder.\n     *\n     * @param Node\\DotNode $node the dot node to validate\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): void\n    {\n        \/\/ No semantic validation needed for dot\n    }\n\n    \/**\n     * Validates an `AnchorNode`.\n     *\n     * Purpose: Anchor nodes (e.g., `^`, `$`) define positions and are generally\n     * semantically valid if syntactically correct. This method serves as a placeholder.\n     *\n     * @param Node\\AnchorNode $node the anchor node to validate\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): void\n    {\n        \/\/ No semantic validation needed for anchors\n    }\n\n    \/**\n     * Validates an `AssertionNode`.\n     *\n     * Purpose: This method checks if the assertion (e.g., `\\b`, `\\A`) is a known\n     * and valid PCRE assertion. While the Lexer\/Parser handles basic syntax, this\n     * provides an additional layer of semantic correctness.\n     *\n     * @param Node\\AssertionNode $node the assertion node to validate\n     *\n     * @throws SemanticErrorException if an invalid or unknown assertion is encountered\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): void\n    {\n        \/\/ Fast array lookup with early return\n        if (!isset(self::VALID_ASSERTIONS[$node->value])) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid assertion: \\\\%s.', $node->value),\n                $node->startPosition,\n                'regex.assertion.invalid',\n            );\n        }\n    }\n\n    \/**\n     * Validates a `KeepNode`.\n     *\n     * Purpose: This method enforces the rule that the `\\K` (keep) assertion is not\n     * allowed inside lookbehind groups. This is a PCRE-specific semantic restriction.\n     *\n     * @param Node\\KeepNode $node the keep node to validate\n     *\n     * @throws SemanticErrorException if `\\K` is found within a lookbehind\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): void\n    {\n        if ($this->inLookbehind) {\n            $this->raiseSemanticError(\n                '\\K (keep) is not allowed in lookbehinds.',\n                $node->startPosition,\n                'regex.lookbehind.keep_not_allowed',\n            );\n        }\n    }\n\n    \/**\n     * Validates a `CharClassNode`.\n     *\n     * Purpose: This method recursively validates each part within a character class.\n     * This ensures that all components (literals, ranges, POSIX classes, etc.)\n     * inside the `[...]` are individually valid.\n     *\n     * @param Node\\CharClassNode $node the character class node to validate\n     *\n     * @throws SemanticErrorException if any semantic validation rule is violated within a part of the character class\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): void\n    {\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        foreach ($parts as $part) {\n            $part->accept($this);\n        }\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): void\n    {\n        \/\/ 1. Validation: Ensure start and end nodes represent a single character.\n        \/\/ We allow LiteralNode, but also CharLiteralNode, UnicodeNode, etc.\n        if (!$this->isSingleCharNode($node->start) || !$this->isSingleCharNode($node->end)) {\n            $this->raiseSemanticError(\n                \\sprintf(\n                    'Invalid range: ranges must be between literal characters or single escape sequences. Found %s and %s.',\n                    $node->start::class,\n                    $node->end::class,\n                ),\n                $node->startPosition,\n                'regex.range.invalid_bounds',\n            );\n        }\n\n        \/\/ 2. Validation: Ensure characters are single-byte or single codepoint (for LiteralNodes).\n        if ($node->start instanceof Node\\LiteralNode && \\strlen($node->start->value) > 1) {\n            $this->raiseSemanticError(\n                'Invalid range: start char must be a single character.',\n                $node->startPosition,\n                'regex.range.invalid_start',\n            );\n        }\n        if ($node->end instanceof Node\\LiteralNode && \\strlen($node->end->value) > 1) {\n            $this->raiseSemanticError(\n                'Invalid range: end char must be a single character.',\n                $node->startPosition,\n                'regex.range.invalid_end',\n            );\n        }\n\n        \/\/ 3. Validation: ASCII\/Unicode order check.\n        \/\/ Note: We only strictly compare two LiteralNodes here to avoid complex cross-type decoding logic.\n        if ($node->start instanceof Node\\LiteralNode && $node->end instanceof Node\\LiteralNode) {\n            if (mb_ord($node->start->value) > mb_ord($node->end->value)) {\n                $this->raiseSemanticError(\n                    \\sprintf('Invalid range \"%s-%s\": start character comes after end character.', $node->start->value, $node->end->value),\n                    $node->startPosition,\n                    'regex.range.reversed',\n                );\n            }\n        }\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): void\n    {\n        $this->ensureGroupNumberingInitialized();\n\n        $ref = $node->ref;\n\n        \/\/ Fast path for numeric backreferences\n        if (preg_match('\/^\\\\\\\\(\\d++)$\/', $ref, $matches)) {\n            $num = (int) $matches[1];\n            if (0 === $num) {\n                $this->raiseSemanticError(\n                    'Backreference \\\\0 is not valid.',\n                    $node->startPosition,\n                    'regex.backref.zero',\n                    'Use \\\\g<0> for recursion to the whole pattern, or remove the reference.',\n                );\n            }\n            if ($num > $this->groupNumbering->maxGroupNumber) {\n                $this->raiseSemanticError(\n                    \\sprintf('Backreference to non-existent group: \\\\%d.', $num),\n                    $node->startPosition,\n                    'regex.backref.missing_group',\n                );\n            }\n\n            return;\n        }\n\n        \/\/ Optimized named backreference validation\n        if (preg_match('\/^\\\\\\\\k[<{\\'](?<name>\\w++)[>}\\']$\/', $ref, $matches)) {\n            $name = $matches['name'];\n            if (!$this->groupNumbering->hasNamedGroup($name)) {\n                $this->raiseSemanticError(\n                    \\sprintf('Backreference to non-existent named group: \"%s\".', $name),\n                    $node->startPosition,\n                    'regex.backref.missing_named_group',\n                );\n            }\n\n            return;\n        }\n\n        \/\/ Bare name validation (conditionals)\n        if (preg_match('\/^\\w++$\/', $ref)) {\n            if (!$this->groupNumbering->hasNamedGroup($ref)) {\n                $this->raiseSemanticError(\n                    \\sprintf('Backreference to non-existent named group: \"%s\".', $ref),\n                    $node->startPosition,\n                    'regex.backref.missing_named_group',\n                );\n            }\n\n            return;\n        }\n\n        \/\/ \\g backreference with optimized validation\n        if (preg_match('\/^\\\\\\\\g\\{?(?<num>[0-9+-]++)\\}?$\/', $ref, $matches)) {\n            $numStr = $matches['num'];\n            if ('0' === $numStr || '+0' === $numStr || '-0' === $numStr) {\n                $this->raiseSemanticError(\n                    'Backreference \\\\g{0} is not valid.',\n                    $node->startPosition,\n                    'regex.backref.zero',\n                    'Use \\\\g<0> for recursion to the whole pattern.',\n                );\n            }\n\n            if (str_starts_with($numStr, '+') || str_starts_with($numStr, '-')) {\n                $offset = (int) $numStr;\n                $this->assertRelativeReferenceExists($offset, $node->startPosition, 'regex.backref.relative', 'Backreference');\n\n                return;\n            }\n\n            $num = (int) $numStr;\n            if ($num > $this->groupNumbering->maxGroupNumber) {\n                $this->raiseSemanticError(\n                    \\sprintf('Backreference to non-existent group: \\\\g{%d}.', $num),\n                    $node->startPosition,\n                    'regex.backref.missing_group',\n                );\n            }\n\n            return;\n        }\n\n        $this->raiseSemanticError(\n            \\sprintf('Invalid backreference syntax: \"%s\".', $ref),\n            $node->startPosition,\n            'regex.backref.invalid_syntax',\n        );\n    }\n\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): void\n    {\n        \/\/ The Lexer\/Parser combination already ensures these are\n        \/\/ syntactically valid hex\/octal. We validate the *value*.\n        $code = -1;\n        if (preg_match('\/^\\\\\\\\x([0-9a-fA-F]{2})$\/', $node->code, $m)) {\n            $code = (int) hexdec($m[1]);\n        } elseif (preg_match('\/^\\\\\\\\u\\{([0-9a-fA-F]++)\\}$\/', $node->code, $m)) {\n            $code = (int) hexdec($m[1]);\n        }\n\n        if ($code > 0x10FFFF) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid Unicode codepoint \"%s\" (out of range).', $node->code),\n                $node->startPosition,\n                'regex.unicode.out_of_range',\n            );\n        }\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): void\n    {\n        \/\/ The Lexer\/Parser combination already ensures these are\n        \/\/ syntactically valid. We validate the *value*.\n        match ($node->type) {\n            Node\\CharLiteralType::UNICODE => $this->validateUnicode($node),\n            Node\\CharLiteralType::OCTAL => $this->validateOctal($node),\n            Node\\CharLiteralType::OCTAL_LEGACY => $this->validateOctalLegacy($node),\n            Node\\CharLiteralType::UNICODE_NAMED => $this->validateUnicodeNamed($node),\n        };\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): void\n    {\n        $prop = $node->prop;\n        $key = (\\strlen($prop) > 1 || str_starts_with($prop, '^')) ? \"p{{$prop}}\" : \"p{$prop}\";\n\n        \/\/ Intelligent caching with lazy validation\n        if (!isset(self::$unicodePropCache[$key])) {\n            self::$unicodePropCache[$key] = $this->validateUnicodeProperty($key);\n        }\n\n        if (false === self::$unicodePropCache[$key]) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid or unsupported Unicode property: \\\\%s.', $key),\n                $node->startPosition,\n                'regex.unicode.property_invalid',\n            );\n        }\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): void\n    {\n        $class = strtolower($node->class);\n        $isNegated = str_starts_with($class, '^');\n\n        if ($isNegated) {\n            $class = substr($class, 1);\n        }\n\n        \/\/ Fast validation with clear error messages\n        if (!isset(self::VALID_POSIX_CLASSES[$class])) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid POSIX class: \"%s\".', $node->class),\n                $node->startPosition,\n                'regex.posix.invalid',\n            );\n        }\n\n        if ($isNegated && 'word' === $class) {\n            $this->raiseSemanticError(\n                'Negation of POSIX class \"word\" is not supported.',\n                $node->startPosition,\n                'regex.posix.word_negation',\n            );\n        }\n    }\n\n    \/**\n     * Validates a `CommentNode`.\n     *\n     * Purpose: Comments (`(?#...)`) are ignored by the regex engine and thus do not\n     * require semantic validation. This method serves as a pass-through.\n     *\n     * @param Node\\CommentNode $node the comment node to validate\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): void\n    {\n        \/\/ Comments are ignored in validation\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): void\n    {\n        $this->ensureGroupNumberingInitialized();\n\n        \/\/ Check if the condition is a valid *type* of condition first\n        \/\/ (e.g., a backreference, a subroutine call, or a lookaround)\n        if ($node->condition instanceof Node\\BackrefNode) {\n            \/\/ This is (?(1)...) or (?(<name>)...) or (?(name)...)\n            \/\/ For bare names, check if the group exists before calling accept\n            $ref = $node->condition->ref;\n            if (preg_match('\/^\\w++$\/', $ref) && !$this->groupNumbering->hasNamedGroup($ref)) {\n                \/\/ Bare name that doesn't exist - this is an invalid conditional\n                $this->raiseSemanticError(\n                    'Invalid conditional construct. Condition must be a group reference, lookaround, or (DEFINE).',\n                    $node->condition->getStartPosition(),\n                    'regex.conditional.invalid',\n                );\n            }\n            \/\/ Now validate the backreference itself\n            $node->condition->accept($this);\n        } elseif ($node->condition instanceof Node\\SubroutineNode) {\n            $ref = $node->condition->reference;\n            if ('R' === $ref || '0' === $ref) {\n                \/\/ Always valid recursion condition to entire pattern.\n            } elseif (preg_match('\/^R-?\\d++$\/', $ref)) {\n                $num = (int) substr($ref, 1);\n                $this->assertSubroutineReferenceExists($num, $node->condition->startPosition, 'regex.subroutine.recursion', 'Recursion condition');\n            } else {\n                $node->condition->accept($this);\n            }\n        } elseif ($node->condition instanceof Node\\GroupNode && \\in_array($node->condition->type, [\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n        ], true)) {\n            \/\/ This is (?(?=...)...) etc. This is valid.\n            $node->condition->accept($this);\n        } elseif ($node->condition instanceof Node\\AssertionNode && 'DEFINE' === $node->condition->value) {\n            \/\/ (?(DEFINE)...) This is valid.\n            $node->condition->accept($this);\n        } else {\n            \/\/ Any other atom is not a valid condition\n            $this->raiseSemanticError(\n                'Invalid conditional construct. Condition must be a group reference, lookaround, or (DEFINE).',\n                $node->condition->getStartPosition(),\n                'regex.conditional.invalid',\n            );\n        }\n\n        $node->yes->accept($this);\n        $node->no->accept($this);\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): void\n    {\n        $this->ensureGroupNumberingInitialized();\n\n        $ref = $node->reference;\n\n        if ('R' === $ref || '0' === $ref) {\n            return; \/\/ (?R) or (?0) is always valid.\n        }\n\n        if (str_starts_with($ref, 'R')) {\n            $numPart = substr($ref, 1);\n            if ('' === $numPart) {\n                return;\n            }\n\n            if (ctype_digit($numPart)) {\n                $num = (int) $numPart;\n                $this->assertAbsoluteReferenceExists($num, $node->startPosition, 'regex.subroutine.recursion', 'Recursion condition');\n\n                return;\n            }\n\n            if (str_starts_with($numPart, '-') && ctype_digit(substr($numPart, 1))) {\n                $num = (int) $numPart;\n                $this->assertRelativeReferenceExists($num, $node->startPosition, 'regex.subroutine.recursion', 'Recursion condition');\n\n                return;\n            }\n        }\n\n        \/\/ Numeric reference: (?1), (?-1)\n        if (ctype_digit($ref) || (str_starts_with($ref, '-') && ctype_digit(substr($ref, 1)))) {\n            $num = (int) $ref;\n            if (0 === $num) {\n                return; \/\/ (?0) is an alias for (?R)\n            }\n            if ($num > 0) {\n                $this->assertAbsoluteReferenceExists($num, $node->startPosition, 'regex.subroutine.missing_group', 'Subroutine call');\n            } else {\n                $this->assertRelativeReferenceExists($num, $node->startPosition, 'regex.subroutine.relative_missing', 'Subroutine call');\n            }\n\n            return;\n        }\n\n        \/\/ Named reference: (?&name), (?P>name), \\g<name>\n        if (!$this->groupNumbering->hasNamedGroup($ref)) {\n            $this->raiseSemanticError(\n                \\sprintf('Subroutine call to non-existent named group: \"%s\".', $ref),\n                $node->startPosition,\n                'regex.subroutine.missing_named_group',\n            );\n        }\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): void\n    {\n        $verbName = preg_split('\/[:=]\/', $node->verb, 2)[0] ?? $node->verb;\n        if ('LIMIT_LOOKBEHIND' === $verbName && preg_match('\/^LIMIT_LOOKBEHIND=(\\d++)$\/', $node->verb, $matches)) {\n            $this->lookbehindLimit = (int) $matches[1];\n        }\n\n        if (!isset(self::VALID_PCRE_VERBS[$verbName])) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid or unsupported PCRE verb: \"%s\".', $verbName),\n                $node->startPosition,\n                'regex.verb.invalid',\n            );\n        }\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): void\n    {\n        $node->content->accept($this);\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): void\n    {\n        \/\/ No specific validation needed for this node.\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): void\n    {\n        $position = $node->startPosition + 4;\n\n        if (\\is_int($node->identifier)) {\n            if ($node->identifier < 0 || $node->identifier > 255) {\n                $this->raiseSemanticError(\n                    \\sprintf('Callout identifier must be between 0 and 255, got %d.', $node->identifier),\n                    $position,\n                    'regex.callout.out_of_range',\n                );\n            }\n        } elseif (\\is_string($node->identifier)) {\n            \/\/ PCRE2 allows any string as an argument, but it's good to ensure it's not empty.\n            if ('' === $node->identifier) {\n                $this->raiseSemanticError(\n                    'Callout string identifier cannot be empty.',\n                    $position,\n                    'regex.callout.empty_identifier',\n                );\n            }\n        } else {\n            \/\/ This case should ideally be caught by the Lexer\/Parser, but as a safeguard.\n            $this->raiseSemanticError(\n                'Invalid callout identifier type.',\n                $position,\n                'regex.callout.invalid_type',\n            );\n        }\n    }\n\n    private function validateUnicode(Node\\CharLiteralNode $node): void\n    {\n        \/\/ Parse codePoint from the escape string\n        $rep = $node->originalRepresentation;\n        if (preg_match('\/^\\\\\\\\x([0-9a-fA-F]{1,2})$\/', $rep, $m)) {\n            $codePoint = (int) hexdec($m[1]);\n        } elseif (preg_match('\/^\\\\\\\\(x|u)\\\\{([0-9a-fA-F]+)\\\\}$\/', $rep, $m)) {\n            $codePoint = (int) hexdec($m[2]);\n        } else {\n            return; \/\/ Invalid format, skip\n        }\n\n        if ($codePoint > 0x10FFFF) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid Unicode codepoint \"%s\" (out of range).', $node->originalRepresentation),\n                $node->startPosition,\n                'regex.unicode.out_of_range',\n            );\n        }\n    }\n\n    private function validateOctal(Node\\CharLiteralNode $node): void\n    {\n        \/\/ PCRE limits \\o{} to single-byte values (0-255)\n        if ($node->codePoint > 0xFF) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid octal codepoint \"%s\".', $node->originalRepresentation),\n                $node->startPosition,\n                'regex.octal.out_of_range',\n            );\n        }\n    }\n\n    private function validateOctalLegacy(Node\\CharLiteralNode $node): void\n    {\n        \/\/ Legacy octal is limited to 0-255 in practice (including \\0 for null byte)\n        if ($node->codePoint > 0xFF) {\n            $this->raiseSemanticError(\n                \\sprintf('Invalid legacy octal codepoint \"%s\" (out of range).', $node->originalRepresentation),\n                $node->startPosition,\n                'regex.octal.out_of_range',\n            );\n        }\n    }\n\n    private function validateUnicodeNamed(Node\\CharLiteralNode $node): void\n    {\n        \/\/ TODO: Validate that the Unicode name is valid. For now, assume it's correct.\n    }\n\n    \/**\n     * Optimized Unicode property validation with error suppression.\n     *\/\n    private function validateUnicodeProperty(string $key): bool\n    {\n        \/\/ Use error suppression as preg_match warns on invalid properties\n        $result = @preg_match(\"\/^\\\\{$key}$\/u\", '');\n        $error = preg_last_error();\n\n        \/\/ PREG_NO_ERROR means it compiled successfully\n        return false !== $result && \\PREG_NO_ERROR === $error;\n    }\n\n    \/**\n     * Helper to check if a node represents a valid single character for a range.\n     *\n     * Purpose: This private helper method is used by `visitRange` to determine if a\n     * given node can serve as a valid start or end point for a character range.\n     * It ensures that only single-character representations are used for ranges.\n     *\n     * @param Node\\NodeInterface $node the node to check\n     *\n     * @return bool true if the node represents a single character, false otherwise\n     *\/\n    private function isSingleCharNode(Node\\NodeInterface $node): bool\n    {\n        return $node instanceof Node\\LiteralNode\n            || $node instanceof Node\\CharLiteralNode\n            || $node instanceof Node\\UnicodeNode;\n        \/\/ CharTypeNode (e.g., \\d) is technically invalid in a standard PCRE range start\/end,\n        \/\/ but we exclude it here to remain spec-compliant unless lenient mode is desired.\n    }\n\n    \/**\n     * High-performance cached quantifier bounds parsing.\n     *\n     * @return array{0: int, 1: int}\n     *\/\n    private function getQuantifierBounds(string $q): array\n    {\n        \/\/ Return cached result if available\n        if (isset(self::$quantifierBoundsCache[$q])) {\n            return self::$quantifierBoundsCache[$q];\n        }\n\n        \/\/ Compute and cache the result\n        $bounds = $this->parseQuantifierBounds($q);\n        self::$quantifierBoundsCache[$q] = $bounds;\n\n        return $bounds;\n    }\n\n    \/**\n     * Parses a quantifier string (e.g., \"{2,5}\") into min\/max bounds.\n     *\n     * Purpose: This private helper method extracts the minimum and maximum repetition\n     * counts from a quantifier string. It's used by `visitQuantifier` to validate\n     * the range and identify unbounded quantifiers for ReDoS detection.\n     *\n     * @param string $q The quantifier string (e.g., \"*\", \"+\", \"?\", \"{n,m}\").\n     *\n     * @return array{0: int, 1: int} a tuple containing `[min, max]`, where `max = -1` means unbounded\n     *\/\n    private function parseQuantifierBounds(string $q): array\n    {\n        return match ($q) {\n            '*' => [0, -1],\n            '+' => [1, -1],\n            '?' => [0, 1],\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $q, $m) ?\n                (isset($m[2]) ?\n                    ('' === $m[2] ? [(int) $m[1], -1] : [(int) $m[1], (int) $m[2]]) : \/\/ {n,} or {n,m}\n                    [(int) $m[1], (int) $m[1]] \/\/ {n}\n                ) :\n                [1, 1], \/\/ Should be impossible if Lexer is correct\n        };\n    }\n\n    \/**\n     * Calculates the fixed length of a node.\n     *\n     * Purpose: This private helper method attempts to determine the fixed length\n     * (in characters) that a given node will match. This is particularly useful\n     * for validating lookbehinds, which traditionally require fixed-length patterns.\n     * If a node can match a variable number of characters, it returns `null`.\n     *\n     * @param Node\\NodeInterface $node the node for which to calculate the length\n     *\n     * @return int|null the fixed length of the node, or `null` if its length is variable\n     *\/\n    private function calculateFixedLength(Node\\NodeInterface $node): ?int\n    {\n        return match (true) {\n            $node instanceof Node\\LiteralNode => mb_strlen($node->value),\n            $node instanceof Node\\CharTypeNode, $node instanceof Node\\DotNode => 1,\n            $node instanceof Node\\AnchorNode, $node instanceof Node\\AssertionNode => 0,\n            $node instanceof Node\\SequenceNode => $this->calculateSequenceLength($node),\n            $node instanceof Node\\GroupNode => $this->calculateFixedLength($node->child),\n            $node instanceof Node\\QuantifierNode => $this->calculateQuantifierLength($node),\n            $node instanceof Node\\CharClassNode => 1,\n            $node instanceof Node\\AlternationNode => null, \/\/ Handled separately\n            default => null, \/\/ Unknown or variable\n        };\n    }\n\n    \/**\n     * Calculates the fixed length of a sequence node.\n     *\n     * Purpose: This private helper method is used by `calculateFixedLength` to\n     * sum the fixed lengths of all children within a `SequenceNode`. If any child\n     * has a variable length, the entire sequence is considered variable length.\n     *\n     * @param Node\\SequenceNode $node the sequence node for which to calculate the length\n     *\n     * @return int|null the fixed length of the sequence, or `null` if its length is variable\n     *\/\n    private function calculateSequenceLength(Node\\SequenceNode $node): ?int\n    {\n        $total = 0;\n        foreach ($node->children as $child) {\n            $length = $this->calculateFixedLength($child);\n            if (null === $length) {\n                return null; \/\/ Variable length\n            }\n            $total += $length;\n        }\n\n        return $total;\n    }\n\n    \/**\n     * Calculates the fixed length of a quantifier node.\n     *\n     * Purpose: This private helper method is used by `calculateFixedLength` to\n     * determine the length of a quantified node. A quantified node only has a\n     * fixed length if its quantifier specifies an exact number of repetitions\n     * (e.g., `{3}`) and its child also has a fixed length.\n     *\n     * @param Node\\QuantifierNode $node the quantifier node for which to calculate the length\n     *\n     * @return int|null the fixed length of the quantified node, or `null` if its length is variable\n     *\/\n    private function calculateQuantifierLength(Node\\QuantifierNode $node): ?int\n    {\n        [$min, $max] = $this->parseQuantifierBounds($node->quantifier);\n\n        \/\/ Only fixed if min == max (and both are not -1)\n        if ($min !== $max || -1 === $max) {\n            return null; \/\/ Variable length\n        }\n\n        $childLength = $this->calculateFixedLength($node->node);\n        if (null === $childLength) {\n            return null;\n        }\n\n        return $min * $childLength;\n    }\n\n    private function extractLookbehindLimit(Node\\NodeInterface $node): ?int\n    {\n        if ($node instanceof Node\\PcreVerbNode && preg_match('\/^LIMIT_LOOKBEHIND=(\\d++)$\/', $node->verb, $matches)) {\n            return (int) $matches[1];\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->extractLookbehindLimit($node->child);\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            foreach ($node->alternatives as $alt) {\n                $limit = $this->extractLookbehindLimit($alt);\n                if (null !== $limit) {\n                    return $limit;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            foreach ($node->children as $child) {\n                $limit = $this->extractLookbehindLimit($child);\n                if (null !== $limit) {\n                    return $limit;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\QuantifierNode) {\n            return $this->extractLookbehindLimit($node->node);\n        }\n\n        if ($node instanceof Node\\ConditionalNode) {\n            return $this->extractLookbehindLimit($node->condition)\n                ?? $this->extractLookbehindLimit($node->yes)\n                ?? $this->extractLookbehindLimit($node->no);\n        }\n\n        if ($node instanceof Node\\DefineNode) {\n            return $this->extractLookbehindLimit($node->content);\n        }\n\n        if ($node instanceof Node\\CharClassNode) {\n            return $this->extractLookbehindLimit($node->expression);\n        }\n\n        if ($node instanceof Node\\ClassOperationNode) {\n            return $this->extractLookbehindLimit($node->left) ?? $this->extractLookbehindLimit($node->right);\n        }\n\n        if ($node instanceof Node\\RangeNode) {\n            return $this->extractLookbehindLimit($node->start) ?? $this->extractLookbehindLimit($node->end);\n        }\n\n        return null;\n    }\n\n    private function validateLookbehindLength(Node\\GroupNode $node): void\n    {\n        $lengthRange = $node->child->accept(new LengthRangeNodeVisitor());\n        [$min, $max] = $lengthRange;\n\n        if (null === $max) {\n            $culprit = $this->findUnboundedLookbehindNode($node->child);\n            $position = $culprit?->getStartPosition() ?? $node->startPosition;\n            $detail = $culprit instanceof Node\\QuantifierNode ? $culprit->quantifier : null;\n            $hint = null !== $detail\n                ? \\sprintf('Use a bounded quantifier instead of \"%s\".', $detail)\n                : 'Ensure the lookbehind has a bounded maximum length.';\n\n            $this->raiseSemanticError(\n                'Lookbehind is unbounded. PCRE requires a bounded maximum length.',\n                $position,\n                'regex.lookbehind.unbounded',\n                $hint,\n            );\n        }\n\n        if ($max > $this->lookbehindLimit) {\n            $this->raiseSemanticError(\n                \\sprintf('Lookbehind exceeds the maximum length of %d (max=%d).', $this->lookbehindLimit, $max),\n                $node->startPosition,\n                'regex.lookbehind.too_long',\n                \\sprintf('Reduce lookbehind length or use (*LIMIT_LOOKBEHIND=%d).', $max),\n            );\n        }\n    }\n\n    private function findUnboundedLookbehindNode(Node\\NodeInterface $node): ?Node\\NodeInterface\n    {\n        if ($node instanceof Node\\BackrefNode || $node instanceof Node\\SubroutineNode) {\n            return $node;\n        }\n\n        if ($node instanceof Node\\QuantifierNode) {\n            [, $max] = $this->getQuantifierBounds($node->quantifier);\n            if (-1 === $max) {\n                return $node;\n            }\n\n            return $this->findUnboundedLookbehindNode($node->node);\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->findUnboundedLookbehindNode($node->child);\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            foreach ($node->alternatives as $alt) {\n                $culprit = $this->findUnboundedLookbehindNode($alt);\n                if (null !== $culprit) {\n                    return $culprit;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            foreach ($node->children as $child) {\n                $culprit = $this->findUnboundedLookbehindNode($child);\n                if (null !== $culprit) {\n                    return $culprit;\n                }\n            }\n        }\n\n        if ($node instanceof Node\\ConditionalNode) {\n            return $this->findUnboundedLookbehindNode($node->condition)\n                ?? $this->findUnboundedLookbehindNode($node->yes)\n                ?? $this->findUnboundedLookbehindNode($node->no);\n        }\n\n        if ($node instanceof Node\\DefineNode) {\n            return $this->findUnboundedLookbehindNode($node->content);\n        }\n\n        if ($node instanceof Node\\CharClassNode) {\n            return $this->findUnboundedLookbehindNode($node->expression);\n        }\n\n        if ($node instanceof Node\\ClassOperationNode) {\n            return $this->findUnboundedLookbehindNode($node->left) ?? $this->findUnboundedLookbehindNode($node->right);\n        }\n\n        if ($node instanceof Node\\RangeNode) {\n            return $this->findUnboundedLookbehindNode($node->start) ?? $this->findUnboundedLookbehindNode($node->end);\n        }\n\n        return null;\n    }\n\n    private function assertAbsoluteReferenceExists(int $num, int $position, string $code, string $context): void\n    {\n        if ($num <= 0 || $num > $this->groupNumbering->maxGroupNumber) {\n            $this->raiseSemanticError(\n                \\sprintf('%s to non-existent group: %d.', $context, $num),\n                $position,\n                $code,\n            );\n        }\n    }\n\n    private function assertRelativeReferenceExists(int $offset, int $position, string $code, string $context): void\n    {\n        if (0 === $offset) {\n            $this->raiseSemanticError(\n                \\sprintf('%s relative reference cannot be zero.', $context),\n                $position,\n                $code,\n            );\n        }\n\n        $index = $offset > 0 ? $this->captureIndex + $offset - 1 : $this->captureIndex + $offset;\n        if ($index < 0 || $index >= \\count($this->captureSequence)) {\n            $this->raiseSemanticError(\n                \\sprintf('%s relative reference %d is outside the range of available capture groups.', $context, $offset),\n                $position,\n                $code,\n                'Check group numbering or remove the relative reference.',\n            );\n        }\n    }\n\n    private function assertSubroutineReferenceExists(int $num, int $position, string $code, string $context): void\n    {\n        if ($num > 0) {\n            $this->assertAbsoluteReferenceExists($num, $position, $code, $context);\n\n            return;\n        }\n\n        $this->assertRelativeReferenceExists($num, $position, $code, $context);\n    }\n\n    private function raiseSemanticError(string $message, int $position, string $code, ?string $hint = null): never\n    {\n        throw new SemanticErrorException(\n            $message,\n            $position,\n            $this->pattern,\n            null,\n            $code,\n            $hint,\n        );\n    }\n\n    private function ensureGroupNumberingInitialized(): void\n    {\n        if (!isset($this->groupNumbering)) {\n            $this->groupNumbering = new GroupNumbering(0, [], []);\n            $this->captureSequence = [];\n            $this->captureIndex = 0;\n            $this->lookbehindLimit = $this->maxLookbehindLength;\n        }\n    }\n}\n",
    "NodeVisitor\/AbstractNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Base visitor that returns a default value for every node.\n *\n * @template TReturn\n *\n * @implements NodeVisitorInterface<TReturn>\n *\/\nabstract class AbstractNodeVisitor implements NodeVisitorInterface\n{\n    public function visitRegex(Node\\RegexNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitAlternation(Node\\AlternationNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitSequence(Node\\SequenceNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitGroup(Node\\GroupNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitQuantifier(Node\\QuantifierNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitLiteral(Node\\LiteralNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitCharLiteral(Node\\CharLiteralNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitCharType(Node\\CharTypeNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitUnicode(Node\\UnicodeNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitDot(Node\\DotNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitAnchor(Node\\AnchorNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitAssertion(Node\\AssertionNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitKeep(Node\\KeepNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitCharClass(Node\\CharClassNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitRange(Node\\RangeNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitBackref(Node\\BackrefNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitClassOperation(Node\\ClassOperationNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitControlChar(Node\\ControlCharNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitScriptRun(Node\\ScriptRunNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitVersionCondition(Node\\VersionConditionNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitUnicodeProp(Node\\UnicodePropNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitPosixClass(Node\\PosixClassNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitComment(Node\\CommentNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitConditional(Node\\ConditionalNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitSubroutine(Node\\SubroutineNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitPcreVerb(Node\\PcreVerbNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitDefine(Node\\DefineNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitLimitMatch(Node\\LimitMatchNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    public function visitCallout(Node\\CalloutNode $node)\n    {\n        return $this->defaultReturn();\n    }\n\n    \/**\n     * @return TReturn\n     *\/\n    protected function defaultReturn()\n    {\n        \/** @var TReturn $result *\/\n        $result = null;\n\n        return $result;\n    }\n}\n",
    "NodeVisitor\/MetricsNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Collects structural metrics about an AST (node counts and depth).\n *\n * @extends AbstractNodeVisitor<array{counts: array<string, int>, total: int, maxDepth: int}>\n *\/\nfinal class MetricsNodeVisitor extends AbstractNodeVisitor\n{\n    \/**\n     * @var array<string, int>\n     *\/\n    private array $counts = [];\n\n    private int $total = 0;\n\n    private int $maxDepth = 0;\n\n    private int $currentDepth = 0;\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChild($node->pattern);\n        });\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChildren($node->alternatives);\n        });\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChildren($node->children);\n        });\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChild($node->child);\n        });\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChild($node->node);\n        });\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n            $this->visitChildren($parts);\n        });\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChild($node->start);\n            $this->visitChild($node->end);\n        });\n    }\n\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChild($node->condition);\n            $this->visitChild($node->yes);\n            $this->visitChild($node->no);\n        });\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): array\n    {\n        return $this->record($node, function () use ($node): void {\n            $this->visitChild($node->content);\n        });\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): array\n    {\n        return $this->record($node);\n    }\n\n    \/**\n     * @return array{counts: array<string, int>, total: int, maxDepth: int}\n     *\/\n    private function record(Node\\NodeInterface $node, ?callable $traverse = null): array\n    {\n        $this->total++;\n        $type = $this->shortName($node::class);\n        $this->counts[$type] = ($this->counts[$type] ?? 0) + 1;\n\n        $this->currentDepth++;\n        $this->maxDepth = max($this->maxDepth, $this->currentDepth);\n\n        if (null !== $traverse) {\n            $traverse();\n        }\n\n        $this->currentDepth--;\n\n        return $this->snapshot();\n    }\n\n    private function visitChild(Node\\NodeInterface $child): void\n    {\n        $child->accept($this);\n    }\n\n    \/**\n     * @param array<Node\\NodeInterface> $children\n     *\/\n    private function visitChildren(array $children): void\n    {\n        foreach ($children as $child) {\n            $this->visitChild($child);\n        }\n    }\n\n    private function shortName(string $class): string\n    {\n        $pos = strrpos($class, '\\\\');\n\n        return false === $pos ? $class : substr($class, $pos + 1);\n    }\n\n    \/**\n     * @return array{counts: array<string, int>, total: int, maxDepth: int}\n     *\/\n    private function snapshot(): array\n    {\n        return [\n            'counts' => $this->counts,\n            'total' => $this->total,\n            'maxDepth' => $this->maxDepth,\n        ];\n    }\n}\n",
    "NodeVisitor\/LengthRangeNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * A visitor that calculates the minimum and maximum possible lengths of strings that match the AST.\n *\n * Purpose: This visitor traverses the Abstract Syntax Tree (AST) of a regular expression\n * and computes the range of string lengths that could potentially match the pattern.\n * This is invaluable for input validation, performance optimization, and understanding\n * the constraints of a regex pattern.\n *\n * @extends AbstractNodeVisitor<array{0: int, 1: int|null}>\n *\/\nfinal class LengthRangeNodeVisitor extends AbstractNodeVisitor\n{\n    \/**\n     * Visits a RegexNode and returns the length range of its pattern.\n     *\n     * @param Node\\RegexNode $node the `RegexNode` representing the entire regular expression\n     *\n     * @return array{0: int, 1: int|null} the minimum and maximum lengths (null for infinite)\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): array\n    {\n        return $node->pattern->accept($this);\n    }\n\n    \/**\n     * Visits an AlternationNode and returns the combined length range of its alternatives.\n     *\n     * @param Node\\AlternationNode $node the `AlternationNode` representing a choice between patterns\n     *\n     * @return array{0: int, 1: int|null} the minimum and maximum lengths across all alternatives\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): array\n    {\n        $min = \\PHP_INT_MAX;\n        $max = 0;\n        $hasInfinite = false;\n\n        foreach ($node->alternatives as $alt) {\n            [$altMin, $altMax] = $alt->accept($this);\n            $min = min($min, $altMin);\n            if (null === $altMax) {\n                $hasInfinite = true;\n            } else {\n                $max = max($max, $altMax);\n            }\n        }\n\n        return [$min, $hasInfinite ? null : $max];\n    }\n\n    \/**\n     * Visits a SequenceNode and returns the sum of length ranges of its children.\n     *\n     * @param Node\\SequenceNode $node the `SequenceNode` representing a series of regex components\n     *\n     * @return array{0: int, 1: int|null} the total minimum and maximum lengths\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): array\n    {\n        $totalMin = 0;\n        $totalMax = 0;\n        $hasInfinite = false;\n\n        foreach ($node->children as $child) {\n            [$childMin, $childMax] = $child->accept($this);\n            $totalMin += $childMin;\n            if (null === $childMax) {\n                $hasInfinite = true;\n            } else {\n                $totalMax += $childMax;\n            }\n        }\n\n        return [$totalMin, $hasInfinite ? null : $totalMax];\n    }\n\n    \/**\n     * Visits a GroupNode and returns the length range of its child.\n     *\n     * @param Node\\GroupNode $node the `GroupNode` representing a grouping construct\n     *\n     * @return array{0: int, 1: int|null} the length range of the grouped content\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): array\n    {\n        \/\/ Lookarounds are zero-width assertions\n        if (\\in_array($node->type, [\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n        ], true)) {\n            return [0, 0];\n        }\n\n        return $node->child->accept($this);\n    }\n\n    \/**\n     * Visits a QuantifierNode and calculates the length range based on repetition.\n     *\n     * @param Node\\QuantifierNode $node the `QuantifierNode` representing a repetition operator\n     *\n     * @return array{0: int, 1: int|null} the minimum and maximum lengths for the quantified element\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): array\n    {\n        [$childMin, $childMax] = $node->node->accept($this);\n\n        \/\/ Parse quantifier\n        $range = $this->parseQuantifierRange($node->quantifier);\n        $qMin = $range[0];\n        $qMax = $range[1];\n\n        $min = $childMin * $qMin;\n        $max = null;\n        if (null !== $childMax && null !== $qMax) {\n            $max = $childMax * $qMax;\n        }\n\n        return [$min, $max];\n    }\n\n    \/**\n     * Visits a LiteralNode and returns [1, 1].\n     *\n     * @param Node\\LiteralNode $node the `LiteralNode` representing a literal character\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a CharTypeNode and returns [1, 1].\n     *\n     * @param Node\\CharTypeNode $node the `CharTypeNode` representing a character type\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a DotNode and returns [1, 1].\n     *\n     * @param Node\\DotNode $node the `DotNode` representing the wildcard dot\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits an AnchorNode and returns [0, 0].\n     *\n     * @param Node\\AnchorNode $node the `AnchorNode` representing a positional anchor\n     *\n     * @return array{0: int, 1: int|null} always [0, 0]\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): array\n    {\n        return [0, 0];\n    }\n\n    \/**\n     * Visits an AssertionNode and returns [0, 0].\n     *\n     * @param Node\\AssertionNode $node the `AssertionNode` representing a zero-width assertion\n     *\n     * @return array{0: int, 1: int|null} always [0, 0]\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): array\n    {\n        return [0, 0];\n    }\n\n    \/**\n     * Visits a CharClassNode and returns [1, 1].\n     *\n     * @param Node\\CharClassNode $node the `CharClassNode` representing a character class\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a RangeNode and returns [1, 1].\n     *\n     * @param Node\\RangeNode $node the `RangeNode` representing a character range\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a BackrefNode and returns [0, null] (can be any length).\n     *\n     * @param Node\\BackrefNode $node the `BackrefNode` representing a backreference\n     *\n     * @return array{0: int, 1: int|null} [0, null]\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): array\n    {\n        return [0, null]; \/\/ Backrefs can match variable lengths\n    }\n\n    \/**\n     * Visits a UnicodeNode and returns [1, 1].\n     *\n     * @param Node\\UnicodeNode $node the `UnicodeNode` representing a Unicode escape\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a UnicodePropNode and returns [1, 1].\n     *\n     * @param Node\\UnicodePropNode $node the `UnicodePropNode` representing a Unicode property\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a PosixClassNode and returns [1, 1].\n     *\n     * @param Node\\PosixClassNode $node the `PosixClassNode` representing a POSIX character class\n     *\n     * @return array{0: int, 1: int|null} always [1, 1]\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): array\n    {\n        return [1, 1];\n    }\n\n    \/**\n     * Visits a CommentNode and returns [0, 0].\n     *\n     * @param Node\\CommentNode $node the `CommentNode` representing an inline comment\n     *\n     * @return array{0: int, 1: int|null} always [0, 0]\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): array\n    {\n        return [0, 0];\n    }\n\n    \/**\n     * Visits a ConditionalNode and returns the length range of the chosen branch.\n     *\n     * @param Node\\ConditionalNode $node the `ConditionalNode` representing a conditional sub-pattern\n     *\n     * @return array{0: int, 1: int|null} the length range of the conditional\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): array\n    {\n        \/\/ For simplicity, take the max of yes and no\n        [$yesMin, $yesMax] = $node->yes->accept($this);\n        [$noMin, $noMax] = $node->no->accept($this);\n\n        $min = min($yesMin, $noMin);\n        $max = null;\n        if (null !== $yesMax && null !== $noMax) {\n            $max = max($yesMax, $noMax);\n        }\n\n        return [$min, $max];\n    }\n\n    \/**\n     * Visits a SubroutineNode and returns [0, null] (complex recursion).\n     *\n     * @param Node\\SubroutineNode $node the `SubroutineNode` representing a subroutine call\n     *\n     * @return array{0: int, 1: int|null} [0, null]\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): array\n    {\n        return [0, null]; \/\/ Subroutines can be complex\n    }\n\n    \/**\n     * Visits a PcreVerbNode and returns [0, 0].\n     *\n     * @param Node\\PcreVerbNode $node the `PcreVerbNode` representing a PCRE verb\n     *\n     * @return array{0: int, 1: int|null} always [0, 0]\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): array\n    {\n        return [0, 0];\n    }\n\n    \/**\n     * Visits a DefineNode and returns [0, 0].\n     *\n     * @param Node\\DefineNode $node the `DefineNode` representing a define block\n     *\n     * @return array{0: int, 1: int|null} always [0, 0]\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): array\n    {\n        return [0, 0];\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): array\n    {\n        return [0, 0];\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): array\n    {\n        return [0, 0];\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): array\n    {\n        return [0, 0];\n    }\n\n    \/**\n     * Parses a quantifier string into min and max.\n     *\n     * @param string $q the quantifier\n     *\n     * @return array{0: int, 1: int|null} min and max\n     *\/\n    private function parseQuantifierRange(string $q): array\n    {\n        return match ($q) {\n            '*' => [0, null],\n            '+' => [1, null],\n            '?' => [0, 1],\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    [(int) $m[1], null] :\n                    [(int) $m[1], (int) $m[2]]\n                ) :\n                    [(int) $m[1], (int) $m[1]]\n                ) :\n                [1, 1], \/\/ fallback\n        };\n    }\n}\n",
    "NodeVisitor\/TestCaseGeneratorNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * A visitor that generates test cases (matching and non-matching strings) for a regex pattern.\n *\n * Purpose: This visitor traverses the Abstract Syntax Tree (AST) of a regular expression\n * and generates sample strings that should match the pattern, as well as strings that should not.\n * This is invaluable for testing regex implementations, validating patterns, and ensuring\n * correctness in applications like Laravel or Symfony form validations.\n *\n * @extends AbstractNodeVisitor<array{matching: array<string>, non_matching: array<string>}>\n *\/\nfinal class TestCaseGeneratorNodeVisitor extends AbstractNodeVisitor\n{\n    private const MAX_SAMPLES = 3;\n\n    \/**\n     * Visits a RegexNode and generates test cases for its pattern.\n     *\n     * @param Node\\RegexNode $node the `RegexNode` representing the entire regular expression\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): array\n    {\n        return $node->pattern->accept($this);\n    }\n\n    \/**\n     * Visits an AlternationNode and generates test cases from one of its alternatives.\n     *\n     * @param Node\\AlternationNode $node the `AlternationNode` representing a choice between patterns\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): array\n    {\n        \/\/ Choose the first alternative for simplicity\n        $cases = $node->alternatives[0]->accept($this);\n\n        \/\/ Add non-matching by choosing a different alternative if available\n        $nonMatching = $cases['non_matching'];\n        if (\\count($node->alternatives) > 1) {\n            $other = $node->alternatives[1]->accept($this)['matching'];\n            $nonMatching = array_merge($nonMatching, \\array_slice($other, 0, 1));\n        }\n\n        return [\n            'matching' => \\array_slice($cases['matching'], 0, self::MAX_SAMPLES),\n            'non_matching' => \\array_slice($nonMatching, 0, self::MAX_SAMPLES),\n        ];\n    }\n\n    \/**\n     * Visits a SequenceNode and concatenates test cases from its children.\n     *\n     * @param Node\\SequenceNode $node the `SequenceNode` representing a series of regex components\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): array\n    {\n        $matching = [''];\n        $nonMatching = [''];\n\n        foreach ($node->children as $child) {\n            $childCases = $child->accept($this);\n            $newMatching = [];\n            $newNonMatching = [];\n\n            foreach ($matching as $m) {\n                foreach ($childCases['matching'] as $cm) {\n                    $newMatching[] = $m.$cm;\n                }\n            }\n\n            foreach ($nonMatching as $nm) {\n                foreach ($childCases['non_matching'] as $cnm) {\n                    $newNonMatching[] = $nm.$cnm;\n                }\n            }\n\n            $matching = \\array_slice($newMatching, 0, self::MAX_SAMPLES);\n            $nonMatching = \\array_slice($newNonMatching, 0, self::MAX_SAMPLES);\n        }\n\n        return [\n            'matching' => $matching,\n            'non_matching' => $nonMatching,\n        ];\n    }\n\n    \/**\n     * Visits a GroupNode and generates test cases from its child.\n     *\n     * @param Node\\GroupNode $node the `GroupNode` representing a grouping construct\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): array\n    {\n        return $node->child->accept($this);\n    }\n\n    \/**\n     * Visits a QuantifierNode and generates test cases based on repetition.\n     *\n     * @param Node\\QuantifierNode $node the `QuantifierNode` representing a repetition operator\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): array\n    {\n        $childCases = $node->node->accept($this);\n        $range = $this->parseQuantifierRange($node->quantifier);\n        $min = $range[0];\n        $max = $range[1];\n\n        $matching = [];\n        for ($i = $min; $i <= min($max ?? $min + 2, $min + 2); $i++) {\n            $sample = str_repeat($childCases['matching'][0] ?? '', $i);\n            $matching[] = $sample;\n        }\n\n        $nonMatching = [];\n        if ($min > 0) {\n            \/\/ Too few\n            $nonMatching[] = str_repeat($childCases['matching'][0] ?? '', $min - 1);\n        }\n        if (null !== $max) {\n            \/\/ Too many\n            $nonMatching[] = str_repeat($childCases['matching'][0] ?? '', $max + 1);\n        }\n\n        return [\n            'matching' => \\array_slice($matching, 0, self::MAX_SAMPLES),\n            'non_matching' => \\array_slice($nonMatching, 0, self::MAX_SAMPLES),\n        ];\n    }\n\n    \/**\n     * Visits a LiteralNode and generates test cases.\n     *\n     * @param Node\\LiteralNode $node the `LiteralNode` representing a literal character\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): array\n    {\n        $value = $node->value;\n        $matching = [$value];\n        $nonMatching = [];\n\n        \/\/ Generate non-matching by changing one character\n        if ('' !== $value) {\n            $chars = str_split($value);\n            for ($i = 0; $i < min(\\strlen($value), 2); $i++) {\n                $modified = $chars;\n                $modified[$i] = \\chr(\\ord($chars[$i]) + 1);\n                $nonMatching[] = implode('', $modified);\n            }\n        }\n\n        return [\n            'matching' => $matching,\n            'non_matching' => \\array_slice($nonMatching, 0, self::MAX_SAMPLES),\n        ];\n    }\n\n    \/**\n     * Visits a CharTypeNode and generates test cases.\n     *\n     * @param Node\\CharTypeNode $node the `CharTypeNode` representing a character type\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): array\n    {\n        $sample = $this->generateForCharType($node->value);\n        $matching = [$sample];\n        $nonMatching = ['!']; \/\/ Simple non-matching\n\n        return [\n            'matching' => $matching,\n            'non_matching' => $nonMatching,\n        ];\n    }\n\n    \/**\n     * Visits a DotNode and generates test cases.\n     *\n     * @param Node\\DotNode $node the `DotNode` representing the wildcard dot\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): array\n    {\n        return [\n            'matching' => ['a'],\n            'non_matching' => [\"\\n\"], \/\/ Assuming dot doesn't match newline\n        ];\n    }\n\n    \/**\n     * Visits an AnchorNode and returns empty test cases (anchors don't consume).\n     *\n     * @param Node\\AnchorNode $node the `AnchorNode` representing a positional anchor\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} empty test cases\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    \/**\n     * Visits an AssertionNode and returns empty test cases.\n     *\n     * @param Node\\AssertionNode $node the `AssertionNode` representing a zero-width assertion\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} empty test cases\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    \/**\n     * Visits a CharClassNode and generates test cases.\n     *\n     * @param Node\\CharClassNode $node the `CharClassNode` representing a character class\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): array\n    {\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        if (empty($parts)) {\n            return [\n                'matching' => [],\n                'non_matching' => ['a'],\n            ];\n        }\n\n        $sample = $parts[0]->accept($this)['matching'][0] ?? 'a';\n        $matching = [$sample];\n        $nonMatching = $node->isNegated ? [] : ['!'];\n\n        return [\n            'matching' => $matching,\n            'non_matching' => $nonMatching,\n        ];\n    }\n\n    \/**\n     * Visits a RangeNode and generates test cases.\n     *\n     * @param Node\\RangeNode $node the `RangeNode` representing a character range\n     *\n     * @return array{matching: array<string>, non_matching: array<string>} test cases\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): array\n    {\n        if (!$node->start instanceof Node\\LiteralNode || !$node->end instanceof Node\\LiteralNode) {\n            return [\n                'matching' => ['a'],\n                'non_matching' => ['!'],\n            ];\n        }\n\n        $start = $node->start->value;\n        $end = $node->end->value;\n        $sample = $start;\n        $nonMatching = \\chr(\\ord($end) + 1);\n\n        return [\n            'matching' => [$sample],\n            'non_matching' => [$nonMatching],\n        ];\n    }\n\n    \/\/ Other nodes return basic cases\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => ['x'],\n        ];\n    }\n\n    #[\\Override]\n    public function visitUnicode(Node\\UnicodeNode $node): array\n    {\n        return [\n            'matching' => ['a'],\n            'non_matching' => ['!'],\n        ];\n    }\n\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): array\n    {\n        return [\n            'matching' => ['a'],\n            'non_matching' => ['1'],\n        ];\n    }\n\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): array\n    {\n        return [\n            'matching' => ['a'],\n            'non_matching' => ['1'],\n        ];\n    }\n\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): array\n    {\n        return $node->yes->accept($this);\n    }\n\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => ['x'],\n        ];\n    }\n\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): array\n    {\n        return [\n            'matching' => [''],\n            'non_matching' => [''],\n        ];\n    }\n\n    \/**\n     * Parses a quantifier string into min and max.\n     *\n     * @param string $q the quantifier\n     *\n     * @return array{0: int, 1: int|null} min and max\n     *\/\n    private function parseQuantifierRange(string $q): array\n    {\n        return match ($q) {\n            '*' => [0, null],\n            '+' => [1, null],\n            '?' => [0, 1],\n            default => preg_match('\/^\\{(\\d++)(?:,(\\d*+))?\\}$\/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    [(int) $m[1], null] :\n                    [(int) $m[1], (int) $m[2]]\n                ) :\n                    [(int) $m[1], (int) $m[1]]\n                ) :\n                [1, 1],\n        };\n    }\n\n    \/**\n     * Generates a sample character for a character type.\n     *\n     * @param string $type the type\n     *\n     * @return string the sample\n     *\/\n    private function generateForCharType(string $type): string\n    {\n        return match ($type) {\n            'd' => '0',\n            'D' => 'a',\n            's' => ' ',\n            'S' => 'a',\n            'w' => 'a',\n            'W' => '!',\n            'h' => ' ',\n            'H' => 'a',\n            'v' => \"\\n\",\n            'V' => 'a',\n            'R' => \"\\r\\n\",\n            default => 'a',\n        };\n    }\n}\n",
    "NodeVisitor\/ConsoleHighlighterVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Highlights regex syntax for console output using ANSI escape codes.\n *\/\nfinal class ConsoleHighlighterVisitor extends HighlighterVisitor\n{\n    private const RESET = \"\\033[0m\";\n\n    private const COLORS = [\n        'meta' => \"\\033[1;34m\",      \/\/ Bold Blue\n        'quantifier' => \"\\033[1;33m\", \/\/ Bold Yellow\n        'type' => \"\\033[0;32m\",      \/\/ Green\n        'anchor' => \"\\033[0;35m\",    \/\/ Magenta\n        'literal' => '',             \/\/ Default\n    ];\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): string\n    {\n        $inner = $node->child->accept($this);\n        $prefix = match ($node->type) {\n            Node\\GroupType::T_GROUP_NON_CAPTURING => '?:',\n            Node\\GroupType::T_GROUP_LOOKAHEAD_POSITIVE => '?=',\n            Node\\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => '?!',\n            Node\\GroupType::T_GROUP_LOOKBEHIND_POSITIVE => '?<=',\n            Node\\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => '?<!',\n            Node\\GroupType::T_GROUP_ATOMIC => '?>',\n            Node\\GroupType::T_GROUP_NAMED => \"?<{$node->name}>\",\n            default => '',\n        };\n        $opening = self::COLORS['meta'].'('.$prefix.self::RESET;\n        $closing = self::COLORS['meta'].')'.self::RESET;\n\n        return $opening.$inner.$closing;\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): string\n    {\n        $condition = $node->condition->accept($this);\n        $yes = $node->yes->accept($this);\n        $no = $node->no->accept($this);\n        $noPart = $no ? self::COLORS['meta'].'|'.self::RESET.$no : '';\n\n        return self::COLORS['meta'].'(?('.self::RESET.$condition.self::COLORS['meta'].')'.self::RESET.$yes.$noPart.self::COLORS['meta'].')'.self::RESET;\n    }\n\n    protected function wrap(string $content, string $type): string\n    {\n        return self::COLORS[$type].$content.self::RESET;\n    }\n\n    protected function escape(string $string): string\n    {\n        return $string;\n    }\n}\n",
    "NodeVisitor\/NodeVisitorInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\n\n\/**\n * Defines the contract for a visitor that traverses the regex Abstract Syntax Tree (AST).\n *\n * @template-covariant TReturn The return type of the visitor's methods (e.g., `string`\n *                             for `CompilerNodeVisitor`, `void` for `ValidatorNodeVisitor`).\n *\/\ninterface NodeVisitorInterface\n{\n    \/**\n     * @return TReturn\n     *\/\n    public function visitRegex(Node\\RegexNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitAlternation(Node\\AlternationNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitSequence(Node\\SequenceNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitGroup(Node\\GroupNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitQuantifier(Node\\QuantifierNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitLiteral(Node\\LiteralNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitCharLiteral(Node\\CharLiteralNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitCharType(Node\\CharTypeNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitUnicode(Node\\UnicodeNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitDot(Node\\DotNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitAnchor(Node\\AnchorNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitAssertion(Node\\AssertionNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitKeep(Node\\KeepNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitCharClass(Node\\CharClassNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitRange(Node\\RangeNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitBackref(Node\\BackrefNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitClassOperation(Node\\ClassOperationNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitControlChar(Node\\ControlCharNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitScriptRun(Node\\ScriptRunNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitVersionCondition(Node\\VersionConditionNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitUnicodeProp(Node\\UnicodePropNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitPosixClass(Node\\PosixClassNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitComment(Node\\CommentNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitConditional(Node\\ConditionalNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitSubroutine(Node\\SubroutineNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitPcreVerb(Node\\PcreVerbNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitDefine(Node\\DefineNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitLimitMatch(Node\\LimitMatchNode $node);\n\n    \/**\n     * @return TReturn\n     *\/\n    public function visitCallout(Node\\CalloutNode $node);\n}\n",
    "NodeVisitor\/OptimizerNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\ReDoS\\CharSetAnalyzer;\n\n\/**\n * Transforms the AST to apply optimizations, returning a new, simplified AST.\n *\n * @extends AbstractNodeVisitor<Node\\NodeInterface>\n *\/\nfinal class OptimizerNodeVisitor extends AbstractNodeVisitor\n{\n    private const CHAR_CLASS_META = [']' => true, '\\\\' => true, '^' => true, '-' => true];\n\n    private string $flags = '';\n\n    private readonly CharSetAnalyzer $charSetAnalyzer;\n\n    private bool $isInsideQuantifier = false;\n\n    public function __construct(\n        private readonly bool $optimizeDigits = true,\n        private readonly bool $optimizeWord = true,\n        private readonly bool $strictRanges = true\n    ) {\n        $this->charSetAnalyzer = new CharSetAnalyzer();\n    }\n\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): Node\\NodeInterface\n    {\n        $this->flags = $node->flags;\n        $optimizedPattern = $node->pattern->accept($this);\n\n        if ($optimizedPattern === $node->pattern) {\n            return $node;\n        }\n\n        return new Node\\RegexNode($optimizedPattern, $node->flags, $node->delimiter, $node->startPosition, $node->endPosition);\n    }\n\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): Node\\NodeInterface\n    {\n        $optimizedAlts = [];\n        $hasChanged = false;\n\n        foreach ($node->alternatives as $alt) {\n            $optimizedAlt = $alt->accept($this);\n\n            if ($optimizedAlt instanceof Node\\AlternationNode) {\n                array_push($optimizedAlts, ...$optimizedAlt->alternatives);\n                $hasChanged = true;\n            } else {\n                $optimizedAlts[] = $optimizedAlt;\n            }\n\n            if ($optimizedAlt !== $alt) {\n                $hasChanged = true;\n            }\n        }\n\n        $deduplicatedAlts = $this->deduplicateAlternation($optimizedAlts);\n        if (\\count($deduplicatedAlts) !== \\count($optimizedAlts)) {\n            $hasChanged = true;\n            $optimizedAlts = $deduplicatedAlts;\n        }\n\n        if ($this->canAlternationBeCharClass($optimizedAlts)) {\n            \/* @var list<Node\\LiteralNode> $optimizedAlts *\/\n            $expression = new Node\\AlternationNode($optimizedAlts, $node->startPosition, $node->endPosition);\n\n            return new Node\\CharClassNode($expression, false, $node->startPosition, $node->endPosition);\n        }\n\n        if (!$hasChanged) {\n            return $node;\n        }\n\n        $deduplicatedAlts = $this->deduplicateAlternation($optimizedAlts);\n        if (\\count($deduplicatedAlts) !== \\count($optimizedAlts)) {\n            $hasChanged = true;\n            $optimizedAlts = $deduplicatedAlts;\n        }\n\n        $factoredAlts = $this->factorizeAlternation($optimizedAlts);\n\n        if ($factoredAlts !== $optimizedAlts) {\n            return new Node\\AlternationNode($factoredAlts, $node->startPosition, $node->endPosition);\n        }\n\n        return new Node\\AlternationNode($optimizedAlts, $node->startPosition, $node->endPosition);\n    }\n\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): Node\\NodeInterface\n    {\n        $optimizedChildren = [];\n        $hasChanged = false;\n\n        foreach ($node->children as $child) {\n            $optimizedChild = $child->accept($this);\n\n            if ($optimizedChild instanceof Node\\LiteralNode && \\count($optimizedChildren) > 0) {\n                $prevNode = $optimizedChildren[\\count($optimizedChildren) - 1];\n                if ($prevNode instanceof Node\\LiteralNode) {\n                    $optimizedChildren[\\count($optimizedChildren) - 1] = new Node\\LiteralNode(\n                        $prevNode->value.$optimizedChild->value,\n                        $prevNode->startPosition,\n                        $optimizedChild->endPosition,\n                    );\n                    $hasChanged = true;\n\n                    continue;\n                }\n            }\n\n            if ($optimizedChild instanceof Node\\SequenceNode) {\n                array_push($optimizedChildren, ...$optimizedChild->children);\n                $hasChanged = true;\n\n                continue;\n            }\n\n            if ($optimizedChild instanceof Node\\LiteralNode && '' === $optimizedChild->value) {\n                $hasChanged = true;\n\n                continue;\n            }\n\n            if ($optimizedChild !== $child) {\n                $hasChanged = true;\n            }\n\n            $optimizedChildren[] = $optimizedChild;\n        }\n\n        \/\/ Compact repeated literal sequences\n        foreach ($optimizedChildren as $i => $child) {\n            if ($child instanceof Node\\LiteralNode && preg_match('\/^(.)\\1+$\/', $child->value, $matches)) {\n                $char = $matches[1];\n                $count = \\strlen($child->value);\n                $baseNode = new Node\\LiteralNode($char, $child->startPosition, $child->endPosition);\n                $optimizedChildren[$i] = new Node\\QuantifierNode($baseNode, '{'.$count.'}', Node\\QuantifierType::T_GREEDY, $child->startPosition, $child->endPosition);\n                $hasChanged = true;\n            }\n        }\n\n        \/\/ Sequence compaction\n        $originalCount = \\count($optimizedChildren);\n        \/** @var list<Node\\NodeInterface> $optimizedChildren *\/\n        $optimizedChildren = array_values($optimizedChildren);\n        $optimizedChildren = $this->compactSequence($optimizedChildren);\n        if (\\count($optimizedChildren) !== $originalCount) {\n            $hasChanged = true;\n        }\n\n        \/\/ Auto-possessivization (only for + to be conservative)\n        for ($i = 0; $i < \\count($optimizedChildren) - 1; $i++) {\n            $current = $optimizedChildren[$i];\n            $next = $optimizedChildren[$i + 1];\n\n            if ($current instanceof Node\\QuantifierNode && Node\\QuantifierType::T_GREEDY === $current->type && '+' === $current->quantifier) {\n                if ($this->areCharSetsDisjoint($current->node, $next)) {\n                    $optimizedChildren[$i] = new Node\\QuantifierNode(\n                        $current->node,\n                        $current->quantifier,\n                        Node\\QuantifierType::T_POSSESSIVE,\n                        $current->startPosition,\n                        $current->endPosition,\n                    );\n                    $hasChanged = true;\n                }\n            }\n        }\n\n        if (!$hasChanged) {\n            return $node;\n        }\n\n        if (1 === \\count($optimizedChildren)) {\n            return $optimizedChildren[0];\n        }\n\n        if (0 === \\count($optimizedChildren)) {\n            return new Node\\LiteralNode('', $node->startPosition, $node->endPosition);\n        }\n\n        return new Node\\SequenceNode($optimizedChildren, $node->startPosition, $node->endPosition);\n    }\n\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): Node\\NodeInterface\n    {\n        $optimizedChild = $node->child->accept($this);\n\n        \/\/ Enhanced Group Unwrapping: (?:x) -> x\n        \/\/ If the group is non-capturing and contains a single atomic node, remove the group.\n        \/\/ But do not unwrap if we are inside a quantifier and the original child was a sequence or alternation,\n        \/\/ as unwrapping changes semantics when the group has a quantifier.\n        if (\n            GroupType::T_GROUP_NON_CAPTURING === $node->type\n            && !($this->isInsideQuantifier && ($node->child instanceof Node\\SequenceNode || $node->child instanceof Node\\AlternationNode))\n            && (\n                $optimizedChild instanceof Node\\LiteralNode\n                || $optimizedChild instanceof Node\\CharLiteralNode\n                || $optimizedChild instanceof Node\\CharTypeNode\n                || $optimizedChild instanceof Node\\DotNode\n                || $optimizedChild instanceof Node\\CharClassNode\n                || $optimizedChild instanceof Node\\AnchorNode\n                || $optimizedChild instanceof Node\\AssertionNode\n                || $optimizedChild instanceof Node\\UnicodePropNode\n            )\n        ) {\n            return $optimizedChild;\n        }\n\n        if ($optimizedChild !== $node->child) {\n            return new Node\\GroupNode($optimizedChild, $node->type, $node->name, $node->flags, $node->startPosition, $node->endPosition);\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): Node\\NodeInterface\n    {\n        $this->isInsideQuantifier = true;\n        $optimizedNode = $node->node->accept($this);\n        $this->isInsideQuantifier = false;\n\n        if ($optimizedNode !== $node->node) {\n            $node = new Node\\QuantifierNode($optimizedNode, $node->quantifier, $node->type, $node->startPosition, $node->endPosition);\n        }\n\n        $normalized = $this->normalizeQuantifier($node);\n        if ($normalized !== $node) {\n            return $normalized;\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): Node\\NodeInterface\n    {\n        $isUnicode = str_contains($this->flags, 'u');\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n\n        if ($this->optimizeDigits && !$isUnicode && !$node->isNegated && 1 === \\count($parts)) {\n            $part = $parts[0];\n            if ($part instanceof Node\\RangeNode && $part->start instanceof Node\\LiteralNode && $part->end instanceof Node\\LiteralNode) {\n                if ('0' === $part->start->value && '9' === $part->end->value) {\n                    return new Node\\CharTypeNode('d', $node->startPosition, $node->endPosition);\n                }\n            }\n        }\n\n        if ($this->optimizeWord && !$isUnicode && !$node->isNegated && 4 === \\count($parts)) {\n            if ($this->isFullWordClass($parts)) {\n                return new Node\\CharTypeNode('w', $node->startPosition, $node->endPosition);\n            }\n        }\n\n        $optimizedParts = [];\n        $hasChanged = false;\n        foreach ($parts as $part) {\n            $optimizedPart = $part->accept($this);\n            $optimizedParts[] = $optimizedPart;\n            if ($optimizedPart !== $part) {\n                $hasChanged = true;\n            }\n        }\n\n        [$optimizedParts, $normalizedChanged] = $this->normalizeCharClassParts($optimizedParts);\n        $hasChanged = $hasChanged || $normalizedChanged;\n\n        if ($hasChanged) {\n            if (1 === \\count($optimizedParts)) {\n                $expression = $optimizedParts[0];\n            } else {\n                $expression = new Node\\AlternationNode($optimizedParts, $node->startPosition, $node->endPosition);\n            }\n\n            return new Node\\CharClassNode($expression, $node->isNegated, $node->startPosition, $node->endPosition);\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): Node\\NodeInterface\n    {\n        $optimizedCond = $node->condition->accept($this);\n        $optimizedYes = $node->yes->accept($this);\n        $optimizedNo = $node->no->accept($this);\n\n        if ($optimizedCond !== $node->condition || $optimizedYes !== $node->yes || $optimizedNo !== $node->no) {\n            return new Node\\ConditionalNode($optimizedCond, $optimizedYes, $optimizedNo, $node->startPosition, $node->endPosition);\n        }\n\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `CharTypeNode`.\n     *\n     * Purpose: Character types like `\\d` are already in their most optimal form.\n     *\n     * @param Node\\CharTypeNode $node the character type node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `DotNode`.\n     *\n     * Purpose: The `.` wildcard is atomic and cannot be optimized.\n     *\n     * @param Node\\DotNode $node the dot node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits an `AnchorNode`.\n     *\n     * Purpose: Anchors like `^` and `$` are atomic and cannot be optimized.\n     *\n     * @param Node\\AnchorNode $node the anchor node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits an `AssertionNode`.\n     *\n     * Purpose: Assertions like `\\b` are atomic and cannot be optimized.\n     *\n     * @param Node\\AssertionNode $node the assertion node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `KeepNode`.\n     *\n     * Purpose: The `\\K` assertion is atomic and cannot be optimized.\n     *\n     * @param Node\\KeepNode $node the keep node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `BackrefNode`.\n     *\n     * Purpose: Backreferences are dynamic and cannot be optimized.\n     *\n     * @param Node\\BackrefNode $node the backreference node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `UnicodePropNode`.\n     *\n     * Purpose: Unicode property escapes are atomic and cannot be optimized.\n     *\n     * @param Node\\UnicodePropNode $node the Unicode property node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `PosixClassNode`.\n     *\n     * Purpose: POSIX classes are atomic and cannot be optimized further.\n     *\n     * @param Node\\PosixClassNode $node the POSIX class node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `CommentNode`.\n     *\n     * Purpose: Comments do not affect matching and are preserved as is.\n     *\n     * @param Node\\CommentNode $node the comment node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `SubroutineNode`.\n     *\n     * Purpose: Subroutine calls are dynamic and cannot be optimized.\n     *\n     * @param Node\\SubroutineNode $node the subroutine node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Visits a `PcreVerbNode`.\n     *\n     * Purpose: PCRE verbs control the matching engine and are not optimized.\n     *\n     * @param Node\\PcreVerbNode $node the PCRE verb node\n     *\n     * @return Node\\NodeInterface the unchanged node\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * Optimizes a `DefineNode`.\n     *\n     * Purpose: This method recursively optimizes the content within a `(?(DEFINE)...)` block.\n     *\n     * @param Node\\DefineNode $node the define node to optimize\n     *\n     * @return Node\\NodeInterface the new, optimized define node\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): Node\\NodeInterface\n    {\n        return new Node\\DefineNode(\n            $node->content->accept($this),\n            $node->startPosition,\n            $node->endPosition,\n        );\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): Node\\NodeInterface\n    {\n        return $node;\n    }\n\n    \/**\n     * @param array<Node\\NodeInterface> $alternatives\n     *\/\n    private function canAlternationBeCharClass(array $alternatives): bool\n    {\n        if (empty($alternatives)) {\n            return false;\n        }\n\n        foreach ($alternatives as $alt) {\n            if (!$alt instanceof Node\\LiteralNode) {\n                return false;\n            }\n            if (1 !== \\strlen($alt->value)) {  \/\/ Also excludes empty strings\n                return false;\n            }\n            if (isset(self::CHAR_CLASS_META[$alt->value])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * @param array<\\RegexParser\\Node\\NodeInterface> $parts\n     *\/\n    private function isFullWordClass(array $parts): bool\n    {\n        $partsFound = ['a-z' => false, 'A-Z' => false, '0-9' => false, '_' => false];\n        foreach ($parts as $part) {\n            if ($part instanceof Node\\RangeNode && $part->start instanceof Node\\LiteralNode && $part->end instanceof Node\\LiteralNode) {\n                $range = $part->start->value.'-'.$part->end->value;\n                if (isset($partsFound[$range])) {\n                    $partsFound[$range] = true;\n                }\n            } elseif ($part instanceof Node\\LiteralNode && '_' === $part->value) {\n                $partsFound['_'] = true;\n            }\n        }\n\n        return !\\in_array(false, $partsFound, true);\n    }\n\n    \/**\n     * Classify a character by its ASCII category for range merging.\n     *\n     * @param int $ord the ASCII ordinal of the character\n     *\n     * @return int category: 0=other, 1=digits, 2=uppercase, 3=lowercase\n     *\/\n    private function getCharCategory(int $ord): int\n    {\n        if ($ord >= 48 && $ord <= 57) { \/\/ 0-9\n            return 1;\n        }\n        if ($ord >= 65 && $ord <= 90) { \/\/ A-Z\n            return 2;\n        }\n        if ($ord >= 97 && $ord <= 122) { \/\/ a-z\n            return 3;\n        }\n\n        return 0; \/\/ other\n    }\n\n    \/**\n     * @param array<Node\\NodeInterface> $parts\n     *\n     * @return array{0: array<Node\\NodeInterface>, 1: bool}\n     *\/\n    private function normalizeCharClassParts(array $parts): array\n    {\n        \/** @var array<int, array{start: int, end: int}> $scalarChars *\/\n        $scalarChars = [];\n        $otherParts = [];\n        $changed = false;\n\n        foreach ($parts as $part) {\n            if ($part instanceof Node\\LiteralNode && 1 === \\strlen($part->value)) {\n                $ord = mb_ord($part->value);\n                if (isset($scalarChars[$ord])) {\n                    $scalarChars[$ord]['start'] = min($scalarChars[$ord]['start'], $part->startPosition);\n                    $scalarChars[$ord]['end'] = max($scalarChars[$ord]['end'], $part->endPosition);\n                    $changed = true;\n                } else {\n                    $scalarChars[$ord] = ['start' => $part->startPosition, 'end' => $part->endPosition];\n                }\n\n                continue;\n            }\n\n            if ($part instanceof Node\\RangeNode\n                && $part->start instanceof Node\\LiteralNode\n                && $part->end instanceof Node\\LiteralNode\n                && 1 === \\strlen($part->start->value)\n                && 1 === \\strlen($part->end->value)\n            ) {\n                $startOrd = mb_ord($part->start->value);\n                $endOrd = mb_ord($part->end->value);\n                if ($startOrd > $endOrd) {\n                    [$startOrd, $endOrd] = [$endOrd, $startOrd];\n                }\n                for ($ord = $startOrd; $ord <= $endOrd; $ord++) {\n                    if (isset($scalarChars[$ord])) {\n                        $scalarChars[$ord]['start'] = min($scalarChars[$ord]['start'], $part->startPosition);\n                        $scalarChars[$ord]['end'] = max($scalarChars[$ord]['end'], $part->endPosition);\n                    } else {\n                        $scalarChars[$ord] = ['start' => $part->startPosition, 'end' => $part->endPosition];\n                    }\n                }\n                $changed = true;\n\n                continue;\n            }\n\n            $otherParts[] = $part;\n        }\n\n        if (empty($scalarChars)) {\n            return [$parts, $changed];\n        }\n\n        ksort($scalarChars);\n\n        $normalized = [];\n        $hasRange = false;\n        $rangeStart = 0;\n        $rangeEnd = 0;\n        $rangeStartPos = 0;\n        $rangeEndPos = 0;\n\n        foreach ($scalarChars as $ord => $pos) {\n            $ord = (int) $ord;\n            $posStart = (int) $pos['start'];\n            $posEnd = (int) $pos['end'];\n\n            if (!$hasRange) {\n                $rangeStart = $ord;\n                $rangeEnd = $ord;\n                $rangeStartPos = $posStart;\n                $rangeEndPos = $posEnd;\n                $hasRange = true;\n\n                continue;\n            }\n\n            if ($ord === $rangeEnd + 1 && (!$this->strictRanges || $this->getCharCategory($ord) === $this->getCharCategory($rangeEnd))) {\n                $rangeEnd = $ord;\n                $rangeEndPos = max($rangeEndPos, $posEnd);\n\n                continue;\n            }\n\n            $normalized = array_merge($normalized, $this->buildRangeOrLiteral($rangeStart, $rangeEnd, $rangeStartPos, $rangeEndPos));\n            $rangeStart = $ord;\n            $rangeEnd = $ord;\n            $rangeStartPos = $posStart;\n            $rangeEndPos = $posEnd;\n        }\n\n        $normalized = array_merge($normalized, $this->buildRangeOrLiteral($rangeStart, $rangeEnd, $rangeStartPos, $rangeEndPos));\n\n        $finalParts = array_merge($normalized, $otherParts);\n\n        return [$finalParts, $changed || \\count($finalParts) !== \\count($parts)];\n    }\n\n    \/**\n     * @return array<Node\\NodeInterface>\n     *\/\n    private function buildRangeOrLiteral(int $startOrd, int $endOrd, int $startPos, int $endPos): array\n    {\n        $startLiteral = new Node\\LiteralNode(mb_chr($startOrd), $startPos, $startPos + 1);\n\n        if ($startOrd === $endOrd) {\n            return [$startLiteral];\n        }\n\n        \/\/ Only create a range if it covers 3 or more characters to save space\n        $coverage = $endOrd - $startOrd + 1;\n        if ($coverage < 3) {\n            \/\/ For 2 characters, return them as separate literals\n            $endLiteral = new Node\\LiteralNode(mb_chr($endOrd), $endPos, $endPos + 1);\n\n            return [$startLiteral, $endLiteral];\n        }\n\n        $endLiteral = new Node\\LiteralNode(mb_chr($endOrd), $endPos, $endPos + 1);\n\n        return [new Node\\RangeNode($startLiteral, $endLiteral, $startPos, $endPos)];\n    }\n\n    \/**\n     * @param list<Node\\NodeInterface> $children\n     *\n     * @return list<Node\\NodeInterface>\n     *\/\n    private function compactSequence(array $children): array\n    {\n        if (empty($children)) {\n            return $children;\n        }\n\n        $compacted = [];\n        $currentNode = null;\n        $currentCount = 0;\n\n        foreach ($children as $child) {\n            $baseNode = $child;\n            $count = 1;\n\n            if ($child instanceof Node\\QuantifierNode) {\n                $baseNode = $child->node;\n                $parsedCount = $this->parseQuantifierCount($child->quantifier);\n                if (null === $parsedCount) {\n                    \/\/ Variable quantifier, don't merge\n                    if (null !== $currentNode) {\n                        $compacted[] = $this->createQuantifiedNode($currentNode, $currentCount);\n                        $currentNode = null;\n                        $currentCount = 0;\n                    }\n                    $compacted[] = $child;\n\n                    continue;\n                }\n                $count = $parsedCount;\n            }\n\n            if (null === $currentNode || !$this->areNodesEqual($currentNode, $baseNode)) {\n                if (null !== $currentNode) {\n                    $compacted[] = $this->createQuantifiedNode($currentNode, $currentCount);\n                }\n                $currentNode = $baseNode;\n                $currentCount = $count;\n            } else {\n                $currentCount += $count;\n            }\n        }\n\n        if (null !== $currentNode) {\n            $compacted[] = $this->createQuantifiedNode($currentNode, $currentCount);\n        }\n\n        return $compacted;\n    }\n\n    private function parseQuantifierCount(string $quantifier): ?int\n    {\n        if (preg_match('\/^\\{(\\d+)(?:,(\\d*))?\\}$\/', $quantifier, $matches)) {\n            $min = (int) $matches[1];\n            $max = isset($matches[2]) ? ('' === $matches[2] ? \\PHP_INT_MAX : (int) $matches[2]) : $min;\n            if ($min === $max) {\n                return $min;\n            }\n\n            \/\/ For ranges, don't merge\n            return null;\n        }\n\n        \/\/ For * + ?, don't merge\n        return null;\n    }\n\n    private function areNodesEqual(Node\\NodeInterface $a, Node\\NodeInterface $b): bool\n    {\n        \/\/ Simple equality: same type and same string representation\n        if ($a::class !== $b::class) {\n            return false;\n        }\n\n        return $this->nodeToString($a) === $this->nodeToString($b);\n    }\n\n    private function createQuantifiedNode(Node\\NodeInterface $node, int $count): Node\\NodeInterface\n    {\n        if (1 === $count) {\n            return $node;\n        }\n\n        return new Node\\QuantifierNode(\n            $node,\n            '{'.$count.'}',\n            Node\\QuantifierType::T_GREEDY,\n            $node->getStartPosition(),\n            $node->getEndPosition(),\n        );\n    }\n\n    private function areCharSetsDisjoint(Node\\NodeInterface $node1, Node\\NodeInterface $node2): bool\n    {\n        try {\n            $set1 = $this->charSetAnalyzer->lastChars($node1);\n            $set2 = $this->charSetAnalyzer->firstChars($node2);\n\n            return !$set1->intersects($set2);\n        } catch (\\Throwable) {\n            return false; \/\/ If analysis fails, don't optimize\n        }\n    }\n\n    private function normalizeQuantifier(Node\\QuantifierNode $node): Node\\NodeInterface\n    {\n        $quantifier = $node->quantifier;\n\n        if ('{0,}' === $quantifier) {\n            return new Node\\QuantifierNode($node->node, '*', $node->type, $node->startPosition, $node->endPosition);\n        }\n\n        if ('{1,}' === $quantifier) {\n            return new Node\\QuantifierNode($node->node, '+', $node->type, $node->startPosition, $node->endPosition);\n        }\n\n        if ('{0,1}' === $quantifier) {\n            return new Node\\QuantifierNode($node->node, '?', $node->type, $node->startPosition, $node->endPosition);\n        }\n\n        if ('{1}' === $quantifier || '{1,1}' === $quantifier) {\n            return $node->node;\n        }\n\n        if ('{0}' === $quantifier || '{0,0}' === $quantifier) {\n            return new Node\\LiteralNode('', $node->startPosition, $node->endPosition);\n        }\n\n        return $node;\n    }\n\n    \/**\n     * @param list<Node\\NodeInterface> $alts\n     *\n     * @return list<Node\\NodeInterface>\n     *\/\n    private function deduplicateAlternation(array $alts): array\n    {\n        $seen = [];\n        $unique = [];\n\n        foreach ($alts as $alt) {\n            $key = $this->nodeToString($alt);\n            if (!isset($seen[$key])) {\n                $seen[$key] = true;\n                $unique[] = $alt;\n            }\n        }\n\n        return $unique;\n    }\n\n    \/**\n     * @param list<Node\\NodeInterface> $alts\n     *\n     * @return list<Node\\NodeInterface>\n     *\/\n    private function factorizeAlternation(array $alts): array\n    {\n        if (\\count($alts) < 2) {\n            return $alts;\n        }\n\n        \/\/ Get string representations\n        $strings = [];\n        foreach ($alts as $alt) {\n            $strings[] = $this->nodeToString($alt);\n        }\n\n        \/\/ Find common prefix\n        $prefix = $this->findCommonPrefix($strings);\n        if (empty($prefix) || str_starts_with($prefix, '[')) {\n            return $alts;\n        }\n\n        \/\/ Split into with prefix and without\n        $withPrefix = [];\n        $withoutPrefix = [];\n        foreach ($alts as $i => $alt) {\n            if (str_starts_with($strings[$i], $prefix)) {\n                $withPrefix[] = $alt;\n            } else {\n                $withoutPrefix[] = $alt;\n            }\n        }\n\n        if (\\count($withPrefix) < 2) {\n            return $alts;\n        }\n\n        \/\/ Create suffixes\n        $suffixes = [];\n        \/**\n         * @var \\RegexParser\\Node\\AbstractNode $alt\n         *\/\n        foreach ($withPrefix as $alt) {\n            $suffixStr = substr($this->nodeToString($alt), \\strlen($prefix));\n            if (empty($suffixStr)) {\n                $suffixes[] = null;\n            } else {\n                $suffixes[] = $this->stringToNode($suffixStr, $alt->startPosition + \\strlen($prefix), $alt->endPosition);\n            }\n        }\n\n        $nonNullSuffixes = array_filter($suffixes, fn ($s) => null !== $s);\n        if (empty($nonNullSuffixes)) {\n            \/\/ All are just the prefix\n            \/** @var \\RegexParser\\Node\\AbstractNode $firstAlt *\/\n            $firstAlt = $withPrefix[0];\n\n            return [$this->stringToNode($prefix, $firstAlt->startPosition, $firstAlt->startPosition + \\strlen($prefix))];\n        }\n\n        \/** @var \\RegexParser\\Node\\AbstractNode $firstSuffix *\/\n        $firstSuffix = $nonNullSuffixes[0];\n        \/** @var \\RegexParser\\Node\\AbstractNode $lastSuffix *\/\n        $lastSuffix = end($nonNullSuffixes);\n        $newAlt = 1 === \\count($nonNullSuffixes) ? $nonNullSuffixes[0] : new Node\\AlternationNode($nonNullSuffixes, $firstSuffix->startPosition, $lastSuffix->endPosition);\n        $group = new Node\\GroupNode($newAlt, Node\\GroupType::T_GROUP_NON_CAPTURING);\n        \/** @var \\RegexParser\\Node\\AbstractNode $firstAlt *\/\n        $firstAlt = $withPrefix[0];\n        $prefixNode = $this->stringToNode($prefix, $firstAlt->startPosition, $firstAlt->startPosition + \\strlen($prefix));\n        $factored = new Node\\SequenceNode([$prefixNode, $group], $firstAlt->startPosition, $firstAlt->endPosition);\n\n        if (empty($withoutPrefix)) {\n            return [$factored];\n        }\n\n        return array_merge([$factored], $withoutPrefix);\n\n    }\n\n    private function nodeToString(Node\\NodeInterface $node): string\n    {\n        $compiler = new CompilerNodeVisitor();\n\n        return $node->accept($compiler);\n    }\n\n    private function stringToNode(string $str, int $start, int $end): Node\\NodeInterface\n    {\n        if (1 === \\strlen($str)) {\n            return new Node\\LiteralNode($str, $start, $end);\n        }\n        $children = [];\n        for ($i = 0; $i < \\strlen($str); $i++) {\n            $children[] = new Node\\LiteralNode($str[$i], $start + $i, $start + $i + 1);\n        }\n\n        return new Node\\SequenceNode($children, $start, $end);\n    }\n\n    \/**\n     * @param array<string> $strings\n     *\/\n    private function findCommonPrefix(array $strings): string\n    {\n        if (empty($strings)) {\n            return '';\n        }\n        $prefix = $strings[0];\n        foreach ($strings as $str) {\n            while (!str_starts_with((string) $str, (string) $prefix)) {\n                $prefix = substr((string) $prefix, 0, -1);\n                if (empty($prefix)) {\n                    return '';\n                }\n            }\n        }\n\n        return $prefix;\n    }\n}\n",
    "NodeVisitor\/LiteralExtractorNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\LiteralSet;\nuse RegexParser\\Node;\n\n\/**\n * Extracts literal strings that must appear in any match.\n *\n * Purpose: This visitor analyzes the regex AST to identify fixed strings\n * that are guaranteed to appear in every possible match. These\n * literals can be used for fast-path optimizations (e.g. strpos check).\n * For instance, if a regex is `\/foo.*bar\/`, this visitor would identify\n * \"foo\" as a prefix and \"bar\" as a suffix that must exist in any matching string.\n * This can significantly speed up initial matching attempts by using simple string\n * search functions before engaging the full regex engine.\n *\n * @extends AbstractNodeVisitor<LiteralSet>\n *\/\nfinal class LiteralExtractorNodeVisitor extends AbstractNodeVisitor\n{\n    \/**\n     * Maximum number of literals generated to prevent explosion (e.g. [a-z]{10}).\n     *\/\n    private const MAX_LITERALS_COUNT = 128;\n\n    private bool $caseInsensitive = false;\n\n    \/**\n     * Visits a RegexNode and initiates the literal extraction process.\n     *\n     * Purpose: This is the entry point for extracting literal strings from an entire\n     * regular expression. It first checks for the 'i' flag to determine case-insensitivity,\n     * which affects how literals are extracted. It then delegates the actual extraction\n     * to the main pattern node.\n     *\n     * @param Node\\RegexNode $node the `RegexNode` representing the entire regular expression\n     *\n     * @return LiteralSet a `LiteralSet` containing all guaranteed literal prefixes and suffixes\n     *                    that must be present in any string matching the regex\n     *\n     * @example\n     * ```php\n     * \/\/ Assuming $regexNode is the root of your parsed AST for '\/hello.*world\/i'\n     * $visitor = new LiteralExtractorNodeVisitor();\n     * $literalSet = $regexNode->accept($visitor);\n     * \/\/ $literalSet->prefixes might contain ['hello', 'Hello', 'HEllo', ...]\n     * \/\/ $literalSet->suffixes might contain ['world', 'World', 'WORld', ...]\n     * ```\n     *\/\n    #[\\Override]\n    public function visitRegex(Node\\RegexNode $node): LiteralSet\n    {\n        $this->caseInsensitive = str_contains($node->flags, 'i');\n\n        return $node->pattern->accept($this);\n    }\n\n    \/**\n     * Visits an AlternationNode and extracts common literals from its alternatives.\n     *\n     * Purpose: When a regex contains an \"OR\" condition (e.g., `cat|dog`), this method\n     * identifies literals that are common to *all* alternatives. If no common literal\n     * can be found, or if the alternatives are too complex, it returns an empty `LiteralSet`.\n     * This ensures that only truly guaranteed literals are extracted.\n     *\n     * @param Node\\AlternationNode $node the `AlternationNode` representing a choice between patterns\n     *\n     * @return LiteralSet a `LiteralSet` representing the common literals across all alternatives\n     *\n     * @example\n     * ```php\n     * \/\/ For an alternation like `(foo|bar)`\n     * $alternationNode->accept($visitor); \/\/ Returns an empty LiteralSet as 'foo' and 'bar' are not common.\n     *\n     * \/\/ For an alternation like `(prefix_foo|prefix_bar)`\n     * $alternationNode->accept($visitor); \/\/ Might return a LiteralSet with 'prefix_' as a common prefix.\n     * ```\n     *\/\n    #[\\Override]\n    public function visitAlternation(Node\\AlternationNode $node): LiteralSet\n    {\n        $result = null;\n\n        foreach ($node->alternatives as $alt) {\n            \/** @var LiteralSet $altSet *\/\n            $altSet = $alt->accept($this);\n\n            if (null === $result) {\n                $result = $altSet;\n            } else {\n                $result = $result->unite($altSet);\n            }\n\n            \/\/ Safety valve for memory\n            if (\\count($result->prefixes) > self::MAX_LITERALS_COUNT) {\n                return LiteralSet::empty();\n            }\n        }\n\n        return $result ?? LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a SequenceNode and concatenates literals from its child nodes.\n     *\n     * Purpose: This method processes a linear sequence of regex elements (e.g., `abc`).\n     * It recursively extracts literals from each child node and then concatenates them\n     * to form a longer literal sequence. This is crucial for building up longer guaranteed\n     * literal strings from simpler components.\n     *\n     * @param Node\\SequenceNode $node the `SequenceNode` representing a series of regex components\n     *\n     * @return LiteralSet a `LiteralSet` representing the concatenated literals from its children\n     *\n     * @example\n     * ```php\n     * \/\/ For a sequence `foo.*bar`\n     * $sequenceNode->accept($visitor); \/\/ Might return a LiteralSet with 'foo' as prefix and 'bar' as suffix.\n     * ```\n     *\/\n    #[\\Override]\n    public function visitSequence(Node\\SequenceNode $node): LiteralSet\n    {\n        $result = LiteralSet::fromString(''); \/\/ Start with empty complete string\n\n        foreach ($node->children as $child) {\n            \/** @var LiteralSet $childSet *\/\n            $childSet = $child->accept($this);\n            $result = $result->concat($childSet);\n\n            \/\/ Safety valve\n            if (\\count($result->prefixes) > self::MAX_LITERALS_COUNT) {\n                return LiteralSet::empty();\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Visits a GroupNode and extracts literals from its child, handling inline flags.\n     *\n     * Purpose: This method is responsible for extracting literals from within groups.\n     * It's particularly important for handling inline flag modifiers (e.g., `(?i:...)` or `(?-i:...)`),\n     * which can change the case-insensitivity setting for the group's content. The original\n     * case-insensitivity state is restored after visiting the group's child.\n     *\n     * @param Node\\GroupNode $node the `GroupNode` representing a specific grouping construct\n     *\n     * @return LiteralSet a `LiteralSet` containing literals extracted from the group's child\n     *\n     * @example\n     * ```php\n     * \/\/ For a group `(?i:hello)`\n     * $groupNode->accept($visitor); \/\/ Will extract 'hello', 'Hello', 'HEllo', etc., due to inline 'i' flag.\n     * ```\n     *\/\n    #[\\Override]\n    public function visitGroup(Node\\GroupNode $node): LiteralSet\n    {\n        \/\/ Handle inline flags if present\n        $previousState = $this->caseInsensitive;\n        if ($node->flags) {\n            if (str_contains($node->flags, '-i')) {\n                $this->caseInsensitive = false;\n            } elseif (str_contains($node->flags, 'i')) {\n                $this->caseInsensitive = true;\n            }\n        }\n\n        \/** @var LiteralSet $result *\/\n        $result = $node->child->accept($this);\n\n        \/\/ Restore state\n        $this->caseInsensitive = $previousState;\n\n        return $result;\n    }\n\n    \/**\n     * Visits a QuantifierNode and extracts literals based on its repetition rules.\n     *\n     * Purpose: This method intelligently extracts literals from quantified elements.\n     * For exact quantifiers (`{n}`), it repeats the child's literals `n` times.\n     * For quantifiers guaranteeing at least one repetition (`+`, `{n,}`), it extracts\n     * the child's literals but marks them as potentially incomplete (as more repetitions\n     * might follow). For optional quantifiers (`*`, `?`), it cannot guarantee presence,\n     * so it returns an empty `LiteralSet`.\n     *\n     * @param Node\\QuantifierNode $node the `QuantifierNode` representing a repetition operator\n     *\n     * @return LiteralSet a `LiteralSet` containing literals extracted based on the quantifier's rules\n     *\n     * @example\n     * ```php\n     * \/\/ For a quantifier `a{3}`\n     * $quantifierNode->accept($visitor); \/\/ Returns a LiteralSet with 'aaa'.\n     *\n     * \/\/ For a quantifier `a+`\n     * $quantifierNode->accept($visitor); \/\/ Returns a LiteralSet with 'a' as a prefix, but not complete.\n     *\n     * \/\/ For a quantifier `a*`\n     * $quantifierNode->accept($visitor); \/\/ Returns an empty LiteralSet.\n     * ```\n     *\/\n    #[\\Override]\n    public function visitQuantifier(Node\\QuantifierNode $node): LiteralSet\n    {\n        \/\/ Case 1: Exact quantifier {n} -> repeat literals n times\n        if (preg_match('\/^\\{(\\d++)\\}$\/', $node->quantifier, $m)) {\n            $count = (int) $m[1];\n            if (0 === $count) {\n                return LiteralSet::fromString(''); \/\/ Matches empty string\n            }\n\n            \/** @var LiteralSet $childSet *\/\n            $childSet = $node->node->accept($this);\n\n            \/\/ Repeat concatenation\n            $result = $childSet;\n            for ($i = 1; $i < $count; $i++) {\n                $result = $result->concat($childSet);\n                if (\\count($result->prefixes) > self::MAX_LITERALS_COUNT) {\n                    return LiteralSet::empty();\n                }\n            }\n\n            return $result;\n        }\n\n        \/\/ Case 2: + or {n,} (At least 1)\n        \/\/ We can extract the literal from the node, but it's not complete anymore because of the tail\n        if ('+' === $node->quantifier || preg_match('\/^\\{(\\d++),\/', $node->quantifier)) {\n            \/** @var LiteralSet $childSet *\/\n            $childSet = $node->node->accept($this);\n\n            \/\/ The literal is present at least once, but followed by unknown quantity.\n            \/\/ So suffixes are lost, completeness is lost.\n            return new LiteralSet($childSet->prefixes, [], false);\n        }\n\n        \/\/ Case 3: * or ? (Optional)\n        \/\/ Cannot guarantee presence.\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a LiteralNode and extracts its value as a literal.\n     *\n     * Purpose: This is the most direct literal extraction. When a literal character\n     * or string (e.g., `a`, `hello`) is encountered, its exact value is returned\n     * as a `LiteralSet`. If case-insensitivity is active, it expands the literal\n     * to include all possible case variations.\n     *\n     * @param Node\\LiteralNode $node the `LiteralNode` representing a literal character or string\n     *\n     * @return LiteralSet a `LiteralSet` containing the literal value(s)\n     *\n     * @example\n     * ```php\n     * \/\/ For a literal `a` (case-sensitive)\n     * $literalNode->accept($visitor); \/\/ Returns a LiteralSet with ['a'].\n     *\n     * \/\/ For a literal `a` (case-insensitive)\n     * $literalNode->accept($visitor); \/\/ Returns a LiteralSet with ['a', 'A'].\n     * ```\n     *\/\n    #[\\Override]\n    public function visitLiteral(Node\\LiteralNode $node): LiteralSet\n    {\n        if ($this->caseInsensitive) {\n            return $this->expandCaseInsensitive($node->value);\n        }\n\n        return LiteralSet::fromString($node->value);\n    }\n\n    \/**\n     * Visits a CharClassNode and extracts literals if it represents a simple,\n     * non-negated set of literals.\n     *\n     * Purpose: This method attempts to extract literals from character classes like `[abc]`.\n     * If the character class is simple (non-negated and contains only literal parts),\n     * it treats it as an alternation of those literals. More complex character classes\n     * (e.g., `[^0-9]`, `[a-z]`, or those containing character types) are considered\n     * non-literal for simplicity and return an empty `LiteralSet`.\n     *\n     * @param Node\\CharClassNode $node the `CharClassNode` representing a character class\n     *\n     * @return LiteralSet a `LiteralSet` containing literals from the character class, or empty if complex\n     *\n     * @example\n     * ```php\n     * \/\/ For a character class `[abc]`\n     * $charClassNode->accept($visitor); \/\/ Returns a LiteralSet with ['a', 'b', 'c'].\n     *\n     * \/\/ For a character class `[^0-9]`\n     * $charClassNode->accept($visitor); \/\/ Returns an empty LiteralSet.\n     * ```\n     *\/\n    #[\\Override]\n    public function visitCharClass(Node\\CharClassNode $node): LiteralSet\n    {\n        $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n        \/\/ Optimization: Single character class [a] is literal 'a'\n        if (!$node->isNegated && 1 === \\count($parts) && $parts[0] instanceof Node\\LiteralNode) {\n            return $this->visitLiteral($parts[0]);\n        }\n\n        \/\/ [abc] is effectively an alternation a|b|c\n        \/\/ We only handle simple literals inside char classes for now to avoid complexity\n        if (!$node->isNegated) {\n            $literals = [];\n            foreach ($parts as $part) {\n                if ($part instanceof Node\\LiteralNode) {\n                    if ($this->caseInsensitive) {\n                        $expanded = $this->expandCaseInsensitive($part->value);\n                        array_push($literals, ...$expanded->prefixes);\n                    } else {\n                        $literals[] = $part->value;\n                    }\n                } else {\n                    \/\/ Range, char type, etc. -> considered non-literal for simplicity\n                    return LiteralSet::empty();\n                }\n            }\n\n            return new LiteralSet($literals, $literals, true); \/\/ Complete single char match\n        }\n\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a CharTypeNode. Character types do not yield fixed literals.\n     *\n     * Purpose: Predefined character types (e.g., `\\d`, `\\s`, `\\w`) match a *class*\n     * of characters, not a single fixed literal. Therefore, they cannot contribute\n     * to a guaranteed literal string, and this method returns an empty `LiteralSet`.\n     *\n     * @param Node\\CharTypeNode $node the `CharTypeNode` representing a predefined character type\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitCharType(Node\\CharTypeNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a DotNode. The wildcard dot does not yield a fixed literal.\n     *\n     * Purpose: The dot (`.`) matches any single character (except newline by default).\n     * Since it can match various characters, it cannot contribute to a guaranteed\n     * literal string, and this method returns an empty `LiteralSet`.\n     *\n     * @param Node\\DotNode $node the `DotNode` representing the wildcard dot character\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitDot(Node\\DotNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits an AnchorNode. Anchors match empty strings and can be part of literal sequences.\n     *\n     * Purpose: Positional anchors (e.g., `^`, `$`, `\\b`) assert a position but do not\n     * consume characters. They effectively match an empty string. Returning a `LiteralSet`\n     * representing an empty string allows them to be correctly integrated into literal\n     * sequences (e.g., `\/^abc\/` can still yield 'abc' as a prefix).\n     *\n     * @param Node\\AnchorNode $node the `AnchorNode` representing a positional anchor\n     *\n     * @return LiteralSet a `LiteralSet` representing an empty string\n     *\/\n    #[\\Override]\n    public function visitAnchor(Node\\AnchorNode $node): LiteralSet\n    {\n        \/\/ Anchors match empty strings, so they are \"complete\" empty matches\n        \/\/ This allows \/^abc\/ to return prefix 'abc'\n        return LiteralSet::fromString('');\n    }\n\n    \/**\n     * Visits an AssertionNode. Assertions match empty strings and can be part of literal sequences.\n     *\n     * Purpose: Zero-width assertions (e.g., `\\b`, `\\A`) check for conditions without\n     * consuming characters. Similar to anchors, they effectively match an empty string.\n     * Returning a `LiteralSet` representing an empty string allows them to be correctly\n     * integrated into literal sequences.\n     *\n     * @param Node\\AssertionNode $node the `AssertionNode` representing a zero-width assertion\n     *\n     * @return LiteralSet a `LiteralSet` representing an empty string\n     *\/\n    #[\\Override]\n    public function visitAssertion(Node\\AssertionNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    \/**\n     * Visits a KeepNode. The `\\K` assertion matches an empty string and can be part of literal sequences.\n     *\n     * Purpose: The `\\K` assertion resets the starting point of the match but does not\n     * consume characters. It effectively matches an empty string. Returning a `LiteralSet`\n     * representing an empty string allows it to be correctly integrated into literal sequences.\n     *\n     * @param Node\\KeepNode $node the `KeepNode` representing the `\\K` assertion\n     *\n     * @return LiteralSet a `LiteralSet` representing an empty string\n     *\/\n    #[\\Override]\n    public function visitKeep(Node\\KeepNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    \/**\n     * Visits a RangeNode. Character ranges do not yield fixed literals.\n     *\n     * Purpose: Character ranges (e.g., `a-z`) within a character class match any character\n     * within that range. Since they can match various characters, they cannot contribute\n     * to a guaranteed literal string, and this method returns an empty `LiteralSet`.\n     *\n     * @param Node\\RangeNode $node the `RangeNode` representing a character range\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitRange(Node\\RangeNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a BackrefNode. Backreferences do not yield fixed literals.\n     *\n     * Purpose: Backreferences (e.g., `\\1`, `\\k<name>`) match previously captured text,\n     * which is dynamic and not a fixed literal. Therefore, they cannot contribute to\n     * a guaranteed literal string, and this method returns an empty `LiteralSet`.\n     *\n     * @param Node\\BackrefNode $node the `BackrefNode` representing a backreference\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitBackref(Node\\BackrefNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a UnicodePropNode. Unicode properties do not yield fixed literals.\n     *\n     * Purpose: Unicode character properties (e.g., `\\p{L}`) match a class of characters\n     * based on their property, not a single fixed literal. Therefore, they cannot\n     * contribute to a guaranteed literal string, and this method returns an empty `LiteralSet`.\n     *\n     * @param Node\\UnicodePropNode $node the `UnicodePropNode` representing a Unicode property\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitUnicodeProp(Node\\UnicodePropNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    #[\\Override]\n    public function visitCharLiteral(Node\\CharLiteralNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a PosixClassNode. POSIX character classes do not yield fixed literals.\n     *\n     * Purpose: POSIX character classes (e.g., `[:alpha:]`) match a class of characters,\n     * not a single fixed literal. Therefore, they cannot contribute to a guaranteed\n     * literal string, and this method returns an empty `LiteralSet`.\n     *\n     * @param Node\\PosixClassNode $node the `PosixClassNode` representing a POSIX character class\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitPosixClass(Node\\PosixClassNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a CommentNode. Comments match empty strings and can be part of literal sequences.\n     *\n     * Purpose: Comments within a regex (e.g., `(?#comment)`) are ignored by the regex engine\n     * and do not consume characters. They effectively match an empty string. Returning a\n     * `LiteralSet` representing an empty string allows them to be correctly integrated\n     * into literal sequences.\n     *\n     * @param Node\\CommentNode $node the `CommentNode` representing an inline comment\n     *\n     * @return LiteralSet a `LiteralSet` representing an empty string\n     *\/\n    #[\\Override]\n    public function visitComment(Node\\CommentNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    \/**\n     * Visits a ConditionalNode. Conditional patterns do not yield fixed literals.\n     *\n     * Purpose: Conditional patterns (e.g., `(?(condition)yes|no)`) introduce branching\n     * logic where different paths can be taken. Unless both branches yield the *exact*\n     * same literal, no fixed literal can be guaranteed. For simplicity, this visitor\n     * treats conditional nodes as non-literal and returns an empty `LiteralSet`.\n     *\n     * @param Node\\ConditionalNode $node the `ConditionalNode` representing a conditional sub-pattern\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitConditional(Node\\ConditionalNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a SubroutineNode. Subroutines do not yield fixed literals.\n     *\n     * Purpose: Subroutines (e.g., `(?&name)`) call other patterns, which can be dynamic\n     * or recursive. Determining a fixed literal from a subroutine call is complex and\n     * beyond the scope of this visitor's simple literal extraction. It returns an empty `LiteralSet`.\n     *\n     * @param Node\\SubroutineNode $node the `SubroutineNode` representing a subroutine call\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitSubroutine(Node\\SubroutineNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    \/**\n     * Visits a PcreVerbNode. PCRE verbs match empty strings and can be part of literal sequences.\n     *\n     * Purpose: PCRE control verbs (e.g., `(*FAIL)`, `(*COMMIT)`) influence the regex\n     * engine's behavior but do not consume characters. They effectively match an empty string.\n     * Returning a `LiteralSet` representing an empty string allows them to be correctly\n     * integrated into literal sequences.\n     *\n     * @param Node\\PcreVerbNode $node the `PcreVerbNode` representing a PCRE verb\n     *\n     * @return LiteralSet a `LiteralSet` representing an empty string\n     *\/\n    #[\\Override]\n    public function visitPcreVerb(Node\\PcreVerbNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    \/**\n     * Visits a DefineNode. DEFINE blocks do not yield fixed literals.\n     *\n     * Purpose: The `(?(DEFINE)...)` block is used to define named sub-patterns that\n     * are not matched directly but can be referenced by subroutines. Since this block\n     * itself does not match any text, it cannot contribute to a guaranteed literal string.\n     * It returns an empty `LiteralSet`.\n     *\n     * @param Node\\DefineNode $node The `DefineNode` representing a `(?(DEFINE)...)` block.\n     *\n     * @return LiteralSet an empty `LiteralSet`\n     *\/\n    #[\\Override]\n    public function visitDefine(Node\\DefineNode $node): LiteralSet\n    {\n        \/\/ DEFINE blocks don't produce any literal matches\n        return LiteralSet::empty();\n    }\n\n    #[\\Override]\n    public function visitLimitMatch(Node\\LimitMatchNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    #[\\Override]\n    public function visitCallout(Node\\CalloutNode $node): LiteralSet\n    {\n        \/\/ Callouts do not match characters, so they don't contribute to literal extraction.\n        return LiteralSet::fromString('');\n    }\n\n    \/**\n     * Generates case variants for a given string if case-insensitivity is active.\n     *\n     * Purpose: This private helper method is used when the regex is case-insensitive.\n     * It takes a literal string and generates all possible case permutations (e.g.,\n     * 'foo' -> ['foo', 'Foo', 'fOo', 'foO', 'FOo', 'fOO', 'FoO', 'FOO']).\n     * It includes a safety mechanism to limit the number of generated variants\n     * to prevent excessive memory usage for long strings.\n     *\n     * @param string $value the literal string to expand for case variations\n     *\n     * @return LiteralSet a `LiteralSet` containing all case variations of the input string\n     *\/\n    private function expandCaseInsensitive(string $value): LiteralSet\n    {\n        \/\/ Limit expansion length\n        if (\\strlen($value) > 8) {\n            return LiteralSet::empty(); \/\/ Too expensive to compute permutations\n        }\n\n        $results = [''];\n        for ($i = 0; $i < \\strlen($value); $i++) {\n            $char = $value[$i];\n            $lower = strtolower($char);\n            $upper = strtoupper($char);\n\n            $nextResults = [];\n            foreach ($results as $prefix) {\n                if ($lower === $upper) {\n                    $nextResults[] = $prefix.$char;\n                } else {\n                    $nextResults[] = $prefix.$lower;\n                    $nextResults[] = $prefix.$upper;\n                }\n            }\n            $results = $nextResults;\n        }\n\n        if (\\count($results) > self::MAX_LITERALS_COUNT) {\n            return LiteralSet::empty();\n        }\n\n        return new LiteralSet($results, $results, true);\n    }\n}\n",
    "Parser.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Exception\\RecursionLimitException;\nuse RegexParser\\Exception\\SyntaxErrorException;\n\n\/**\n * High-performance recursive descent parser for regex patterns.\n *\n * This optimized parser uses intelligent caching, reduced method calls, and\n * streamlined parsing logic for maximum performance while maintaining full\n * compatibility with PCRE syntax.\n *\/\nfinal class Parser\n{\n    private const INLINE_FLAG_CHARS = 'imsxADSUXJnr-';\n    private const MAX_RECURSION_DEPTH = 1024;\n\n    private TokenStream $stream;\n\n    private string $pattern = '';\n\n    private string $flags = '';\n\n    private bool $JModifier = false;\n\n    \/**\n     * @var array<string, bool>\n     *\/\n    private array $groupNames = [];\n\n    \/\/ Performance optimizations\n    private ?Token $currentToken = null;\n\n    private bool $currentTokenValid = false;\n\n    private int $lastPosition = -1;\n\n    \/\/ State tracking\n    private bool $lastTokenWasAlternation = false;\n\n    private int $lastInlineFlagsLength = 0;\n\n    private int $recursionDepth = 0;\n\n    public function parse(TokenStream $stream, string $flags = '', string $delimiter = '\/', int $patternLength = 0): Node\\RegexNode\n    {\n        $this->stream = $stream;\n        $this->pattern = $stream->getPattern();\n        $this->flags = $flags;\n        $this->JModifier = str_contains($flags, 'J');\n        $this->groupNames = [];\n        $this->lastTokenWasAlternation = false;\n        $this->lastInlineFlagsLength = 0;\n        $this->recursionDepth = 0;\n\n        \/\/ Reset performance caches\n        $this->currentToken = null;\n        $this->currentTokenValid = false;\n        $this->lastPosition = -1;\n\n        $patternNode = $this->parseAlternation();\n        $this->consume(TokenType::T_EOF, 'Unexpected content at end of pattern');\n\n        return new Node\\RegexNode($patternNode, $flags, $delimiter, 0, $patternLength);\n    }\n\n    private function parseAlternation(): Node\\NodeInterface\n    {\n        $this->guardRecursionDepth($this->current()->position);\n        $this->recursionDepth++;\n\n        try {\n            $startPosition = $this->current()->position;\n            $nodes = [$this->parseSequence()];\n\n            while ($this->match(TokenType::T_ALTERNATION)) {\n                $this->lastTokenWasAlternation = true;\n                $nodes[] = $this->parseSequence();\n            }\n\n            if (1 === \\count($nodes)) {\n                return $nodes[0];\n            }\n\n            $endPosition = end($nodes)->getEndPosition();\n\n            return new Node\\AlternationNode($nodes, $startPosition, $endPosition);\n        } finally {\n            $this->recursionDepth--;\n        }\n    }\n\n    private function parseSequence(): Node\\NodeInterface\n    {\n        $nodes = [];\n        $startPosition = $this->current()->position;\n\n        while (!$this->isAtEnd() && !$this->check(TokenType::T_GROUP_CLOSE) && !$this->check(TokenType::T_ALTERNATION)) {\n            if ($this->match(TokenType::T_QUOTE_MODE_START) || $this->match(TokenType::T_QUOTE_MODE_END)) {\n                continue;\n            }\n\n            if ($this->skipExtendedModeContent()) {\n                continue;\n            }\n\n            $nodes[] = $this->parseQuantifiedAtom();\n        }\n\n        if (empty($nodes)) {\n            return $this->createEmptyLiteralNodeAt($startPosition);\n        }\n\n        if (1 === \\count($nodes)) {\n            return $nodes[0];\n        }\n\n        $endPosition = end($nodes)->getEndPosition();\n\n        return new Node\\SequenceNode($nodes, $startPosition, $endPosition);\n    }\n\n    private function skipExtendedModeContent(): bool\n    {\n        if (!str_contains($this->flags, 'x')) {\n            return false;\n        }\n\n        $skipped = false;\n        while (!$this->isAtEnd() && !$this->check(TokenType::T_GROUP_CLOSE) && !$this->check(TokenType::T_ALTERNATION)) {\n            $token = $this->current();\n            if (TokenType::T_LITERAL !== $token->type) {\n                break;\n            }\n\n            if (ctype_space($token->value)) {\n                $this->advance();\n                $skipped = true;\n\n                continue;\n            }\n\n            if ('#' === $token->value) {\n                $this->advance();\n                while (!$this->isAtEnd() && \"\\n\" !== $this->current()->value) {\n                    $this->advance();\n                }\n                if (!$this->isAtEnd() && \"\\n\" === $this->current()->value) {\n                    $this->advance();\n                }\n                $skipped = true;\n\n                continue;\n            }\n\n            break;\n        }\n\n        return $skipped;\n    }\n\n    private function parseQuantifiedAtom(): Node\\NodeInterface\n    {\n        $node = $this->parseAtom();\n\n        $this->skipExtendedModeContent();\n\n        if ($this->match(TokenType::T_QUANTIFIER)) {\n            $token = $this->previous();\n\n            $this->assertQuantifierCanApply($node, $token);\n\n            [$quantifier, $type] = $this->parseQuantifierValue($token->value);\n\n            $startPosition = $node->getStartPosition();\n            $endPosition = $token->position + \\strlen($token->value);\n\n            return new Node\\QuantifierNode($node, $quantifier, $type, $startPosition, $endPosition);\n        }\n\n        return $node;\n    }\n\n    \/**\n     * @return array{0: string, 1: Node\\QuantifierType}\n     *\/\n    private function parseQuantifierValue(string $value): array\n    {\n        $lastChar = substr($value, -1);\n        $baseValue = substr($value, 0, -1);\n\n        if ('?' === $lastChar && \\strlen($value) > 1) {\n            return [$baseValue, Node\\QuantifierType::T_LAZY];\n        }\n\n        if ('+' === $lastChar && \\strlen($value) > 1) {\n            return [$baseValue, Node\\QuantifierType::T_POSSESSIVE];\n        }\n\n        return [$value, Node\\QuantifierType::T_GREEDY];\n    }\n\n    private function assertQuantifierCanApply(Node\\NodeInterface $node, Token $token): void\n    {\n        if ($this->isEmptyNode($node)) {\n            throw $this->parserException(\n                \\sprintf('Quantifier without target at position %d', $token->position),\n                $token->position,\n            );\n        }\n\n        if ($this->isAssertionNode($node)) {\n            $nodeName = $this->getAssertionNodeName($node);\n\n            throw $this->parserException(\n                \\sprintf('Quantifier \"%s\" cannot be applied to assertion or verb \"%s\" at position %d',\n                    $token->value, $nodeName, $node->getStartPosition()),\n                $token->position,\n            );\n        }\n    }\n\n    private function isEmptyNode(Node\\NodeInterface $node): bool\n    {\n        return ($node instanceof Node\\LiteralNode && '' === $node->value)\n            || ($node instanceof Node\\GroupNode && $this->isEmptyGroup($node))\n            || ($node instanceof Node\\SequenceNode && empty($node->children));\n    }\n\n    private function isAssertionNode(Node\\NodeInterface $node): bool\n    {\n        return $node instanceof Node\\AnchorNode\n            || $node instanceof Node\\AssertionNode\n            || $node instanceof Node\\PcreVerbNode\n            || $node instanceof Node\\KeepNode;\n    }\n\n    private function getAssertionNodeName(Node\\NodeInterface $node): string\n    {\n        return match (true) {\n            $node instanceof Node\\AnchorNode => $node->value,\n            $node instanceof Node\\AssertionNode => '\\\\'.$node->value,\n            $node instanceof Node\\PcreVerbNode => '(*'.$node->verb.')',\n            default => '\\K',\n        };\n    }\n\n    private function isEmptyGroup(Node\\GroupNode $node): bool\n    {\n        $child = $node->child;\n\n        return ($child instanceof Node\\LiteralNode && '' === $child->value)\n            || ($child instanceof Node\\SequenceNode && empty($child->children));\n    }\n\n    private function parseAtom(): Node\\NodeInterface\n    {\n        $token = $this->current();\n        $startPosition = $token->position;\n\n        if ($this->match(TokenType::T_COMMENT_OPEN)) {\n            return $this->parseComment();\n        }\n\n        if ($this->match(TokenType::T_CALLOUT)) {\n            return $this->parseCallout();\n        }\n\n        if ($this->match(TokenType::T_QUOTE_MODE_START) || $this->match(TokenType::T_QUOTE_MODE_END)) {\n            return $this->parseAtom();\n        }\n\n        if (null !== $node = $this->parseSimpleAtom($startPosition)) {\n            return $node;\n        }\n\n        if (null !== $node = $this->parseGroupOrCharClassAtom()) {\n            return $node;\n        }\n\n        if (null !== $node = $this->parseVerbAtom($startPosition)) {\n            return $node;\n        }\n\n        if ($this->check(TokenType::T_QUANTIFIER)) {\n            throw $this->parserException(\n                \\sprintf('Quantifier without target at position %d', $this->current()->position),\n                $this->current()->position,\n            );\n        }\n\n        $val = $this->current()->value;\n        $type = $this->current()->type->value;\n\n        throw $this->parserException(\n            \\sprintf('Unexpected token \"%s\" (%s) at position %d.', $val, $type, $startPosition),\n            $startPosition,\n        );\n    }\n\n    private function parseSimpleAtom(int $startPosition): ?Node\\NodeInterface\n    {\n        if ($this->match(TokenType::T_LITERAL)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + \\strlen($token->value);\n\n            return new Node\\LiteralNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_LITERAL_ESCAPED)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + \\strlen($token->value) + 1; \/\/ +1 for the backslash\n\n            return new Node\\LiteralNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_CHAR_TYPE)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + \\strlen($token->value) + 1; \/\/ +1 for the backslash\n\n            return new Node\\CharTypeNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_DOT)) {\n            return new Node\\DotNode($startPosition, $startPosition + 1);\n        }\n\n        if ($this->match(TokenType::T_ANCHOR)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + \\strlen($token->value);\n\n            return new Node\\AnchorNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_ASSERTION)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + \\strlen($token->value) + 1;\n\n            return new Node\\AssertionNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_BACKREF)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + \\strlen($token->value);\n\n            return new Node\\BackrefNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_G_REFERENCE)) {\n            return $this->parseGReference($startPosition);\n        }\n\n        if ($this->match(TokenType::T_UNICODE)) {\n            return $this->createCharLiteralNodeFromToken($this->previous(), TokenType::T_UNICODE, $startPosition);\n        }\n\n        if ($this->match(TokenType::T_UNICODE_NAMED)) {\n            return $this->createCharLiteralNodeFromToken(\n                $this->previous(),\n                TokenType::T_UNICODE_NAMED,\n                $startPosition,\n            );\n        }\n\n        if ($this->match(TokenType::T_CONTROL_CHAR)) {\n            $token = $this->previous();\n            $endPosition = $startPosition + 3; \/\/ \\cM\n\n            return new Node\\ControlCharNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_OCTAL)) {\n            return $this->createCharLiteralNodeFromToken($this->previous(), TokenType::T_OCTAL, $startPosition);\n        }\n\n        if ($this->match(TokenType::T_OCTAL_LEGACY)) {\n            return $this->createCharLiteralNodeFromToken(\n                $this->previous(),\n                TokenType::T_OCTAL_LEGACY,\n                $startPosition,\n            );\n        }\n\n        if ($this->match(TokenType::T_UNICODE_PROP)) {\n            $token = $this->previous();\n            \/\/ Calculate end pos based on original syntax (\\p{L} vs \\pL)\n            $len = 2 + \\strlen($token->value); \/\/ \\p or \\P + value\n            if (\\strlen($token->value) > 1 || str_starts_with($token->value, '^')) {\n                $len += 2; \/\/ for {}\n            }\n            $endPosition = $startPosition + $len;\n\n            return new Node\\UnicodePropNode($token->value, $startPosition, $endPosition);\n        }\n\n        if ($this->match(TokenType::T_KEEP)) {\n            return new Node\\KeepNode($startPosition, $startPosition + 2); \/\/ \\K\n        }\n\n        return null;\n    }\n\n    \/**\n     * Transforms a stream of Tokens into an Abstract Syntax Tree (AST).\n     * Implements a Recursive Descent Parser based on PCRE grammar.\n     *\/\n    private function parseGroupOrCharClassAtom(): ?Node\\NodeInterface\n    {\n        if ($this->match(TokenType::T_GROUP_OPEN)) {\n            $startToken = $this->previous();\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_CAPTURING,\n                $startToken->position,\n                $endToken,\n            );\n        }\n\n        if ($this->match(TokenType::T_GROUP_MODIFIER_OPEN)) {\n            return $this->parseGroupModifier();\n        }\n\n        if ($this->match(TokenType::T_CHAR_CLASS_OPEN)) {\n            return $this->parseCharClass();\n        }\n\n        return null;\n    }\n\n    private function parseVerbAtom(int $startPosition): ?Node\\NodeInterface\n    {\n        if (!$this->match(TokenType::T_PCRE_VERB)) {\n            return null;\n        }\n\n        $token = $this->previous();\n        $endPosition = $startPosition + \\strlen($token->value) + 3; \/\/ +3 for \"(*)\"\n\n        return new Node\\PcreVerbNode($token->value, $startPosition, $endPosition);\n    }\n\n    \/**\n     * parses callouts like (?C1), (?C\"name\"), (?C\"string\"), and (?Cname)\n     *\/\n    private function parseCallout(): Node\\CalloutNode\n    {\n        $token = $this->previous();\n        $startPosition = $token->position;\n        $value = $token->value;\n        $endPosition = $startPosition + \\strlen($token->value) + 4; \/\/ for (?C)\n\n        $isStringIdentifier = false;\n        $identifier = null;\n        if (preg_match('\/^\"([^\"]*+)\"$\/', $value, $matches)) {\n            $identifier = $matches[1];\n            $isStringIdentifier = true;\n        } elseif (ctype_digit($value)) {\n            $identifier = (int) $value;\n        } elseif (preg_match('\/^[a-zA-Z_][a-zA-Z0-9_]*+$\/', $value)) {\n            $identifier = $value;\n        } else {\n            throw $this->parserException(\n                \\sprintf('Invalid callout argument: %s at position %d', $value, $startPosition),\n                $startPosition,\n            );\n        }\n\n        return new Node\\CalloutNode($identifier, $isStringIdentifier, $startPosition, $endPosition);\n    }\n\n    \/**\n     * parses \\g references (backreferences and subroutines)\n     *\/\n    private function parseGReference(int $startPosition): Node\\NodeInterface\n    {\n        $token = $this->previous();\n        $value = $token->value;\n        $endPosition = $startPosition + \\strlen($value);\n\n        \/\/ \\g{N} or \\gN (numeric, incl. relative) -> Backreference\n        if (preg_match('\/^\\\\\\\\g\\{?([0-9+-]++)\\}?$\/', $value, $m)) {\n            return new Node\\BackrefNode($value, $startPosition, $endPosition);\n        }\n\n        \/\/ \\g<name> or \\g{name} (non-numeric) -> Subroutine\n        if (\n            preg_match('\/^\\\\\\\\g<(\\w++)>$\/', $value, $m)\n            || preg_match('\/^\\\\\\\\g\\{(\\w++)\\}$\/', $value, $m)\n        ) {\n            return new Node\\SubroutineNode($m[1], 'g', $startPosition, $endPosition);\n        }\n\n        throw $this->parserException(\n            \\sprintf('Invalid \\\\g reference syntax: %s at position %d', $value, $token->position),\n            $token->position,\n        );\n    }\n\n    \/**\n     * parses comments like (?# this is a comment )\n     *\/\n    private function parseComment(): Node\\CommentNode\n    {\n        $startToken = $this->previous(); \/\/ (?#\n        $startPosition = $startToken->position;\n\n        $comment = '';\n        while (\n            !$this->isAtEnd()\n            && !$this->check(TokenType::T_GROUP_CLOSE)\n        ) {\n            $token = $this->current();\n            $comment .= $this->reconstructTokenValue($token);\n            $this->advance();\n        }\n\n        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close comment');\n        $endPosition = $endToken->position + 1;\n\n        return new Node\\CommentNode($comment, $startPosition, $endPosition);\n    }\n\n    \/**\n     * Reconstructs the original string representation of a token.\n     *\/\n    private function reconstructTokenValue(Token $token): string\n    {\n        return match ($token->type) {\n            \/\/ Simple literals\n            TokenType::T_LITERAL,\n            TokenType::T_NEGATION,\n            TokenType::T_RANGE,\n            TokenType::T_DOT,\n            TokenType::T_GROUP_OPEN,\n            TokenType::T_GROUP_CLOSE,\n            TokenType::T_CHAR_CLASS_OPEN,\n            TokenType::T_CHAR_CLASS_CLOSE,\n            TokenType::T_QUANTIFIER,\n            TokenType::T_ALTERNATION,\n            TokenType::T_ANCHOR => $token->value,\n\n            \/\/ Types that had a \\ stripped\n            TokenType::T_CHAR_TYPE,\n            TokenType::T_ASSERTION,\n            TokenType::T_KEEP,\n            TokenType::T_OCTAL_LEGACY,\n            TokenType::T_LITERAL_ESCAPED => '\\\\'.$token->value,\n\n            \/\/ Types that kept their \\\n            TokenType::T_BACKREF,\n            TokenType::T_G_REFERENCE,\n            TokenType::T_UNICODE => $token->value,\n            TokenType::T_UNICODE_NAMED => '\\\\N{'.$token->value.'}',\n            TokenType::T_OCTAL => $token->value,\n\n            \/\/ Complex re-assembly\n            TokenType::T_CALLOUT => '(?C'.$token->value.')',\n            TokenType::T_UNICODE_PROP => str_starts_with($token->value, '{')\n                ? '\\p'.$token->value\n                : ((\\strlen($token->value) > 1 || str_starts_with($token->value, '^'))\n                    ? '\\p{'.$token->value.'}'\n                    : '\\p'.$token->value),\n            TokenType::T_POSIX_CLASS => '[[:'.$token->value.':]]',\n            TokenType::T_PCRE_VERB => '(*'.$token->value.')',\n            TokenType::T_GROUP_MODIFIER_OPEN => '(?',\n            TokenType::T_COMMENT_OPEN => '(?#',\n            TokenType::T_QUOTE_MODE_START => '\\Q',\n            TokenType::T_QUOTE_MODE_END => '\\E',\n            TokenType::T_CONTROL_CHAR => '\\\\c'.$token->value,\n            TokenType::T_CLASS_INTERSECTION => '&&',\n            TokenType::T_CLASS_SUBTRACTION => '--',\n\n            \/\/ Should not be encountered here\n            TokenType::T_EOF => '',\n        };\n    }\n\n    private function createCharLiteralNodeFromToken(Token $token, TokenType $type, int $startPosition): Node\\CharLiteralNode\n    {\n        [$representation, $charType] = match ($type) {\n            TokenType::T_UNICODE => [$token->value, Node\\CharLiteralType::UNICODE],\n            TokenType::T_UNICODE_NAMED => ['\\\\N{'.$token->value.'}', Node\\CharLiteralType::UNICODE_NAMED],\n            TokenType::T_OCTAL => [$token->value, Node\\CharLiteralType::OCTAL],\n            TokenType::T_OCTAL_LEGACY => ['\\\\'.$token->value, Node\\CharLiteralType::OCTAL_LEGACY],\n            default => throw new \\InvalidArgumentException('Unsupported character literal token type.'),\n        };\n\n        return new Node\\CharLiteralNode(\n            $representation,\n            $this->parseCharLiteralCodePoint($representation, $charType),\n            $charType,\n            $startPosition,\n            $startPosition + \\strlen($representation),\n        );\n    }\n\n    private function parseCharLiteralCodePoint(string $representation, Node\\CharLiteralType $type): int\n    {\n        return match ($type) {\n            Node\\CharLiteralType::UNICODE => $this->parseUnicodeCodePoint($representation),\n            Node\\CharLiteralType::UNICODE_NAMED => $this->parseNamedUnicodeCodePoint($representation),\n            Node\\CharLiteralType::OCTAL,\n            Node\\CharLiteralType::OCTAL_LEGACY => $this->parseOctalCodePoint($representation),\n        };\n    }\n\n    private function parseUnicodeCodePoint(string $representation): int\n    {\n        if (preg_match('\/^\\\\\\\\x([0-9a-fA-F]{2})$\/', $representation, $matches)) {\n            return (int) hexdec($matches[1]);\n        }\n\n        if (preg_match('\/^\\\\\\\\[xu]\\\\{([0-9a-fA-F]++)\\\\}$\/', $representation, $matches)) {\n            return (int) hexdec($matches[1]);\n        }\n\n        return -1;\n    }\n\n    private function parseNamedUnicodeCodePoint(string $representation): int\n    {\n        if (!preg_match('\/^\\\\\\\\N\\\\{(.+)}$\/', $representation, $matches)) {\n            return -1;\n        }\n\n        $name = $matches[1];\n        if (class_exists(\\IntlChar::class)) {\n            $char = \\IntlChar::charFromName($name);\n            if (null !== $char) {\n                return (int) \\IntlChar::ord($char);\n            }\n        }\n\n        return -1;\n    }\n\n    private function parseOctalCodePoint(string $representation): int\n    {\n        if (preg_match('\/^\\\\\\\\o\\\\{([0-7]++)\\\\}$\/', $representation, $matches)) {\n            return (int) octdec($matches[1]);\n        }\n\n        if (preg_match('\/^\\\\\\\\([0-7]{1,3})$\/', $representation, $matches)) {\n            return (int) octdec($matches[1]);\n        }\n\n        return -1;\n    }\n\n    \/**\n     * parses group modifiers like (?=...), (?!...), (?<=...), (?<!...), (?P<name>...), (?P'name'...), (?:...), (?(...)), (?&name), (?R), (?1), (?-1), (?0), and inline flags.\n     *\/\n    private function parseGroupModifier(): Node\\NodeInterface\n    {\n        $startToken = $this->previous(); \/\/ (?\n        $startPosition = $startToken->position;\n\n        \/\/ 1. Check for Python-style 'P' groups\n        $pPos = $this->current()->position;\n        if ($this->matchLiteral('P')) {\n            return $this->parsePythonGroup($startPosition, $pPos);\n        }\n\n        \/\/ 2. Check for standard lookarounds and named groups\n        if ($this->matchLiteral('<')) {\n            return $this->parseStandardGroup($startPosition);\n        }\n\n        \/\/ 3. Check for conditional (?(...)\n        $isConditionalWithModifier = null;\n        if ($this->match(TokenType::T_GROUP_MODIFIER_OPEN)) {\n            $isConditionalWithModifier = true;\n        } elseif ($this->match(TokenType::T_GROUP_OPEN)) {\n            $isConditionalWithModifier = false;\n        }\n\n        if (null !== $isConditionalWithModifier) {\n            return $this->parseConditional($startPosition, $isConditionalWithModifier);\n        }\n\n        \/\/ 4. Check for Subroutines\n        if ($this->matchLiteral('&')) { \/\/ (?&name)\n            $name = $this->parseSubroutineName();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close subroutine call');\n\n            return new Node\\SubroutineNode($name, '&', $startPosition, $endToken->position + 1);\n        }\n\n        if ($this->matchLiteral('R')) { \/\/ (?R)\n            if ($this->check(TokenType::T_GROUP_CLOSE)) {\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return new Node\\SubroutineNode('R', '', $startPosition, $endToken->position + 1);\n            }\n            $this->stream->rewind(1); \/\/ Rewind 'R'\n        }\n\n        \/\/ Check for (?1), (?-1), (?0)\n        if ($subroutine = $this->parseNumericSubroutine($startPosition)) {\n            return $subroutine;\n        }\n\n        \/\/ 5. Check for simple non-capturing, lookaheads, atomic, branch reset\n        if ($this->matchLiteral(':')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_NON_CAPTURING,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        if ($this->matchLiteral('=')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        if ($this->matchLiteral('!')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        if ($this->matchLiteral('>')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_ATOMIC,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        if ($this->match(TokenType::T_ALTERNATION)) {\n            \/\/ Branch reset group (?|...)\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_BRANCH_RESET,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        \/\/ 6. Inline flags\n        return $this->parseInlineFlags($startPosition);\n    }\n\n    \/**\n     * Parses Python-style named groups and subroutines like\n     * (?P'name'...), (?P\"name\"...), (?P<name>...), (?P>name), and (?P=name).\n     *\/\n    private function parsePythonGroup(int $startPos, int $pPos): Node\\NodeInterface\n    {\n        \/\/ Check for (?P'name'...) or (?P\"name\"...)\n        if ($this->checkLiteral(\"'\") || $this->checkLiteral('\"')) {\n            $quote = $this->current()->value;\n            $this->advance();\n\n            \/\/ Consume T_LITERAL tokens to build the name character by character\n            $name = '';\n            while (\n                !$this->isAtEnd()\n                && !$this->checkLiteral($quote)\n            ) {\n                if ($this->check(TokenType::T_LITERAL)) {\n                    $name .= $this->current()->value;\n                    $this->advance();\n                } else {\n                    if ($this->check(TokenType::T_GROUP_CLOSE)) {\n                        break;\n                    }\n\n                    throw $this->parserException(\n                        \\sprintf('Unexpected token in group name at position %d', $this->current()->position),\n                        $this->current()->position,\n                    );\n                }\n            }\n\n            if ('' === $name) {\n                throw $this->parserException(\n                    \\sprintf('Expected group name at position %d', $this->current()->position),\n                    $this->current()->position,\n                );\n            }\n\n            if (!$this->checkLiteral($quote)) {\n                throw $this->parserException(\n                    \\sprintf('Expected closing quote %s at position %d', $quote, $this->current()->position),\n                    $this->current()->position,\n                );\n            }\n            $this->advance();\n\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_NAMED,\n                $startPos,\n                $endToken,\n                $name,\n            );\n        }\n\n        if ($this->matchLiteral('<')) { \/\/ (?P<name>...)\n            $name = $this->parseGroupName($pPos);\n            $this->consumeLiteral('>', 'Expected > after group name');\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_NAMED,\n                $startPos,\n                $endToken,\n                $name,\n            );\n        }\n\n        if ($this->matchLiteral('>')) { \/\/ (?P>name) subroutine\n            $name = $this->parseSubroutineName();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close subroutine call');\n\n            return new Node\\SubroutineNode($name, 'P>', $startPos, $endToken->position + 1);\n        }\n\n        if ($this->matchLiteral('=')) {\n            throw $this->parserException(\n                'Backreferences (?P=name) are not supported yet.',\n                $this->current()->position,\n            );\n        }\n\n        throw $this->parserException(\n            \\sprintf('Invalid syntax after (?P at position %d', $pPos),\n            $pPos,\n        );\n    }\n\n    \/**\n     * Parses standard groups like (?<=...), (?<!...), and (?<name>...).\n     *\/\n    private function parseStandardGroup(int $startPos): Node\\NodeInterface\n    {\n        if ($this->matchLiteral('=')) { \/\/ (?<=...)\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n                $startPos,\n                $endToken,\n            );\n        }\n\n        if ($this->matchLiteral('!')) { \/\/ (?<!...)\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n                $startPos,\n                $endToken,\n            );\n        }\n\n        \/\/ (?<name>...)\n        $name = $this->parseGroupName($startPos);\n        $this->consumeLiteral('>', 'Expected > after group name');\n        $expr = $this->parseAlternation();\n        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n        return $this->createGroupNode(\n            $expr,\n            Node\\GroupType::T_GROUP_NAMED,\n            $startPos,\n            $endToken,\n            $name,\n        );\n    }\n\n    \/**\n     * Parses numeric subroutine calls like (?1), (?-1), (?0).\n     *\/\n    private function parseNumericSubroutine(int $startPos): ?Node\\SubroutineNode\n    {\n        $num = '';\n        if ($this->matchLiteral('-')) {\n            $num = '-';\n        }\n        if ($this->isLiteralDigitToken()) {\n            $num .= $this->current()->value;\n            $this->advance();\n            $num .= $this->consumeWhile(static fn (string $c): bool => ctype_digit($c));\n\n            if ($this->check(TokenType::T_GROUP_CLOSE)) {\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return new Node\\SubroutineNode($num, '', $startPos, $endToken->position + 1);\n            }\n            $this->stream->rewind(\\strlen($num));\n        } elseif ('-' === $num) {\n            $this->stream->rewind(1);\n        }\n\n        return null;\n    }\n\n    \/**\n     * Parses inline flags and optional sub-expressions (?(?flags:...)).\n     *\/\n    private function parseInlineFlags(int $startPosition): Node\\NodeInterface\n    {\n        \/\/ Support all PCRE2 flags including n (NO_AUTO_CAPTURE), r (unicode restricted), and ^ (unset)\n        \/\/ Handle ^ (T_ANCHOR) at the start - it means \"unset all flags\" in PCRE2\n        $flags = '';\n        if ($this->check(TokenType::T_ANCHOR) && '^' === $this->current()->value) {\n            $flags = '^';\n            $this->advance();\n        }\n        $flags .= $this->consumeWhile(\n            static fn (string $c): bool => str_contains(self::INLINE_FLAG_CHARS, $c),\n        );\n\n        if ('' !== $flags) {\n            [$setFlags, $unsetFlags] = str_contains($flags, '-')\n                ? explode('-', $flags, 2)\n                : [$flags, ''];\n\n            if (str_contains($setFlags, 'J')) {\n                $this->JModifier = true;\n            }\n            if (str_contains($unsetFlags, 'J')) {\n                $this->JModifier = false;\n            }\n\n            $expr = null;\n            if ($this->matchLiteral(':')) {\n                $expr = $this->parseAlternation();\n            }\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            if (null === $expr) {\n                $expr = $this->createEmptyLiteralNodeAt($this->previous()->position);\n            }\n\n            $this->lastInlineFlagsLength = ($endToken->position + 1) - $startPosition;\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_INLINE_FLAGS,\n                $startPosition,\n                $endToken,\n                null,\n                $flags,\n            );\n        }\n\n        throw $this->parserException(\n            \\sprintf('Invalid group modifier syntax at position %d', $startPosition),\n            $startPosition,\n        );\n    }\n\n    \/**\n     * Parses conditional constructs (?(condition)...).\n     *\/\n    private function parseConditional(int $startPosition, bool $isModifier): Node\\ConditionalNode|Node\\DefineNode\n    {\n        if ($isModifier) {\n            \/\/ Inline Lookaround condition\n            $conditionStartPos = $this->previous()->position;\n            $condition = $this->parseLookaroundCondition($conditionStartPos);\n        } else {\n            $condition = $this->parseConditionalCondition();\n            $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) after condition');\n        }\n\n        $yes = $this->parseAlternation();\n\n        \/\/ Special case: (?(DEFINE)...) creates a DefineNode instead of ConditionalNode\n        if ($condition instanceof Node\\AssertionNode && 'DEFINE' === $condition->value) {\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n            $endPosition = $endToken->position + 1;\n\n            return new Node\\DefineNode($yes, $startPosition, $endPosition);\n        }\n\n        $no = null;\n        $yesBranch = $yes;\n        if ($yes instanceof Node\\AlternationNode && \\count($yes->alternatives) > 1) {\n            $yesBranch = $yes->alternatives[0];\n            $noAlternatives = \\array_slice($yes->alternatives, 1);\n            if (1 === \\count($noAlternatives)) {\n                $no = $noAlternatives[0];\n            } else {\n                $lastAlt = $noAlternatives[\\count($noAlternatives) - 1];\n                $no = new Node\\AlternationNode(\n                    $noAlternatives,\n                    $noAlternatives[0]->getStartPosition(),\n                    $lastAlt->getEndPosition(),\n                );\n            }\n        }\n\n        if (null === $no) {\n            $no = $this->createEmptyLiteralNodeAt($this->current()->position);\n        }\n\n        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n        $endPosition = $endToken->position + 1;\n\n        return new Node\\ConditionalNode($condition, $yesBranch, $no, $startPosition, $endPosition);\n    }\n\n    \/**\n     * Parses lookaround conditions inside conditional constructs (?(?=...)...).\n     *\/\n    private function parseLookaroundCondition(int $startPosition): Node\\NodeInterface\n    {\n        if ($this->matchLiteral('=')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        if ($this->matchLiteral('!')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return $this->createGroupNode(\n                $expr,\n                Node\\GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n                $startPosition,\n                $endToken,\n            );\n        }\n\n        if ($this->matchLiteral('<')) {\n            \/\/ @phpstan-ignore-next-line if.alwaysFalse (false positive: position advanced after matching '<')\n            if ($this->matchLiteral('=')) {\n                $expr = $this->parseAlternation();\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return $this->createGroupNode(\n                    $expr,\n                    Node\\GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n                    $startPosition,\n                    $endToken,\n                );\n            }\n            \/\/ @phpstan-ignore-next-line if.alwaysFalse (false positive: position advanced after matching '<')\n            if ($this->matchLiteral('!')) {\n                $expr = $this->parseAlternation();\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return $this->createGroupNode(\n                    $expr,\n                    Node\\GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n                    $startPosition,\n                    $endToken,\n                );\n            }\n        }\n\n        throw $this->parserException(\n            'Invalid conditional condition at position '.$startPosition,\n            $startPosition,\n        );\n    }\n\n    \/**\n     * Parses the condition part of a conditional construct (?(condition)...).\n     *\/\n    private function parseConditionalCondition(): Node\\NodeInterface\n    {\n        $startPosition = $this->current()->position;\n\n        \/\/ This handles the PCRE feature where (?(DEFINE)...) allows defining subroutines\n        \/\/ without matching them immediately.\n        \/\/ We need to check for 'DEFINE' by peeking at multiple tokens since the lexer\n        \/\/ tokenizes each character separately.\n        if ($this->check(TokenType::T_LITERAL) && 'D' === $this->current()->value) {\n            $savedPos = $this->stream->getPosition();\n            $word = '';\n            while ($this->isLiteralAlphaToken()) {\n                $word .= $this->current()->value;\n                $this->advance();\n            }\n            if ('DEFINE' === $word && $this->check(TokenType::T_GROUP_CLOSE)) {\n                return new Node\\AssertionNode('DEFINE', $startPosition, $this->current()->position);\n            }\n            \/\/ Not DEFINE, restore position\n            $this->stream->setPosition($savedPos);\n        }\n\n        if ($this->isLiteralDigitToken()) {\n            $this->advance();\n            $num = (string) ($this->previous()->value.$this->consumeWhile(\n                static fn (string $c): bool => ctype_digit($c),\n            ));\n\n            return new Node\\BackrefNode($num, $startPosition, $this->current()->position);\n        }\n\n        if ($this->matchLiteral('<') || $this->matchLiteral('{')) {\n            $open = $this->previous()->value;\n            $name = $this->parseGroupName($startPosition, false);\n            $close = '<' === $open ? '>' : '}';\n            $this->consumeLiteral($close, \"Expected $close after condition name\");\n\n            return new Node\\BackrefNode($name, $startPosition, $this->current()->position);\n        }\n\n        if ($this->matchLiteral('R')) {\n            $endPosition = $this->previous()->position;\n            $numericPart = '';\n            $sawMinus = false;\n\n            if ($this->checkLiteral('-')) {\n                $sawMinus = true;\n                $this->advance();\n            }\n\n            $digits = $this->consumeWhile(static fn (string $c): bool => ctype_digit($c));\n            if ('' !== $digits) {\n                $numericPart = ($sawMinus ? '-' : '').$digits;\n                $endPosition = $this->previous()->position;\n            } elseif ($sawMinus) {\n                $this->stream->rewind(1);\n            }\n\n            $reference = 'R'.$numericPart;\n\n            return new Node\\SubroutineNode($reference, '', $startPosition, $endPosition);\n        }\n\n        if ($this->matchLiteral('?')) {\n            \/\/ Lookaround condition inside (?(...))\n            return $this->parseLookaroundCondition($startPosition);\n        }\n\n        \/\/ Bare name check (for conditions like (?(name)...))\n        if ($this->check(TokenType::T_LITERAL)) {\n            $savedPos = $this->stream->getPosition();\n            $name = '';\n            while (\n                $this->check(TokenType::T_LITERAL)\n                && !$this->checkLiteral(')')\n                && !$this->isAtEnd()\n            ) {\n                $name .= $this->current()->value;\n                $this->advance();\n            }\n            if ('' !== $name && $this->check(TokenType::T_GROUP_CLOSE)) {\n                return new Node\\BackrefNode($name, $startPosition, $this->current()->position);\n            }\n            $this->stream->setPosition($savedPos);\n        }\n\n        $condition = $this->parseAtom();\n\n        if (\n            !(\n                $condition instanceof Node\\BackrefNode\n                || $condition instanceof Node\\GroupNode\n                || $condition instanceof Node\\AssertionNode\n                || $condition instanceof Node\\SubroutineNode\n            )\n        ) {\n            throw $this->parserException(\n                \\sprintf(\n                    'Invalid conditional construct at position %d. Condition must be a group reference, lookaround, or (DEFINE).',\n                    $startPosition,\n                ),\n                $startPosition,\n            );\n        }\n\n        return $condition;\n    }\n\n    \/**\n     * checks for duplicate group names and registers the name\n     *\/\n    private function checkAndRegisterGroupName(string $name, int $position): void\n    {\n        if (isset($this->groupNames[$name]) && !$this->JModifier) {\n            throw $this->parserException(\n                \\sprintf('Duplicate group name \"%s\" at position %d.', $name, $position),\n                $position,\n            );\n        }\n        $this->groupNames[$name] = true;\n    }\n\n    \/**\n     * parses a group name, handling quoted names and validating characters\n     *\/\n    private function parseGroupName(?int $errorPosition = null, bool $register = true): string\n    {\n        $quote = null;\n        $nameStartPosition = $errorPosition ?? $this->current()->position;\n\n        $adjustment = 0;\n        if ($this->lastInlineFlagsLength > 0) {\n            $adjustment = max(0, $this->lastInlineFlagsLength - 2);\n        } elseif ($this->lastTokenWasAlternation) {\n            $adjustment = 1;\n        }\n        $nameStartPosition = max(0, $nameStartPosition - $adjustment);\n        $this->lastTokenWasAlternation = false;\n        $this->lastInlineFlagsLength = 0;\n\n        \/\/ Check for quoted group name (Python-style: 'name' or \"name\")\n        if ($this->checkLiteral(\"'\") || $this->checkLiteral('\"')) {\n            $quote = $this->current()->value;\n            $this->advance();\n        }\n\n        $name = '';\n        while (\n            !$this->checkLiteral('>')\n            && !$this->checkLiteral('}')\n            && !$this->isAtEnd()\n        ) {\n            \/\/ If we're in quoted mode and hit the closing quote, stop collecting\n            if (null !== $quote && $this->checkLiteral($quote)) {\n                break;\n            }\n\n            if ($this->check(TokenType::T_GROUP_CLOSE)) {\n                break;\n            }\n\n            if ($this->check(TokenType::T_LITERAL) || $this->check(TokenType::T_LITERAL_ESCAPED)) {\n                $name .= $this->current()->value;\n                $this->advance();\n            } else {\n                throw $this->parserException(\n                    \\sprintf('Unexpected token \"%s\" in group name', $this->current()->value),\n                    $this->current()->position,\n                );\n            }\n        }\n\n        \/\/ If quoted, expect the closing quote\n        if (null !== $quote) {\n            if (!$this->checkLiteral($quote)) {\n                throw $this->parserException(\n                    \\sprintf(\n                        'Expected closing quote \"%s\" for group name at position %d',\n                        $quote,\n                        $this->current()->position,\n                    ),\n                    $this->current()->position,\n                );\n            }\n            $this->advance();\n        }\n\n        if ('' === $name) {\n            throw $this->parserException(\n                \\sprintf('Expected group name at position %d', $nameStartPosition),\n                $nameStartPosition,\n            );\n        }\n\n        if ($register) {\n            $this->checkAndRegisterGroupName($name, $nameStartPosition);\n        }\n\n        return $name;\n    }\n\n    \/**\n     * parses a character class, including its parts and negation\n     *\/\n    private function parseCharClass(): Node\\CharClassNode\n    {\n        $startToken = $this->previous();\n        $startPosition = $startToken->position;\n        $isNegated = $this->match(TokenType::T_NEGATION);\n        $parts = $this->parseClassExpression();\n\n        $endToken = $this->consume(TokenType::T_CHAR_CLASS_CLOSE, 'Expected \"]\" to close character class');\n\n        return new Node\\CharClassNode($parts, $isNegated, $startPosition, $endToken->position + 1);\n    }\n\n    \/**\n     * Parses a character class expression with intersection (&&) and subtraction (--) operations.\n     *\/\n    private function parseClassExpression(): Node\\NodeInterface\n    {\n        $left = $this->parseCharClassAlternation();\n\n        while ($this->check(TokenType::T_CLASS_INTERSECTION) || $this->check(TokenType::T_CLASS_SUBTRACTION)) {\n            $type = TokenType::T_CLASS_INTERSECTION === $this->current()->type ? Node\\ClassOperationType::INTERSECTION : Node\\ClassOperationType::SUBTRACTION;\n            $this->advance();\n            $right = $this->parseCharClassAlternation();\n            $left = new Node\\ClassOperationNode($type, $left, $right, $left->getStartPosition(), $right->getEndPosition());\n        }\n\n        return $left;\n    }\n\n    \/**\n     * Parses the alternation of character class parts (without operations).\n     *\/\n    private function parseCharClassAlternation(): Node\\NodeInterface\n    {\n        $parts = [];\n\n        while (\n            !$this->check(TokenType::T_CHAR_CLASS_CLOSE)\n            && !$this->check(TokenType::T_CLASS_INTERSECTION)\n            && !$this->check(TokenType::T_CLASS_SUBTRACTION)\n            && !$this->isAtEnd()\n        ) {\n            \/\/ Silent tokens inside char class\n            if (\n                $this->match(TokenType::T_QUOTE_MODE_START)\n                || $this->match(TokenType::T_QUOTE_MODE_END)\n            ) {\n                continue;\n            }\n            $parts[] = $this->parseCharClassPart();\n        }\n\n        if (empty($parts)) {\n            return $this->createEmptyLiteralNodeAt($this->current()->position);\n        }\n\n        if (1 === \\count($parts)) {\n            return $parts[0];\n        }\n\n        $start = $parts[0]->getStartPosition();\n        $end = $parts[\\count($parts) - 1]->getEndPosition();\n\n        return new Node\\AlternationNode($parts, $start, $end);\n    }\n\n    \/**\n     * parses a part of a character class, which can be a literal, range, char type, unicode property, etc\n     *\/\n    private function parseCharClassPart(): Node\\NodeInterface\n    {\n        $startToken = $this->current();\n        $startPosition = $startToken->position;\n        $startNode = null;\n\n        \/\/ Simplified matching logic for char class parts\n        if ($this->match(TokenType::T_LITERAL) || $this->match(TokenType::T_LITERAL_ESCAPED)) {\n            $token = $this->previous();\n            \/\/ Check for range validity\n            \/\/ +1 if escaped\n            $endPosition = $startPosition + \\strlen($token->value)\n                + (TokenType::T_LITERAL_ESCAPED === $token->type ? 1 : 0);\n            $startNode = new Node\\LiteralNode($token->value, $startPosition, $endPosition);\n        } elseif ($this->match(TokenType::T_CHAR_TYPE)) {\n            $token = $this->previous();\n            $startNode = new Node\\CharTypeNode(\n                $token->value,\n                $startPosition,\n                $startPosition + \\strlen($token->value) + 1,\n            );\n        } elseif ($this->match(TokenType::T_UNICODE_PROP)) {\n            $token = $this->previous();\n            \/\/ Basic length calc - Parser logic from original\n            $len = 2 + \\strlen($token->value)\n                + ((\\strlen($token->value) > 1 || str_starts_with($token->value, '^')) ? 2 : 0);\n            $startNode = new Node\\UnicodePropNode($token->value, $startPosition, $startPosition + $len);\n        } elseif ($this->match(TokenType::T_UNICODE)) {\n            $startNode = $this->createCharLiteralNodeFromToken(\n                $this->previous(),\n                TokenType::T_UNICODE,\n                $startPosition,\n            );\n        } elseif ($this->match(TokenType::T_OCTAL)) {\n            $startNode = $this->createCharLiteralNodeFromToken(\n                $this->previous(),\n                TokenType::T_OCTAL,\n                $startPosition,\n            );\n        } elseif ($this->match(TokenType::T_OCTAL_LEGACY)) {\n            $startNode = $this->createCharLiteralNodeFromToken(\n                $this->previous(),\n                TokenType::T_OCTAL_LEGACY,\n                $startPosition,\n            );\n        } elseif ($this->match(TokenType::T_RANGE)) {\n            \/\/ Literal hyphen at start\n            return new Node\\LiteralNode($this->previous()->value, $startPosition, $startPosition + 1);\n        } elseif ($this->match(TokenType::T_POSIX_CLASS)) {\n            $token = $this->previous();\n            $startNode = new Node\\PosixClassNode(\n                $token->value,\n                $startPosition,\n                $startPosition + \\strlen($token->value) + 4,\n            );\n        } else {\n            throw $this->parserException(\n                \\sprintf(\n                    'Unexpected token \"%s\" in character class at position %d.',\n                    $this->current()->value,\n                    $this->current()->position,\n                ),\n                $this->current()->position,\n            );\n        }\n\n        \/\/ Check for Range\n        if ($this->match(TokenType::T_RANGE)) {\n            if ($this->check(TokenType::T_CHAR_CLASS_CLOSE)) {\n                \/\/ Trailing hyphen\n                $this->stream->rewind(1);\n\n                return $startNode;\n            }\n\n            \/\/ Parse end node without allowing nested ranges\n            $endToken = $this->current();\n            $endPosition = $endToken->position;\n            $endNode = null;\n\n            if ($this->match(TokenType::T_LITERAL) || $this->match(TokenType::T_LITERAL_ESCAPED)) {\n                $token = $this->previous();\n                $endPosition = $endPosition + \\strlen($token->value)\n                    + (TokenType::T_LITERAL_ESCAPED === $token->type ? 1 : 0);\n                $endNode = new Node\\LiteralNode($token->value, $endPosition - \\strlen($token->value), $endPosition);\n            } elseif ($this->match(TokenType::T_CHAR_TYPE)) {\n                $token = $this->previous();\n                $endNode = new Node\\CharTypeNode(\n                    $token->value,\n                    $endPosition,\n                    $endPosition + \\strlen($token->value) + 1,\n                );\n            } elseif ($this->match(TokenType::T_UNICODE_PROP)) {\n                $token = $this->previous();\n                $len = 2 + \\strlen($token->value)\n                    + ((\\strlen($token->value) > 1 || str_starts_with($token->value, '^')) ? 2 : 0);\n                $endNode = new Node\\UnicodePropNode($token->value, $endPosition, $endPosition + $len);\n            } elseif ($this->match(TokenType::T_UNICODE)) {\n                $endNode = $this->createCharLiteralNodeFromToken(\n                    $this->previous(),\n                    TokenType::T_UNICODE,\n                    $endPosition,\n                );\n            } elseif ($this->match(TokenType::T_OCTAL)) {\n                $endNode = $this->createCharLiteralNodeFromToken(\n                    $this->previous(),\n                    TokenType::T_OCTAL,\n                    $endPosition,\n                );\n            } elseif ($this->match(TokenType::T_OCTAL_LEGACY)) {\n                $endNode = $this->createCharLiteralNodeFromToken(\n                    $this->previous(),\n                    TokenType::T_OCTAL_LEGACY,\n                    $endPosition,\n                );\n            } elseif ($this->match(TokenType::T_POSIX_CLASS)) {\n                $token = $this->previous();\n                $endNode = new Node\\PosixClassNode(\n                    $token->value,\n                    $endPosition,\n                    $endPosition + \\strlen($token->value) + 4,\n                );\n            } else {\n                throw $this->parserException(\n                    \\sprintf(\n                        'Unexpected token \"%s\" in character class range at position %d.',\n                        $this->current()->value,\n                        $this->current()->position,\n                    ),\n                    $this->current()->position,\n                );\n            }\n\n            return new Node\\RangeNode($startNode, $endNode, $startPosition, $endNode->getEndPosition());\n        }\n\n        return $startNode;\n    }\n\n    \/**\n     * parses a subroutine name consisting of alphanumeric characters and underscores\n     *\/\n    private function parseSubroutineName(): string\n    {\n        $name = '';\n        while (\n            !$this->check(TokenType::T_GROUP_CLOSE)\n            && !$this->isAtEnd()\n        ) {\n            if ($this->check(TokenType::T_LITERAL) || $this->check(TokenType::T_LITERAL_ESCAPED)) {\n                $char = $this->current()->value;\n                if (!preg_match('\/^[a-zA-Z0-9_]$\/', $char)) {\n                    throw $this->parserException(\n                        'Unexpected token in subroutine name: '.$char,\n                        $this->current()->position,\n                    );\n                }\n                $name .= $char;\n                $this->advance();\n            } else {\n                throw $this->parserException(\n                    'Unexpected token in subroutine name: '.$this->current()->value,\n                    $this->current()->position,\n                );\n            }\n        }\n        if ('' === $name) {\n            throw $this->parserException(\n                'Expected subroutine name at position '.$this->current()->position,\n                $this->current()->position,\n            );\n        }\n\n        return $name;\n    }\n\n    \/**\n     * creates a ParserException with context about the pattern being parsed\n     *\/\n    private function parserException(string $message, int $position): ParserException\n    {\n        return SyntaxErrorException::withContext($message, $position, $this->pattern);\n    }\n\n    private function guardRecursionDepth(int $position): void\n    {\n        if ($this->recursionDepth >= self::MAX_RECURSION_DEPTH) {\n            throw RecursionLimitException::withContext(\n                \\sprintf('Recursion limit of %d exceeded', self::MAX_RECURSION_DEPTH),\n                $position,\n                $this->pattern,\n            );\n        }\n    }\n\n    \/**\n     * @return bool true if the current token is a T_LITERAL and its value matches the given value\n     *\/\n    private function matchLiteral(string $value): bool\n    {\n        if ($this->checkLiteral($value)) {\n            $this->advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    \/**\n     * @return bool true if the current token is a T_LITERAL and its value matches the given value\n     *\/\n    private function checkLiteral(string $value): bool\n    {\n        if ($this->isAtEnd()) {\n            return false;\n        }\n        $token = $this->current();\n\n        return TokenType::T_LITERAL === $token->type && $token->value === $value;\n    }\n\n    \/**\n     * @return Token the consumed token\n     *\/\n    private function consume(TokenType $type, string $error): Token\n    {\n        if ($this->check($type)) {\n            $token = $this->current();\n            $this->advance();\n\n            return $token;\n        }\n        $at = $this->isAtEnd() ? 'end of input' : 'position '.$this->current()->position;\n\n        throw $this->parserException(\n            $error.' at '.$at.' (found '.$this->current()->type->value.')',\n            $this->current()->position,\n        );\n    }\n\n    \/**\n     * @return Token the consumed token\n     *\/\n    private function consumeLiteral(string $value, string $error): Token\n    {\n        if ($this->checkLiteral($value)) {\n            $token = $this->current();\n            $this->advance();\n\n            return $token;\n        }\n        $at = $this->isAtEnd() ? 'end of input' : 'position '.$this->current()->position;\n\n        throw $this->parserException(\n            $error.' at '.$at.' (found '.$this->current()->type->value.' with value '.$this->current()->value.')',\n            $this->current()->position,\n        );\n    }\n\n    \/**\n     * Creates an empty literal node (epsilon) at a given position.\n     *\/\n    private function createEmptyLiteralNodeAt(int $position): Node\\LiteralNode\n    {\n        return new Node\\LiteralNode('', $position, $position);\n    }\n\n    \/**\n     * Small factory for group nodes to keep argument ordering and end positions consistent.\n     *\/\n    private function createGroupNode(\n        Node\\NodeInterface $expr,\n        Node\\GroupType $type,\n        int $startPosition,\n        Token $endToken,\n        ?string $name = null,\n        ?string $flags = null\n    ): Node\\GroupNode {\n        return new Node\\GroupNode($expr, $type, $name, $flags, $startPosition, $endToken->position + 1);\n    }\n\n    \/**\n     * Optimized current token access with caching.\n     *\/\n    private function current(): Token\n    {\n        $currentPos = $this->stream->getPosition();\n\n        if ($this->currentTokenValid && $this->lastPosition === $currentPos) {\n            return $this->currentToken ?? $this->stream->current();\n        }\n\n        $this->currentToken = $this->stream->current();\n        $this->currentTokenValid = true;\n        $this->lastPosition = $currentPos;\n\n        return $this->currentToken;\n    }\n\n    \/**\n     * Optimized end-of-stream check.\n     *\/\n    private function isAtEnd(): bool\n    {\n        return $this->stream->isAtEnd();\n    }\n\n    \/**\n     * Optimized token type checking.\n     *\/\n    private function check(TokenType $type): bool\n    {\n        if ($this->isAtEnd()) {\n            return TokenType::T_EOF === $type;\n        }\n\n        return $this->current()->type === $type;\n    }\n\n    \/**\n     * Optimized token consumption with caching invalidation.\n     *\/\n    private function match(TokenType $type): bool\n    {\n        if (!$this->check($type)) {\n            return false;\n        }\n\n        $this->advance();\n\n        return true;\n    }\n\n    \/**\n     * Advance to next token and invalidate cache.\n     *\/\n    private function advance(): void\n    {\n        if (!$this->isAtEnd()) {\n            $this->stream->next();\n            $this->currentTokenValid = false;\n        }\n    }\n\n    \/**\n     * Check if current token is a literal digit.\n     *\/\n    private function isLiteralDigitToken(): bool\n    {\n        return $this->check(TokenType::T_LITERAL) && ctype_digit($this->current()->value);\n    }\n\n    \/**\n     * Get previous token with position management.\n     *\/\n    private function previous(): Token\n    {\n        if (0 === $this->stream->getPosition()) {\n            return new Token(TokenType::T_EOF, '', 0);\n        }\n\n        $savedPos = $this->stream->getPosition();\n        $this->stream->setPosition($savedPos - 1);\n        $token = $this->stream->current();\n        $this->stream->setPosition($savedPos);\n\n        return $token;\n    }\n\n    \/**\n     * @return bool true if the current token is a T_LITERAL and its value is an alphabetic character (a-z, A-Z)\n     *\/\n    private function isLiteralAlphaToken(): bool\n    {\n        return $this->check(TokenType::T_LITERAL) && ctype_alpha($this->current()->value);\n    }\n\n    \/**\n     * Consumes tokens while the predicate returns true, concatenating their values.\n     *\/\n    private function consumeWhile(callable $predicate): string\n    {\n        $value = '';\n\n        while (\n            !$this->isAtEnd()\n            && $this->check(TokenType::T_LITERAL)\n            && $predicate($this->current()->value)\n        ) {\n            $value .= $this->current()->value;\n            $this->advance();\n        }\n\n        return $value;\n    }\n}\n",
    "ValidationResult.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Outcome of a regex validation check.\n *\/\nfinal readonly class ValidationResult\n{\n    public function __construct(\n        public bool $isValid,\n        public ?string $error = null,\n        public int $complexityScore = 0,\n        public ?ValidationErrorCategory $category = null,\n        public ?int $offset = null,\n        public ?string $caretSnippet = null,\n        public ?string $hint = null,\n        public ?string $errorCode = null,\n    ) {}\n\n    public function isValid(): bool\n    {\n        return $this->isValid;\n    }\n\n    public function getErrorMessage(): ?string\n    {\n        return $this->error;\n    }\n\n    public function getComplexityScore(): int\n    {\n        return $this->complexityScore;\n    }\n\n    public function getErrorCategory(): ?ValidationErrorCategory\n    {\n        return $this->category;\n    }\n\n    public function getErrorOffset(): ?int\n    {\n        return $this->offset;\n    }\n\n    public function getCaretSnippet(): ?string\n    {\n        return $this->caretSnippet;\n    }\n\n    public function getHint(): ?string\n    {\n        return $this->hint;\n    }\n\n    public function getErrorCode(): ?string\n    {\n        return $this->errorCode;\n    }\n}\n",
    "Bridge\/PHPStan\/PregValidationRule.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\PHPStan;\n\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Expr\\Array_;\nuse PhpParser\\Node\\Expr\\ArrayItem;\nuse PhpParser\\Node\\Expr\\FuncCall;\nuse PhpParser\\Node\\Name;\nuse PhpParser\\Node\\Scalar\\String_;\nuse PHPStan\\Analyser\\Scope;\nuse PHPStan\\Rules\\IdentifierRuleError;\nuse PHPStan\\Rules\\Rule;\nuse PHPStan\\Rules\\RuleErrorBuilder;\nuse RegexParser\\Exception\\LexerException;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Exception\\SyntaxErrorException;\nuse RegexParser\\NodeVisitor\\ValidatorNodeVisitor;\nuse RegexParser\\ReDoS\\ReDoSAnalyzer;\nuse RegexParser\\ReDoS\\ReDoSSeverity;\nuse RegexParser\\Regex;\n\n\/**\n * Validates regex patterns in `preg_*` functions for syntax and ReDoS vulnerabilities.\n *\n * @implements Rule<FuncCall>\n *\/\nfinal class PregValidationRule implements Rule\n{\n    public const IDENTIFIER_SYNTAX_INVALID = 'regex.syntax.invalid';\n    public const IDENTIFIER_SYNTAX_DELIMITER = 'regex.syntax.delimiter';\n    public const IDENTIFIER_SYNTAX_EMPTY = 'regex.syntax.empty';\n    public const IDENTIFIER_REDOS_CRITICAL = 'regex.redos.critical';\n    public const IDENTIFIER_REDOS_HIGH = 'regex.redos.high';\n    public const IDENTIFIER_REDOS_MEDIUM = 'regex.redos.medium';\n    public const IDENTIFIER_REDOS_LOW = 'regex.redos.low';\n    public const IDENTIFIER_OPTIMIZATION = 'regex.optimization';\n\n    private const PREG_FUNCTION_MAP = [\n        'preg_match' => 0,\n        'preg_match_all' => 0,\n        'preg_replace' => 0,\n        'preg_replace_callback' => 0,\n        'preg_split' => 0,\n        'preg_grep' => 0,\n        'preg_filter' => 0,\n        'preg_replace_callback_array' => 0,\n    ];\n\n    private const DOC_BASE_URL = 'https:\/\/github.com\/yoeunes\/regex-parser\/blob\/master\/docs\/reference.md';\n\n    private const DOC_LINKS = [\n        \/\/ Flags - Use PHP.net where possible, or precise concept pages\n        'Flag \\'s\\' is useless' => self::DOC_BASE_URL.'#useless-flag-s-dotall',\n        'Flag \\'m\\' is useless' => self::DOC_BASE_URL.'#useless-flag-m-multiline',\n        'Flag \\'i\\' is useless' => self::DOC_BASE_URL.'#useless-flag-i-caseless',\n\n        \/\/ Security & Concepts - The authority on explaining regex mechanics\n        'catastrophic backtracking' => self::DOC_BASE_URL.'#catastrophic-backtracking',\n\n        \/\/ Advanced Syntax - Internal documentation\n        'possessive quantifiers' => self::DOC_BASE_URL.'#possessive-quantifiers',\n        'atomic groups' => self::DOC_BASE_URL.'#atomic-groups',\n\n        \/\/ Assertions\n        'lookahead' => self::DOC_BASE_URL.'#assertions',\n        'lookbehind' => self::DOC_BASE_URL.'#assertions',\n    ];\n\n    private const LINT_DOC_LINKS = [\n        'regex.lint.flag.useless.s' => self::DOC_BASE_URL.'#useless-flag-s-dotall',\n        'regex.lint.flag.useless.m' => self::DOC_BASE_URL.'#useless-flag-m-multiline',\n        'regex.lint.flag.useless.i' => self::DOC_BASE_URL.'#useless-flag-i-caseless',\n        'regex.lint.anchor.impossible.start' => self::DOC_BASE_URL.'#anchor-conflicts',\n        'regex.lint.anchor.impossible.end' => self::DOC_BASE_URL.'#anchor-conflicts',\n        'regex.lint.quantifier.nested' => self::DOC_BASE_URL.'#nested-quantifiers',\n        'regex.lint.dotstar.nested' => self::DOC_BASE_URL.'#dot-star-in-quantifier',\n        'regex.lint.group.redundant' => self::DOC_BASE_URL.'#redundant-non-capturing-group',\n        'regex.lint.alternation.duplicate' => self::DOC_BASE_URL.'#duplicate-alternation-branches',\n        'regex.lint.alternation.overlap' => self::DOC_BASE_URL.'#overlapping-alternation-branches',\n        'regex.lint.charclass.redundant' => self::DOC_BASE_URL.'#redundant-character-class-elements',\n        'regex.lint.escape.suspicious' => self::DOC_BASE_URL.'#suspicious-escapes',\n        'regex.lint.flag.redundant' => self::DOC_BASE_URL.'#inline-flag-redundant',\n        'regex.lint.flag.override' => self::DOC_BASE_URL.'#inline-flag-override',\n    ];\n\n    private ?Regex $regex = null;\n\n    private ?ValidatorNodeVisitor $validator = null;\n\n    private ?ReDoSAnalyzer $redosAnalyzer = null;\n\n    \/**\n     * @param bool                                                $ignoreParseErrors  Ignore parse errors for partial regex strings\n     * @param bool                                                $reportRedos        Report ReDoS vulnerability analysis\n     * @param string                                              $redosThreshold     Minimum ReDoS severity level to report\n     * @param array{digits: bool, word: bool, strictRanges: bool} $optimizationConfig\n     *\/\n    public function __construct(\n        private readonly bool $ignoreParseErrors = true,\n        private readonly bool $reportRedos = true,\n        private readonly string $redosThreshold = 'high',\n        private readonly bool $suggestOptimizations = false,\n        private readonly array $optimizationConfig = ['digits' => true, 'word' => true, 'strictRanges' => true],\n    ) {}\n\n    public function getNodeType(): string\n    {\n        return FuncCall::class;\n    }\n\n    public function processNode(Node $node, Scope $scope): array\n    {\n        \\assert($node instanceof FuncCall);\n\n        if (!$node->name instanceof Name) {\n            return [];\n        }\n\n        $functionName = $node->name->toLowerString();\n        if (!isset(self::PREG_FUNCTION_MAP[$functionName])) {\n            return [];\n        }\n\n        $patternArgPosition = self::PREG_FUNCTION_MAP[$functionName];\n        $args = $node->getArgs();\n\n        if (!isset($args[$patternArgPosition])) {\n            return [];\n        }\n\n        $patternArg = $args[$patternArgPosition]->value;\n\n        if ('preg_replace_callback_array' === $functionName) {\n            return $this->processPregReplaceCallbackArray($patternArg, $scope, $node->getLine());\n        }\n\n        $errors = [];\n        foreach ($scope->getType($patternArg)->getConstantStrings() as $constantString) {\n            $errors = array_merge($errors, $this->validatePattern($constantString->getValue(), $node->getLine()));\n        }\n\n        return $errors;\n    }\n\n    public function isOptimizationSafe(string $original, string $optimized): bool\n    {\n        \/\/ Extract delimiter, pattern part, and flags for optimized\n        $delimiter = $optimized[0] ?? '';\n        if ('' === $delimiter) {\n            return false; \/\/ Invalid\n        }\n\n        $lastDelimiterPos = strrpos($optimized, $delimiter);\n        if (false === $lastDelimiterPos || 0 === $lastDelimiterPos) {\n            return false; \/\/ No closing delimiter or empty\n        }\n\n        $patternPart = substr($optimized, 1, $lastDelimiterPos - 1);\n\n        \/\/ Extract original pattern part\n        $originalDelimiter = $original[0] ?? '';\n        $originalPatternPart = '';\n        if ('' !== $originalDelimiter) {\n            $originalLastPos = strrpos($original, $originalDelimiter);\n            if (false !== $originalLastPos) {\n                $originalPatternPart = substr($original, 1, $originalLastPos - 1);\n            }\n        }\n\n        \/\/ Return false if optimized pattern is empty\n        if ('' === $patternPart) {\n            return false;\n        }\n\n        \/\/ Return false if optimized pattern is too short (< 2 chars)\n        if (\\strlen($patternPart) < 2) {\n            return false;\n        }\n\n        \/\/ Return false if optimized removes newlines that were present in original (unless escaped)\n        \/\/ Simplified: check if original contains \\n and optimized does not\n        if (str_contains($originalPatternPart, '\\n') && !str_contains($patternPart, '\\n')) {\n            return false;\n        }\n\n        return true;\n    }\n\n    \/**\n     * @return list<IdentifierRuleError>\n     *\/\n    private function processPregReplaceCallbackArray(Node $arrayNode, Scope $scope, int $lineNumber): array\n    {\n        if (!$arrayNode instanceof Array_) {\n            return [];\n        }\n\n        $errors = [];\n        foreach ($arrayNode->items as $item) {\n            if (!$item instanceof ArrayItem || !$item->key instanceof String_) {\n                continue;\n            }\n\n            $pattern = $item->key->value;\n            $errors = array_merge($errors, $this->validatePattern($pattern, $lineNumber));\n        }\n\n        return $errors;\n    }\n\n    \/**\n     * @return list<IdentifierRuleError>\n     *\/\n    private function validatePattern(string $pattern, int $lineNumber): array\n    {\n        if ('' === $pattern) {\n            return [\n                RuleErrorBuilder::message('Regex pattern cannot be empty.')\n                    ->line($lineNumber)\n                    ->identifier(self::IDENTIFIER_SYNTAX_EMPTY)\n                    ->build(),\n            ];\n        }\n\n        $errors = [];\n\n        try {\n            $ast = $this->getRegex()->parse($pattern);\n            $ast->accept($this->getValidator());\n        } catch (LexerException|ParserException|SyntaxErrorException $e) {\n            if ($this->ignoreParseErrors && $this->isLikelyPartialRegexError($e->getMessage())) {\n                return [];\n            }\n\n            $shortPattern = $this->truncatePattern($pattern);\n            $errors[] = RuleErrorBuilder::message(\\sprintf('Regex syntax error: %s (Pattern: \"%s\")', $e->getMessage(), $shortPattern))\n                ->line($lineNumber)\n                ->identifier($this->getIdentifierForSyntaxError($e->getMessage()))\n                ->build();\n\n            return $errors;\n        }\n\n        if ($this->reportRedos) {\n            try {\n                $analysis = $this->getRedosAnalyzer()->analyze($pattern);\n\n                if ($this->exceedsThreshold($analysis->severity)) {\n                    $identifier = match ($analysis->severity) {\n                        ReDoSSeverity::CRITICAL => self::IDENTIFIER_REDOS_CRITICAL,\n                        ReDoSSeverity::HIGH => self::IDENTIFIER_REDOS_HIGH,\n                        ReDoSSeverity::MEDIUM => self::IDENTIFIER_REDOS_MEDIUM,\n                        default => self::IDENTIFIER_REDOS_LOW,\n                    };\n\n                    $errors[] = RuleErrorBuilder::message(\\sprintf(\n                        'ReDoS vulnerability detected (%s): %s',\n                        strtoupper($analysis->severity->value),\n                        $this->truncatePattern($pattern),\n                    ))\n                        ->line($lineNumber)\n                        ->tip($this->getTipForReDoS($analysis->recommendations))\n                        ->identifier($identifier)\n                        ->build();\n                }\n            } catch (\\Throwable) {\n            }\n        }\n\n        if ($this->suggestOptimizations) {\n            try {\n                $ast = $this->getRegex()->parse($pattern);\n                $optimizer = new \\RegexParser\\NodeVisitor\\OptimizerNodeVisitor(\n                    optimizeDigits: (bool) ($this->optimizationConfig['digits'] ?? true),\n                    optimizeWord: (bool) ($this->optimizationConfig['word'] ?? true),\n                    strictRanges: (bool) ($this->optimizationConfig['strictRanges'] ?? true),\n                );\n                $optimizedAst = $ast->accept($optimizer);\n                \/\/ Use compiler to get string back\n                $compiler = new \\RegexParser\\NodeVisitor\\CompilerNodeVisitor();\n                $optimized = $optimizedAst->accept($compiler);\n                if ($optimized !== $pattern && \\strlen($optimized) < \\strlen($pattern)) {\n                    \/\/ Safeguard: Validate that the optimized pattern is still valid\n                    try {\n                        $optimizedAst = $this->getRegex()->parse($optimized);\n                        $optimizedAst->accept($this->getValidator());\n                        \/\/ Additional heuristic checks\n                        if (!$this->isOptimizationSafe($pattern, $optimized)) {\n                            \/\/ Optimized pattern is unsafe, do not suggest it\n                        } else {\n                            \/\/ If we reach here, the optimized pattern is valid and safe\n                            $shortPattern = $this->truncatePattern($pattern);\n\n                            $errors[] = RuleErrorBuilder::message(\\sprintf('Regex pattern can be optimized: \"%s\"', $shortPattern))\n                                ->line($lineNumber)\n                                ->identifier(self::IDENTIFIER_OPTIMIZATION)\n                                ->tip(\\sprintf('Consider using: %s', $optimized))\n                                ->build();\n                        }\n                    } catch (LexerException|ParserException|SyntaxErrorException) {\n                        \/\/ Optimized pattern is invalid, do not suggest it\n                    }\n                }\n            } catch (\\Throwable) {\n            }\n        }\n\n        try {\n            $linter = new \\RegexParser\\NodeVisitor\\LinterNodeVisitor();\n            $ast->accept($linter);\n            foreach ($linter->getIssues() as $issue) {\n                $builder = RuleErrorBuilder::message($issue->message)\n                    ->line($lineNumber)\n                    ->identifier($issue->id);\n                $tipParts = [];\n                if (null !== $issue->hint) {\n                    $tipParts[] = $issue->hint;\n                }\n                if (isset(self::LINT_DOC_LINKS[$issue->id])) {\n                    $tipParts[] = 'Read more: '.self::LINT_DOC_LINKS[$issue->id];\n                }\n                if ([] !== $tipParts) {\n                    $builder = $builder->tip(implode(\"\\n\", $tipParts));\n                }\n                $errors[] = $builder->build();\n            }\n        } catch (\\Throwable) {\n        }\n\n        return $errors;\n    }\n\n    private function getIdentifierForSyntaxError(string $errorMessage): string\n    {\n        if (str_contains($errorMessage, 'delimiter')) {\n            return self::IDENTIFIER_SYNTAX_DELIMITER;\n        }\n\n        return self::IDENTIFIER_SYNTAX_INVALID;\n    }\n\n    private function exceedsThreshold(ReDoSSeverity $severity): bool\n    {\n        $currentLevel = match ($severity) {\n            ReDoSSeverity::SAFE => 0,\n            ReDoSSeverity::LOW => 1,\n            ReDoSSeverity::UNKNOWN => 2,\n            ReDoSSeverity::MEDIUM => 3,\n            ReDoSSeverity::HIGH => 4,\n            ReDoSSeverity::CRITICAL => 5,\n        };\n\n        $thresholdLevel = match ($this->redosThreshold) {\n            'low' => 1,\n            'medium' => 3,\n            'high' => 4,\n            'critical' => 5,\n            default => 1,\n        };\n\n        return $currentLevel >= $thresholdLevel;\n    }\n\n    private function isLikelyPartialRegexError(string $errorMessage): bool\n    {\n        $indicators = [\n            'No closing delimiter',\n            'Regex too short',\n            'Unknown modifier',\n            'Unexpected end',\n        ];\n        $found = false;\n        foreach ($indicators as $indicator) {\n            if (false !== stripos($errorMessage, (string) $indicator)) {\n                $found = true;\n\n                break;\n            }\n        }\n\n        return $found;\n    }\n\n    private function truncatePattern(string $pattern, int $length = 50): string\n    {\n        return \\strlen($pattern) > $length ? substr($pattern, 0, $length).'...' : $pattern;\n    }\n\n    private function getRegex(): Regex\n    {\n        return $this->regex ??= Regex::create();\n    }\n\n    private function getValidator(): ValidatorNodeVisitor\n    {\n        return $this->validator ??= new ValidatorNodeVisitor();\n    }\n\n    private function getRedosAnalyzer(): ReDoSAnalyzer\n    {\n        return $this->redosAnalyzer ??= new ReDoSAnalyzer();\n    }\n\n    \/**\n     * @param array<string> $recommendations\n     *\/\n    private function getTipForReDoS(array $recommendations): string\n    {\n        $tip = implode(\"\\n\", $recommendations);\n\n        \/\/ Append links for relevant recommendations\n        $additionalLinks = [];\n        if (str_contains($tip, 'possessive quantifiers') || str_contains($tip, 'possessive')) {\n            $additionalLinks[] = 'Read more about possessive quantifiers: '.self::DOC_LINKS['possessive quantifiers'];\n        }\n        if (str_contains($tip, 'atomic groups')) {\n            $additionalLinks[] = 'Read more about atomic groups: '.self::DOC_LINKS['atomic groups'];\n        }\n\n        \/\/ Always append catastrophic backtracking link for ReDoS\n        $additionalLinks[] = 'Read more about catastrophic backtracking: '.self::DOC_LINKS['catastrophic backtracking'];\n\n        $tip .= \"\\n\\n\".implode(\"\\n\", $additionalLinks);\n\n        return $tip;\n    }\n}\n",
    "Bridge\/Rector\/RegexOptimizationRector.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Rector;\n\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Expr\\FuncCall;\nuse PhpParser\\Node\\Scalar\\String_;\nuse PhpParser\\Node\\Stmt\\ClassConst;\nuse Rector\\Contract\\Rector\\ConfigurableRectorInterface;\nuse Rector\\Rector\\AbstractRector;\nuse RegexParser\\NodeVisitor\\CompilerNodeVisitor;\nuse RegexParser\\NodeVisitor\\OptimizerNodeVisitor;\nuse RegexParser\\Parser;\nuse Symplify\\RuleDocGenerator\\ValueObject\\CodeSample\\ConfiguredCodeSample;\nuse Symplify\\RuleDocGenerator\\ValueObject\\RuleDefinition;\n\n\/**\n * Optimizes PCRE regex patterns in function calls and class constants.\n *\/\nfinal class RegexOptimizationRector extends AbstractRector implements ConfigurableRectorInterface\n{\n    public const EXTRA_FUNCTIONS = 'extra_functions';\n\n    public const EXTRA_CONSTANTS = 'extra_constants';\n\n    private const DEFAULT_FUNCTIONS = [\n        'preg_match',\n        'preg_match_all',\n        'preg_replace',\n        'preg_replace_callback',\n        'preg_split',\n        'preg_grep',\n        'preg_filter',\n    ];\n\n    private const DEFAULT_CONSTANTS = [\n        'REGEX',\n        'PATTERN',\n    ];\n\n    \/**\n     * @var array<string, bool>\n     *\/\n    private array $targetFunctions = [];\n\n    \/**\n     * @var array<string, bool>\n     *\/\n    private array $targetConstants = [];\n\n    private ?Parser $parser = null;\n\n    private ?CompilerNodeVisitor $compiler = null;\n\n    public function __construct(\n        private readonly OptimizerNodeVisitor $optimizerVisitor,\n    ) {\n        foreach (self::DEFAULT_FUNCTIONS as $func) {\n            $this->targetFunctions[$func] = true;\n        }\n        foreach (self::DEFAULT_CONSTANTS as $const) {\n            $this->targetConstants[$const] = true;\n        }\n    }\n\n    public function getRuleDefinition(): RuleDefinition\n    {\n        return new RuleDefinition(\n            'Optimizes regex patterns using RegexParser\\'s AST transformation.',\n            [\n                new ConfiguredCodeSample(\n                    <<<'CODE_SAMPLE'\n                        class SomeClass\n                        {\n                            public function run($str)\n                            {\n                                preg_match('\/[a-zA-Z0-9_]+\/', $str);\n                            }\n                        }\n                        CODE_SAMPLE,\n                    <<<'CODE_SAMPLE'\n                        class SomeClass\n                        {\n                            public function run($str)\n                            {\n                                preg_match('\/\\\\w+\/', $str);\n                            }\n                        }\n                        CODE_SAMPLE,\n                    [\n                        self::EXTRA_FUNCTIONS => ['my_custom_preg_wrapper'],\n                    ],\n                ),\n            ],\n        );\n    }\n\n    \/**\n     * @param array<string, mixed> $configuration\n     *\/\n    public function configure(array $configuration): void\n    {\n        if (isset($configuration[self::EXTRA_FUNCTIONS])) {\n            foreach ((array) $configuration[self::EXTRA_FUNCTIONS] as $func) {\n                $this->targetFunctions[(string) $func] = true;\n            }\n        }\n\n        if (isset($configuration[self::EXTRA_CONSTANTS])) {\n            foreach ((array) $configuration[self::EXTRA_CONSTANTS] as $const) {\n                $this->targetConstants[(string) $const] = true;\n            }\n        }\n    }\n\n    \/**\n     * @return array<class-string<Node>>\n     *\/\n    public function getNodeTypes(): array\n    {\n        return [FuncCall::class, ClassConst::class];\n    }\n\n    public function refactor(Node $node): ?Node\n    {\n        $stringNode = $this->resolveRegexStringNode($node);\n\n        if (!$stringNode instanceof String_) {\n            return null;\n        }\n\n        $originalPattern = $stringNode->value;\n\n        if (\\strlen($originalPattern) < 2) {\n            return null;\n        }\n\n        try {\n            $parser = $this->getParser();\n            $ast = $parser->parse($originalPattern);\n\n            $optimizer = clone $this->optimizerVisitor;\n            $optimizedAst = $ast->accept($optimizer);\n\n            $compiler = $this->getCompiler();\n            $newPattern = $optimizedAst->accept($compiler);\n\n            if ($newPattern !== $originalPattern) {\n                $stringNode->value = $newPattern;\n\n                return $node;\n            }\n        } catch (\\Throwable) {\n        }\n\n        return null;\n    }\n\n    private function resolveRegexStringNode(Node $node): ?String_\n    {\n        if ($node instanceof FuncCall) {\n            return $this->resolveFuncCallArgument($node);\n        }\n\n        if ($node instanceof ClassConst) {\n            return $this->resolveClassConstantValue($node);\n        }\n\n        return null;\n    }\n\n    private function resolveFuncCallArgument(FuncCall $node): ?String_\n    {\n        if (!$node->name instanceof Node\\Name) {\n            return null;\n        }\n\n        $name = $this->getName($node->name);\n        if (null === $name || !isset($this->targetFunctions[$name])) {\n            return null;\n        }\n\n        $args = $node->getArgs();\n        if (!isset($args[0])) {\n            return null;\n        }\n\n        $patternArg = $args[0]->value;\n\n        return $patternArg instanceof String_ ? $patternArg : null;\n    }\n\n    private function resolveClassConstantValue(ClassConst $node): ?String_\n    {\n        foreach ($node->consts as $const) {\n            if (isset($this->targetConstants[$const->name->toString()])) {\n                return $const->value instanceof String_ ? $const->value : null;\n            }\n        }\n\n        return null;\n    }\n\n    private function getParser(): Parser\n    {\n        return $this->parser ??= new Parser();\n    }\n\n    private function getCompiler(): CompilerNodeVisitor\n    {\n        return $this->compiler ??= new CompilerNodeVisitor();\n    }\n}\n",
    "Bridge\/Psalm\/PluginConfiguration.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm;\n\nfinal readonly class PluginConfiguration\n{\n    public function __construct(\n        public bool $ignoreParseErrors = true,\n        public bool $reportRedos = true,\n        public string $redosThreshold = 'high',\n        public bool $suggestOptimizations = false,\n    ) {}\n}\n",
    "Bridge\/Psalm\/Plugin.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm;\n\nuse Psalm\\Plugin\\PluginEntryPointInterface;\nuse Psalm\\Plugin\\RegistrationInterface;\n\nfinal class Plugin implements PluginEntryPointInterface\n{\n    public function __invoke(RegistrationInterface $registration, ?\\SimpleXMLElement $config = null): void\n    {\n        PregValidationHandler::configure($this->createConfiguration($config));\n\n        $registration->registerHooksFromClass(PregValidationHandler::class);\n    }\n\n    private function createConfiguration(?\\SimpleXMLElement $config): PluginConfiguration\n    {\n        return new PluginConfiguration(\n            ignoreParseErrors: $this->getBoolean($config, 'ignoreParseErrors', true),\n            reportRedos: $this->getBoolean($config, 'reportRedos', true),\n            redosThreshold: $this->getString($config, 'redosThreshold', 'high'),\n            suggestOptimizations: $this->getBoolean($config, 'suggestOptimizations', false),\n        );\n    }\n\n    private function getBoolean(?\\SimpleXMLElement $config, string $key, bool $default): bool\n    {\n        if (null === $config || !isset($config->{$key})) {\n            return $default;\n        }\n\n        $value = filter_var((string) $config->{$key}, \\FILTER_VALIDATE_BOOLEAN, \\FILTER_NULL_ON_FAILURE);\n\n        return $value ?? $default;\n    }\n\n    private function getString(?\\SimpleXMLElement $config, string $key, string $default): string\n    {\n        if (null === $config || !isset($config->{$key})) {\n            return $default;\n        }\n\n        $value = strtolower(trim((string) $config->{$key}));\n\n        return \\in_array($value, ['low', 'medium', 'high', 'critical'], true) ? $value : $default;\n    }\n}\n",
    "Bridge\/Psalm\/Issue\/RegexSyntaxIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm\\Issue;\n\nuse Psalm\\Issue\\PluginIssue;\n\nfinal class RegexSyntaxIssue extends PluginIssue {}\n",
    "Bridge\/Psalm\/Issue\/RegexPatternEmptyIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm\\Issue;\n\nuse Psalm\\Issue\\PluginIssue;\n\nfinal class RegexPatternEmptyIssue extends PluginIssue {}\n",
    "Bridge\/Psalm\/Issue\/RegexOptimizationIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm\\Issue;\n\nuse Psalm\\Issue\\PluginIssue;\n\nfinal class RegexOptimizationIssue extends PluginIssue {}\n",
    "Bridge\/Psalm\/Issue\/RegexLinterIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm\\Issue;\n\nuse Psalm\\Issue\\PluginIssue;\n\nfinal class RegexLinterIssue extends PluginIssue {}\n",
    "Bridge\/Psalm\/Issue\/RegexRedosIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm\\Issue;\n\nuse Psalm\\Issue\\PluginIssue;\n\nfinal class RegexRedosIssue extends PluginIssue {}\n",
    "Bridge\/Psalm\/PregValidationHandler.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Psalm;\n\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Expr\\Array_;\nuse PhpParser\\Node\\Expr\\ArrayItem;\nuse PhpParser\\Node\\Scalar\\String_;\nuse Psalm\\CodeLocation;\nuse Psalm\\Issue\\PluginIssue;\nuse Psalm\\IssueBuffer;\nuse Psalm\\Plugin\\EventHandler\\AfterFunctionCallAnalysisInterface;\nuse Psalm\\Plugin\\EventHandler\\Event\\AfterFunctionCallAnalysisEvent;\nuse Psalm\\Type\\Atomic\\TLiteralString;\nuse Psalm\\Type\\Union;\nuse RegexParser\\Bridge\\Psalm\\Issue\\RegexLinterIssue;\nuse RegexParser\\Bridge\\Psalm\\Issue\\RegexOptimizationIssue;\nuse RegexParser\\Bridge\\Psalm\\Issue\\RegexPatternEmptyIssue;\nuse RegexParser\\Bridge\\Psalm\\Issue\\RegexRedosIssue;\nuse RegexParser\\Bridge\\Psalm\\Issue\\RegexSyntaxIssue;\nuse RegexParser\\Exception\\LexerException;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Exception\\SyntaxErrorException;\nuse RegexParser\\NodeVisitor\\LinterNodeVisitor;\nuse RegexParser\\NodeVisitor\\ValidatorNodeVisitor;\nuse RegexParser\\ReDoS\\ReDoSAnalyzer;\nuse RegexParser\\ReDoS\\ReDoSSeverity;\nuse RegexParser\\Regex;\n\nfinal class PregValidationHandler implements AfterFunctionCallAnalysisInterface\n{\n    private const PREG_FUNCTION_MAP = [\n        'preg_match' => 0,\n        'preg_match_all' => 0,\n        'preg_replace' => 0,\n        'preg_replace_callback' => 0,\n        'preg_split' => 0,\n        'preg_grep' => 0,\n        'preg_filter' => 0,\n        'preg_replace_callback_array' => 0,\n    ];\n\n    private static ?PluginConfiguration $configuration = null;\n\n    private static ?Regex $regex = null;\n\n    private static ?ValidatorNodeVisitor $validator = null;\n\n    private static ?ReDoSAnalyzer $redosAnalyzer = null;\n\n    public static function configure(PluginConfiguration $configuration): void\n    {\n        self::$configuration = $configuration;\n    }\n\n    public static function afterFunctionCallAnalysis(AfterFunctionCallAnalysisEvent $event): void\n    {\n        $functionId = strtolower($event->getFunctionId());\n        if (!isset(self::PREG_FUNCTION_MAP[$functionId])) {\n            return;\n        }\n\n        $args = $event->getExpr()->getArgs();\n        $patternPosition = self::PREG_FUNCTION_MAP[$functionId];\n\n        if (!isset($args[$patternPosition])) {\n            return;\n        }\n\n        $patternArg = $args[$patternPosition]->value;\n\n        if ('preg_replace_callback_array' === $functionId) {\n            self::processPregReplaceCallbackArray($patternArg, $event);\n\n            return;\n        }\n\n        self::processPatternArgument($patternArg, $event);\n    }\n\n    private static function processPregReplaceCallbackArray(Node $arrayNode, AfterFunctionCallAnalysisEvent $event): void\n    {\n        if (!$arrayNode instanceof Array_) {\n            return;\n        }\n\n        foreach ($arrayNode->items as $item) {\n            if (!$item instanceof ArrayItem || !$item->key instanceof String_) {\n                continue;\n            }\n\n            self::validatePattern($item->key->value, $event, $item->key);\n        }\n    }\n\n    private static function processPatternArgument(Node $patternNode, AfterFunctionCallAnalysisEvent $event): void\n    {\n        $typeProvider = $event->getStatementsSource()->getNodeTypeProvider();\n        $type = $typeProvider->getType($patternNode);\n\n        if (null === $type) {\n            if ($patternNode instanceof String_) {\n                self::validatePattern($patternNode->value, $event, $patternNode);\n            }\n\n            return;\n        }\n\n        $literalStrings = self::getLiteralStrings($type);\n\n        if ([] === $literalStrings && $patternNode instanceof String_) {\n            $literalStrings[] = $patternNode->value;\n        }\n\n        foreach ($literalStrings as $literalString) {\n            self::validatePattern($literalString, $event, $patternNode);\n        }\n    }\n\n    private static function validatePattern(string $pattern, AfterFunctionCallAnalysisEvent $event, Node $patternNode): void\n    {\n        if ('' === $pattern) {\n            self::reportIssue(\n                new RegexPatternEmptyIssue('Regex pattern cannot be empty.', new CodeLocation($event->getStatementsSource(), $patternNode)),\n                $event,\n            );\n\n            return;\n        }\n\n        $configuration = self::getConfiguration();\n\n        try {\n            $ast = self::getRegex()->parse($pattern);\n            $ast->accept(self::getValidator());\n        } catch (LexerException|ParserException|SyntaxErrorException $e) {\n            if ($configuration->ignoreParseErrors && self::isLikelyPartialRegexError($e->getMessage())) {\n                return;\n            }\n\n            $message = \\sprintf('Regex syntax error: %s (Pattern: \"%s\")', $e->getMessage(), self::truncatePattern($pattern));\n\n            self::reportIssue(\n                new RegexSyntaxIssue($message, new CodeLocation($event->getStatementsSource(), $patternNode)),\n                $event,\n            );\n\n            return;\n        } catch (\\Throwable) {\n            return;\n        }\n\n        if ($configuration->reportRedos) {\n            try {\n                $analysis = self::getRedosAnalyzer()->analyze($pattern);\n\n                if (self::exceedsThreshold($analysis->severity, $configuration->redosThreshold)) {\n                    $message = \\sprintf(\n                        'ReDoS vulnerability detected (%s): %s',\n                        strtoupper($analysis->severity->value),\n                        self::truncatePattern($pattern),\n                    );\n\n                    if ([] !== $analysis->recommendations) {\n                        $message .= ' | Recommendations: '.implode('; ', $analysis->recommendations);\n                    }\n\n                    self::reportIssue(\n                        new RegexRedosIssue($message, new CodeLocation($event->getStatementsSource(), $patternNode)),\n                        $event,\n                    );\n                }\n            } catch (\\Throwable) {\n            }\n        }\n\n        if ($configuration->suggestOptimizations) {\n            try {\n                $optimization = self::getRegex()->optimize($pattern);\n                $optimized = $optimization->optimized;\n                if ($optimized !== $pattern && \\strlen($optimized) < \\strlen($pattern)) {\n                    $message = \\sprintf(\n                        'Regex pattern can be optimized: \"%s\" (Try: %s)',\n                        self::truncatePattern($pattern),\n                        $optimized,\n                    );\n\n                    self::reportIssue(\n                        new RegexOptimizationIssue($message, new CodeLocation($event->getStatementsSource(), $patternNode)),\n                        $event,\n                    );\n                }\n            } catch (\\Throwable) {\n            }\n        }\n\n        try {\n            $linter = new LinterNodeVisitor();\n            $ast->accept($linter);\n            foreach ($linter->getIssues() as $issue) {\n                $message = \\sprintf('[%s] %s', $issue->id, $issue->message);\n                if (null !== $issue->hint) {\n                    $message .= ' | '.$issue->hint;\n                }\n                self::reportIssue(\n                    new RegexLinterIssue('Tip: '.$message, new CodeLocation($event->getStatementsSource(), $patternNode)),\n                    $event,\n                );\n            }\n        } catch (\\Throwable) {\n        }\n    }\n\n    private static function reportIssue(PluginIssue $issue, AfterFunctionCallAnalysisEvent $event): void\n    {\n        IssueBuffer::maybeAdd($issue, $event->getStatementsSource()->getSuppressedIssues());\n    }\n\n    private static function getConfiguration(): PluginConfiguration\n    {\n        return self::$configuration ??= new PluginConfiguration();\n    }\n\n    \/**\n     * @return list<string>\n     *\/\n    private static function getLiteralStrings(Union $type): array\n    {\n        $strings = [];\n\n        foreach ($type->getAtomicTypes() as $atomic) {\n            if ($atomic instanceof TLiteralString) {\n                $strings[] = $atomic->value;\n            }\n        }\n\n        return $strings;\n    }\n\n    private static function exceedsThreshold(ReDoSSeverity $severity, string $threshold): bool\n    {\n        $currentLevel = match ($severity) {\n            ReDoSSeverity::SAFE => 0,\n            ReDoSSeverity::LOW => 1,\n            ReDoSSeverity::UNKNOWN => 2,\n            ReDoSSeverity::MEDIUM => 3,\n            ReDoSSeverity::HIGH => 4,\n            ReDoSSeverity::CRITICAL => 5,\n        };\n\n        $thresholdLevel = match ($threshold) {\n            'low' => 1,\n            'medium' => 3,\n            'high' => 4,\n            'critical' => 5,\n            default => 1,\n        };\n\n        return $currentLevel >= $thresholdLevel;\n    }\n\n    private static function isLikelyPartialRegexError(string $errorMessage): bool\n    {\n        $indicators = [\n            'No closing delimiter',\n            'Regex too short',\n            'Unknown modifier',\n            'Unexpected end',\n        ];\n\n        foreach ($indicators as $indicator) {\n            if (false !== stripos($errorMessage, (string) $indicator)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static function truncatePattern(string $pattern, int $length = 50): string\n    {\n        return \\strlen($pattern) > $length ? substr($pattern, 0, $length).'...' : $pattern;\n    }\n\n    private static function getRegex(): Regex\n    {\n        return self::$regex ??= Regex::create();\n    }\n\n    private static function getValidator(): ValidatorNodeVisitor\n    {\n        return self::$validator ??= new ValidatorNodeVisitor();\n    }\n\n    private static function getRedosAnalyzer(): ReDoSAnalyzer\n    {\n        return self::$redosAnalyzer ??= new ReDoSAnalyzer();\n    }\n}\n",
    "Bridge\/Symfony\/RegexParserBundle.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\n\/**\n * Symfony Bundle for the RegexParser library.\n *\/\nfinal class RegexParserBundle extends Bundle\n{\n    \/**\n     * @return string the absolute path to the bundle's root directory\n     *\/\n    #[\\Override]\n    public function getPath(): string\n    {\n        return __DIR__;\n    }\n}\n",
    "Bridge\/Symfony\/Resources\/config\/services.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\nuse Psr\\Log\\LoggerInterface;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\CacheWarmer\\RegexParserCacheWarmer;\nuse RegexParser\\Bridge\\Symfony\\Command\\RegexAnalyzeRedosCommand;\nuse RegexParser\\Bridge\\Symfony\\Command\\RegexLintCommand;\nuse RegexParser\\Bridge\\Symfony\\Command\\RegexOptimizeCommand;\nuse RegexParser\\Bridge\\Symfony\\Command\\RegexParserValidateCommand;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n\/*\n * Base services for the RegexParser library.\n *\n * These services are always loaded when the bundle is enabled.\n *\/\nreturn static function (ContainerConfigurator $container): void {\n    $services = $container->services()\n        ->defaults()\n            ->private();\n\n    $services->set('regex_parser.regex', Regex::class)\n        ->factory([Regex::class, 'create'])\n        ->arg('$options', [\n            'max_pattern_length' => param('regex_parser.max_pattern_length'),\n            'max_lookbehind_length' => param('regex_parser.max_lookbehind_length'),\n            'cache' => service('regex_parser.cache'),\n            'redos_ignored_patterns' => param('regex_parser.redos.ignored_patterns'),\n        ])\n        ->public();\n\n    \/\/ Aliases for autowiring\n    $services->alias(Regex::class, 'regex_parser.regex')\n        ->public();\n\n    $services->set(RouteRequirementAnalyzer::class, RouteRequirementAnalyzer::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->arg('$warningThreshold', param('regex_parser.analysis.warning_threshold'))\n        ->arg('$redosThreshold', param('regex_parser.redos.threshold'))\n        ->arg('$ignoredPatterns', param('regex_parser.redos.ignored_patterns'));\n\n    $services->set(ValidatorRegexAnalyzer::class, ValidatorRegexAnalyzer::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->arg('$warningThreshold', param('regex_parser.analysis.warning_threshold'))\n        ->arg('$redosThreshold', param('regex_parser.redos.threshold'))\n        ->arg('$ignoredPatterns', param('regex_parser.redos.ignored_patterns'));\n\n    $services->set('regex_parser.cache_warmer', RegexParserCacheWarmer::class)\n        ->arg('$analyzer', service(RouteRequirementAnalyzer::class))\n        ->arg('$router', service(RouterInterface::class)->nullOnInvalid())\n        ->arg('$logger', service(LoggerInterface::class)->nullOnInvalid())\n        ->arg('$validatorAnalyzer', service(ValidatorRegexAnalyzer::class))\n        ->arg('$validator', service(ValidatorInterface::class)->nullOnInvalid())\n        ->arg('$validatorLoader', service(LoaderInterface::class)->nullOnInvalid())\n        ->tag('kernel.cache_warmer');\n\n    $services->set('regex_parser.command.validate', RegexParserValidateCommand::class)\n        ->arg('$analyzer', service(RouteRequirementAnalyzer::class))\n        ->arg('$router', service(RouterInterface::class)->nullOnInvalid())\n        ->arg('$validatorAnalyzer', service(ValidatorRegexAnalyzer::class))\n        ->arg('$validator', service(ValidatorInterface::class)->nullOnInvalid())\n        ->arg('$validatorLoader', service(LoaderInterface::class)->nullOnInvalid())\n        ->tag('console.command')\n        ->public();\n\n    $services->set('regex_parser.command.lint', RegexLintCommand::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->tag('console.command')\n        ->public();\n\n    $services->set('regex_parser.command.analyze_redos', RegexAnalyzeRedosCommand::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->arg('$defaultThreshold', param('regex_parser.redos.threshold'))\n        ->tag('console.command')\n        ->public();\n\n    $services->set('regex_parser.command.optimize', RegexOptimizeCommand::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->tag('console.command')\n        ->public();\n};\n",
    "Bridge\/Symfony\/CacheWarmer\/RegexParserCacheWarmer.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\CacheWarmer;\n\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\LogLevel;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\AnalysisIssue;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse Symfony\\Component\\HttpKernel\\CacheWarmer\\CacheWarmerInterface;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n\/**\n * Surfaces regex warnings during Symfony cache warmup.\n *\n * @internal\n *\/\nfinal readonly class RegexParserCacheWarmer implements CacheWarmerInterface\n{\n    public function __construct(\n        private RouteRequirementAnalyzer $analyzer,\n        private ?RouterInterface $router = null,\n        private ?LoggerInterface $logger = null,\n        private ?ValidatorRegexAnalyzer $validatorAnalyzer = null,\n        private ?ValidatorInterface $validator = null,\n        private ?LoaderInterface $validatorLoader = null,\n    ) {}\n\n    #[\\Override]\n    public function isOptional(): bool\n    {\n        return true;\n    }\n\n    #[\\Override]\n    public function warmUp(string $cacheDir, ?string $buildDir = null): array\n    {\n        $issues = [];\n\n        if (null !== $this->router) {\n            $issues = array_merge($issues, $this->analyzer->analyze($this->router->getRouteCollection()));\n        }\n\n        if (null !== $this->validatorAnalyzer) {\n            $issues = array_merge($issues, $this->validatorAnalyzer->analyze($this->validator, $this->validatorLoader));\n        }\n\n        foreach ($issues as $issue) {\n            $this->log($issue);\n        }\n\n        return [];\n    }\n\n    private function log(AnalysisIssue $issue): void\n    {\n        if (null !== $this->logger) {\n            $this->logger->log(\n                $issue->isError ? LogLevel::ERROR : LogLevel::WARNING,\n                $issue->message,\n            );\n\n            return;\n        }\n\n        error_log($issue->message);\n    }\n}\n",
    "Bridge\/Symfony\/Command\/RegexAnalyzeRedosCommand.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\nuse RegexParser\\ReDoS\\ReDoSSeverity;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\n\n#[AsCommand(\n    name: 'regex:analyze-redos',\n    description: 'Analyzes constant preg_* patterns for ReDoS risk.',\n)]\nfinal class RegexAnalyzeRedosCommand extends Command\n{\n    protected static ?string $defaultName = 'regex:analyze-redos';\n\n    protected static ?string $defaultDescription = 'Analyzes constant preg_* patterns for ReDoS risk.';\n\n    public function __construct(\n        private readonly Regex $regex,\n        private readonly string $defaultThreshold = 'high',\n    ) {\n        parent::__construct();\n    }\n\n    #[\\Override]\n    protected function configure(): void\n    {\n        $this\n            ->addArgument('paths', InputArgument::IS_ARRAY, 'Files\/directories to scan (defaults to current directory).')\n            ->addOption('threshold', null, InputOption::VALUE_REQUIRED, 'Minimum severity to report (safe|low|medium|high|critical).', $this->defaultThreshold);\n    }\n\n    #[\\Override]\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n\n        \/** @var list<string> $paths *\/\n        $paths = $input->getArgument('paths');\n        if ([] === $paths) {\n            $paths = ['.'];\n        }\n\n        $threshold = (string) $input->getOption('threshold');\n        $severityThreshold = ReDoSSeverity::tryFrom(strtolower($threshold)) ?? ReDoSSeverity::HIGH;\n\n        $extractor = new RegexPatternExtractor();\n        $patterns = $extractor->extract($paths);\n\n        if ([] === $patterns) {\n            $io->success('No constant preg_* patterns found.');\n\n            return Command::SUCCESS;\n        }\n\n        $hasErrors = false;\n\n        foreach ($patterns as $occurrence) {\n            $validation = $this->regex->validate($occurrence->pattern);\n            if (!$validation->isValid) {\n                $hasErrors = true;\n                $io->writeln(\\sprintf(\n                    '<error>[error]<\/error> %s:%d %s',\n                    $occurrence->file,\n                    $occurrence->line,\n                    $validation->error ?? 'Invalid regex.',\n                ));\n\n                continue;\n            }\n\n            $analysis = $this->regex->analyzeReDoS($occurrence->pattern);\n            if (!$analysis->exceedsThreshold($severityThreshold)) {\n                continue;\n            }\n\n            $hasErrors = true;\n            $summary = \\sprintf(\n                '%s:%d severity=%s score=%d',\n                $occurrence->file,\n                $occurrence->line,\n                strtoupper($analysis->severity->value),\n                $analysis->score,\n            );\n\n            $io->writeln('<error>[redos]<\/error> '.$summary);\n\n            if (null !== $analysis->trigger) {\n                $io->writeln('  Trigger: '.$analysis->trigger);\n            }\n\n            if (null !== $analysis->confidence) {\n                $io->writeln('  Confidence: '.$analysis->confidence->value);\n            }\n\n            if (null !== $analysis->falsePositiveRisk) {\n                $io->writeln('  False positive risk: '.$analysis->falsePositiveRisk);\n            }\n\n            foreach ($analysis->recommendations as $recommendation) {\n                $io->writeln('  - '.$recommendation);\n            }\n        }\n\n        if (!$hasErrors) {\n            $io->success('No ReDoS findings above threshold.');\n\n            return Command::SUCCESS;\n        }\n\n        $io->error(\\sprintf('ReDoS analysis found issues (threshold: %s).', $severityThreshold->value));\n\n        return Command::FAILURE;\n    }\n}\n",
    "Bridge\/Symfony\/Command\/RegexLintCommand.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\nuse RegexParser\\NodeVisitor\\LinterNodeVisitor;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\n\n#[AsCommand(\n    name: 'regex:lint',\n    description: 'Lints constant preg_* patterns found in PHP files.',\n)]\nfinal class RegexLintCommand extends Command\n{\n    protected static ?string $defaultName = 'regex:lint';\n\n    protected static ?string $defaultDescription = 'Lints constant preg_* patterns found in PHP files.';\n\n    public function __construct(\n        private readonly Regex $regex,\n    ) {\n        parent::__construct();\n    }\n\n    #[\\Override]\n    protected function configure(): void\n    {\n        $this\n            ->addArgument('paths', InputArgument::IS_ARRAY, 'Files\/directories to scan (defaults to current directory).')\n            ->addOption('fail-on-warnings', null, InputOption::VALUE_NONE, 'Exit with a non-zero code when warnings are found.');\n    }\n\n    #[\\Override]\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n\n        \/** @var list<string> $paths *\/\n        $paths = $input->getArgument('paths');\n        if ([] === $paths) {\n            $paths = ['.'];\n        }\n\n        $extractor = new RegexPatternExtractor();\n        $patterns = $extractor->extract($paths);\n\n        if ([] === $patterns) {\n            $io->success('No constant preg_* patterns found.');\n\n            return Command::SUCCESS;\n        }\n\n        $hasErrors = false;\n        $hasWarnings = false;\n\n        foreach ($patterns as $occurrence) {\n            $validation = $this->regex->validate($occurrence->pattern);\n            if (!$validation->isValid) {\n                $hasErrors = true;\n                $io->writeln(\\sprintf(\n                    '<error>[error]<\/error> %s:%d %s',\n                    $occurrence->file,\n                    $occurrence->line,\n                    $validation->error ?? 'Invalid regex.',\n                ));\n\n                continue;\n            }\n\n            $ast = $this->regex->parse($occurrence->pattern);\n            $linter = new LinterNodeVisitor();\n            $ast->accept($linter);\n\n            foreach ($linter->getIssues() as $issue) {\n                $hasWarnings = true;\n                $io->writeln(\\sprintf(\n                    '<comment>[warn]<\/comment> %s:%d [%s] %s',\n                    $occurrence->file,\n                    $occurrence->line,\n                    $issue->id,\n                    $issue->message,\n                ));\n\n                if (null !== $issue->hint) {\n                    $io->writeln('  '.$issue->hint);\n                }\n            }\n        }\n\n        if (!$hasErrors && !$hasWarnings) {\n            $io->success('No lint issues detected.');\n\n            return Command::SUCCESS;\n        }\n\n        if (!$hasErrors && $hasWarnings) {\n            $io->success('Regex lint completed with warnings only.');\n        }\n\n        $failOnWarnings = (bool) $input->getOption('fail-on-warnings');\n\n        return ($hasErrors || ($failOnWarnings && $hasWarnings)) ? Command::FAILURE : Command::SUCCESS;\n    }\n}\n",
    "Bridge\/Symfony\/Command\/RegexOptimizeCommand.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\n\n#[AsCommand(\n    name: 'regex:optimize',\n    description: 'Suggests safe optimizations for constant preg_* patterns found in PHP files.',\n)]\nfinal class RegexOptimizeCommand extends Command\n{\n    protected static ?string $defaultName = 'regex:optimize';\n\n    protected static ?string $defaultDescription = 'Suggests safe optimizations for constant preg_* patterns found in PHP files.';\n\n    public function __construct(\n        private readonly Regex $regex,\n    ) {\n        parent::__construct();\n    }\n\n    #[\\Override]\n    protected function configure(): void\n    {\n        $this\n            ->addArgument('paths', InputArgument::IS_ARRAY, 'Files\/directories to scan (defaults to current directory).')\n            ->addOption('min-savings', null, InputOption::VALUE_REQUIRED, 'Minimum character savings to report.', 1)\n            ->addOption('fail-on-suggestions', null, InputOption::VALUE_NONE, 'Exit with a non-zero code when suggestions are found.');\n    }\n\n    #[\\Override]\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n\n        \/** @var list<string> $paths *\/\n        $paths = $input->getArgument('paths');\n        if ([] === $paths) {\n            $paths = ['.'];\n        }\n\n        $minSavings = (int) $input->getOption('min-savings');\n        if ($minSavings < 0) {\n            $minSavings = 0;\n        }\n\n        $extractor = new RegexPatternExtractor();\n        $patterns = $extractor->extract($paths);\n\n        if ([] === $patterns) {\n            $io->success('No constant preg_* patterns found.');\n\n            return Command::SUCCESS;\n        }\n\n        $hasErrors = false;\n        $hasSuggestions = false;\n\n        foreach ($patterns as $occurrence) {\n            $validation = $this->regex->validate($occurrence->pattern);\n            if (!$validation->isValid) {\n                $hasErrors = true;\n                $io->writeln(\\sprintf(\n                    '<error>[error]<\/error> %s:%d %s',\n                    $occurrence->file,\n                    $occurrence->line,\n                    $validation->error ?? 'Invalid regex.',\n                ));\n\n                continue;\n            }\n\n            try {\n                $optimization = $this->regex->optimize($occurrence->pattern);\n            } catch (\\Throwable $e) {\n                $hasErrors = true;\n                $io->writeln(\\sprintf('<error>[error]<\/error> %s:%d %s', $occurrence->file, $occurrence->line, $e->getMessage()));\n\n                continue;\n            }\n\n            if (!$optimization->isChanged()) {\n                continue;\n            }\n\n            $savings = \\strlen($optimization->original) - \\strlen($optimization->optimized);\n            if ($savings < $minSavings) {\n                continue;\n            }\n\n            $hasSuggestions = true;\n\n            $io->writeln(\\sprintf(\n                '<comment>[suggest]<\/comment> %s:%d saved=%d',\n                $occurrence->file,\n                $occurrence->line,\n                $savings,\n            ));\n            $io->writeln('  - '.$optimization->original);\n            $io->writeln('  + '.$optimization->optimized);\n        }\n\n        if (!$hasErrors && !$hasSuggestions) {\n            $io->success('No optimization suggestions.');\n\n            return Command::SUCCESS;\n        }\n\n        $failOnSuggestions = (bool) $input->getOption('fail-on-suggestions');\n\n        return ($hasErrors || ($failOnSuggestions && $hasSuggestions)) ? Command::FAILURE : Command::SUCCESS;\n    }\n}\n",
    "Bridge\/Symfony\/Command\/RegexParserValidateCommand.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n#[AsCommand(\n    name: 'regex-parser:check',\n    description: 'Validates regex usage found in the Symfony application.',\n)]\nfinal class RegexParserValidateCommand extends Command\n{\n    protected static ?string $defaultName = 'regex-parser:check';\n\n    protected static ?string $defaultDescription = 'Validates regex usage found in the Symfony application.';\n\n    public function __construct(\n        private readonly RouteRequirementAnalyzer $analyzer,\n        private readonly ?RouterInterface $router = null,\n        private readonly ?ValidatorRegexAnalyzer $validatorAnalyzer = null,\n        private readonly ?ValidatorInterface $validator = null,\n        private readonly ?LoaderInterface $validatorLoader = null,\n    ) {\n        parent::__construct();\n    }\n\n    #[\\Override]\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n\n        $issues = [];\n\n        if (null !== $this->router) {\n            $issues = array_merge($issues, $this->analyzer->analyze($this->router->getRouteCollection()));\n        } else {\n            $io->warning('No router service was found; skipping route regex checks.');\n        }\n\n        if (null !== $this->validatorAnalyzer) {\n            $issues = array_merge($issues, $this->validatorAnalyzer->analyze($this->validator, $this->validatorLoader));\n        } else {\n            $io->warning('No validator service was found; skipping validator regex checks.');\n        }\n\n        if ([] === $issues) {\n            $io->success('No regex issues detected.');\n\n            return Command::SUCCESS;\n        }\n\n        $hasErrors = false;\n        foreach ($issues as $issue) {\n            $hasErrors = $hasErrors || $issue->isError;\n            $io->writeln(\\sprintf(\n                '%s %s',\n                $issue->isError ? '<error>[error]<\/error>' : '<comment>[warn]<\/comment>',\n                $issue->message,\n            ));\n        }\n\n        if (!$hasErrors) {\n            $io->success('RegexParser found warnings only.');\n        }\n\n        return $hasErrors ? Command::FAILURE : Command::SUCCESS;\n    }\n}\n",
    "Bridge\/Symfony\/Command\/RegexPatternExtractor.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\n\/**\n * Extracts constant regex patterns from PHP source files.\n *\n * This scanner is intentionally conservative: it only reports patterns that are\n * PHP constant strings passed directly to `preg_*` calls.\n *\n * @internal\n *\/\nfinal class RegexPatternExtractor\n{\n    private const IGNORABLE_TOKENS = [\n        \\T_WHITESPACE => true,\n        \\T_COMMENT => true,\n        \\T_DOC_COMMENT => true,\n    ];\n\n    private const PREG_FUNCTIONS = [\n        'preg_match' => true,\n        'preg_match_all' => true,\n        'preg_replace' => true,\n        'preg_replace_callback' => true,\n        'preg_split' => true,\n        'preg_grep' => true,\n        'preg_filter' => true,\n        'preg_replace_callback_array' => true,\n    ];\n\n    \/**\n     * @param list<string> $paths\n     *\n     * @return list<RegexPatternOccurrence>\n     *\/\n    public function extract(array $paths): array\n    {\n        $occurrences = [];\n\n        foreach ($this->iteratePhpFiles($paths) as $file) {\n            $occurrences = [...$occurrences, ...$this->extractFromFile($file)];\n        }\n\n        return $occurrences;\n    }\n\n    \/**\n     * @param list<string> $paths\n     *\n     * @return \\Generator<string>\n     *\/\n    private function iteratePhpFiles(array $paths): \\Generator\n    {\n        foreach ($paths as $path) {\n            if ('' === $path) {\n                continue;\n            }\n\n            if (is_file($path)) {\n                if (str_ends_with($path, '.php')) {\n                    yield $path;\n                }\n\n                continue;\n            }\n\n            if (!is_dir($path)) {\n                continue;\n            }\n\n            $iterator = new \\RecursiveIteratorIterator(\n                new \\RecursiveDirectoryIterator($path, \\RecursiveDirectoryIterator::SKIP_DOTS),\n            );\n\n            \/** @var \\SplFileInfo $file *\/\n            foreach ($iterator as $file) {\n                if (!$file->isFile()) {\n                    continue;\n                }\n\n                if ('php' !== $file->getExtension()) {\n                    continue;\n                }\n\n                yield $file->getPathname();\n            }\n        }\n    }\n\n    \/**\n     * @return list<RegexPatternOccurrence>\n     *\/\n    private function extractFromFile(string $file): array\n    {\n        $code = @file_get_contents($file);\n        if (false === $code || '' === $code) {\n            return [];\n        }\n\n        $tokens = token_get_all($code);\n        $count = \\count($tokens);\n\n        $occurrences = [];\n\n        for ($i = 0; $i < $count; $i++) {\n            $token = $tokens[$i] ?? null;\n            if (!\\is_array($token) || \\T_STRING !== $token[0]) {\n                continue;\n            }\n\n            $functionName = strtolower($token[1]);\n            if (!isset(self::PREG_FUNCTIONS[$functionName])) {\n                continue;\n            }\n\n            if ($this->isMethodOrStaticCall($tokens, $i)) {\n                continue;\n            }\n\n            $openParen = $this->nextMeaningfulTokenIndex($tokens, $i + 1);\n            if (null === $openParen || '(' !== ($tokens[$openParen] ?? null)) {\n                continue;\n            }\n\n            $argStart = $this->nextMeaningfulTokenIndex($tokens, $openParen + 1);\n            if (null === $argStart) {\n                continue;\n            }\n\n            $source = $functionName.'()';\n\n            if ('preg_replace_callback_array' === $functionName) {\n                [$found, $endIndex] = $this->extractCallbackArrayPatterns($tokens, $argStart, $file, $source);\n                $occurrences = [...$occurrences, ...$found];\n                if (null !== $endIndex) {\n                    $i = $endIndex;\n                }\n\n                continue;\n            }\n\n            $argToken = $tokens[$argStart];\n            if (!\\is_array($argToken) || \\T_CONSTANT_ENCAPSED_STRING !== $argToken[0]) {\n                continue;\n            }\n\n            $pattern = $this->decodeConstantString($argToken[1]);\n            if (null === $pattern || '' === $pattern) {\n                continue;\n            }\n\n            $occurrences[] = new RegexPatternOccurrence($pattern, $file, (int) $argToken[2], $source);\n        }\n\n        return $occurrences;\n    }\n\n    \/**\n     * @param array<int, array{0: int, 1: string, 2: int}|string> $tokens\n     *\n     * @return array{0: list<RegexPatternOccurrence>, 1: int|null}\n     *\/\n    private function extractCallbackArrayPatterns(array $tokens, int $startIndex, string $file, string $source): array\n    {\n        $token = $tokens[$startIndex] ?? null;\n        if (null === $token) {\n            return [[], null];\n        }\n\n        if ('[' === $token) {\n            [$patterns, $endIndex] = $this->extractArrayStringKeys($tokens, $startIndex, '[', ']');\n\n            return [$this->buildOccurrences($patterns, $file, $source), $endIndex];\n        }\n\n        if (\\is_array($token) && \\T_ARRAY === $token[0]) {\n            $openParen = $this->nextMeaningfulTokenIndex($tokens, $startIndex + 1);\n            if (null === $openParen || '(' !== ($tokens[$openParen] ?? null)) {\n                return [[], null];\n            }\n\n            [$patterns, $endIndex] = $this->extractArrayStringKeys($tokens, $openParen, '(', ')');\n\n            return [$this->buildOccurrences($patterns, $file, $source), $endIndex];\n        }\n\n        return [[], null];\n    }\n\n    \/**\n     * @param list<array{pattern: string, line: int}> $patterns\n     *\n     * @return list<RegexPatternOccurrence>\n     *\/\n    private function buildOccurrences(array $patterns, string $file, string $source): array\n    {\n        $occurrences = [];\n        foreach ($patterns as $pattern) {\n            if ('' === $pattern['pattern']) {\n                continue;\n            }\n\n            $occurrences[] = new RegexPatternOccurrence($pattern['pattern'], $file, $pattern['line'], $source);\n        }\n\n        return $occurrences;\n    }\n\n    \/**\n     * @param array<int, array{0: int, 1: string, 2: int}|string> $tokens\n     *\n     * @return array{0: list<array{pattern: string, line: int}>, 1: int|null}\n     *\/\n    private function extractArrayStringKeys(array $tokens, int $openIndex, string $open, string $close): array\n    {\n        $patterns = [];\n        $depth = 0;\n        $count = \\count($tokens);\n\n        for ($i = $openIndex; $i < $count; $i++) {\n            $token = $tokens[$i];\n\n            if ($open === $token) {\n                $depth++;\n\n                continue;\n            }\n\n            if ($close === $token) {\n                $depth--;\n\n                if (0 === $depth) {\n                    return [$patterns, $i];\n                }\n\n                continue;\n            }\n\n            if (1 !== $depth) {\n                continue;\n            }\n\n            if (!\\is_array($token) || \\T_CONSTANT_ENCAPSED_STRING !== $token[0]) {\n                continue;\n            }\n\n            $next = $this->nextMeaningfulTokenIndex($tokens, $i + 1);\n            if (null === $next) {\n                continue;\n            }\n\n            $nextToken = $tokens[$next];\n            if (!\\is_array($nextToken) || \\T_DOUBLE_ARROW !== $nextToken[0]) {\n                continue;\n            }\n\n            $pattern = $this->decodeConstantString($token[1]);\n            if (null === $pattern) {\n                continue;\n            }\n\n            $patterns[] = ['pattern' => $pattern, 'line' => (int) $token[2]];\n        }\n\n        return [$patterns, null];\n    }\n\n    \/**\n     * @param array<int, array{0: int, 1: string, 2: int}|string> $tokens\n     *\/\n    private function isMethodOrStaticCall(array $tokens, int $index): bool\n    {\n        $previous = $this->previousMeaningfulTokenIndex($tokens, $index - 1);\n        if (null === $previous) {\n            return false;\n        }\n\n        $token = $tokens[$previous];\n        if (!\\is_array($token)) {\n            return false;\n        }\n\n        return \\in_array($token[0], [\\T_OBJECT_OPERATOR, \\T_DOUBLE_COLON, \\T_FUNCTION], true);\n    }\n\n    \/**\n     * @param array<int, array{0: int, 1: string, 2: int}|string> $tokens\n     *\/\n    private function nextMeaningfulTokenIndex(array $tokens, int $start): ?int\n    {\n        $count = \\count($tokens);\n        for ($i = $start; $i < $count; $i++) {\n            $token = $tokens[$i];\n            if (!\\is_array($token)) {\n                return $i;\n            }\n\n            if (!isset(self::IGNORABLE_TOKENS[$token[0]])) {\n                return $i;\n            }\n        }\n\n        return null;\n    }\n\n    \/**\n     * @param array<int, array{0: int, 1: string, 2: int}|string> $tokens\n     *\/\n    private function previousMeaningfulTokenIndex(array $tokens, int $start): ?int\n    {\n        for ($i = $start; $i >= 0; $i--) {\n            $token = $tokens[$i];\n            if (!\\is_array($token)) {\n                return $i;\n            }\n\n            if (!isset(self::IGNORABLE_TOKENS[$token[0]])) {\n                return $i;\n            }\n        }\n\n        return null;\n    }\n\n    private function decodeConstantString(string $literal): ?string\n    {\n        $len = \\strlen($literal);\n        if ($len < 2) {\n            return null;\n        }\n\n        $quote = $literal[0];\n        if ((\"'\" !== $quote && '\"' !== $quote) || $quote !== $literal[$len - 1]) {\n            return null;\n        }\n\n        $content = substr($literal, 1, -1);\n\n        if (\"'\" === $quote) {\n            return str_replace(['\\\\\\\\', \"\\\\'\"], ['\\\\', \"'\"], $content);\n        }\n\n        return stripcslashes($content);\n    }\n}\n",
    "Bridge\/Symfony\/Command\/RegexPatternOccurrence.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\n\/**\n * Represents a regex pattern occurrence found in source code.\n *\n * @internal\n *\/\nfinal readonly class RegexPatternOccurrence\n{\n    public function __construct(\n        public string $pattern,\n        public string $file,\n        public int $line,\n        public string $source,\n    ) {}\n}\n",
    "Bridge\/Symfony\/DependencyInjection\/Configuration.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\DependencyInjection;\n\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Config\\Definition\\Builder\\TreeBuilder;\nuse Symfony\\Component\\Config\\Definition\\ConfigurationInterface;\n\n\/**\n * Defines the configuration schema for the RegexParser bundle.\n *\/\nfinal readonly class Configuration implements ConfigurationInterface\n{\n    \/**\n     * @param bool $debug The value of the `kernel.debug` parameter.\n     *\/\n    public function __construct(\n        private bool $debug = false,\n    ) {}\n\n    \/**\n     * @return TreeBuilder the tree builder instance\n     *\/\n    public function getConfigTreeBuilder(): TreeBuilder\n    {\n        $treeBuilder = new TreeBuilder('regex_parser');\n\n        $treeBuilder->getRootNode()\n            ->children()\n                ->booleanNode('enabled')\n                    ->defaultValue($this->debug)\n                    ->info('Enable or disable the RegexParser bundle entirely. Defaults to dev\/test only.')\n                ->end()\n                ->integerNode('max_pattern_length')\n                    ->defaultValue(Regex::DEFAULT_MAX_PATTERN_LENGTH)\n                    ->info('The maximum allowed length for a regex pattern string to parse.')\n                ->end()\n                ->integerNode('max_lookbehind_length')\n                    ->defaultValue(Regex::DEFAULT_MAX_LOOKBEHIND_LENGTH)\n                    ->min(0)\n                    ->info('The maximum allowed lookbehind length. Can be overridden per-pattern via (*LIMIT_LOOKBEHIND=...).')\n                ->end()\n                ->scalarNode('cache')\n                    ->defaultNull()\n                    ->info('Directory path for cached AST files. Set to null to disable caching.')\n                ->end()\n                ->scalarNode('cache_pool')\n                    ->defaultNull()\n                    ->info('Symfony cache pool service id (PSR-6). Takes precedence over \"cache\" when set.')\n                ->end()\n                ->scalarNode('cache_prefix')\n                    ->defaultValue('regex_')\n                    ->info('Cache key prefix for PSR-6 cache pools.')\n                ->end()\n                ->arrayNode('redos')\n                    ->addDefaultsIfNotSet()\n                    ->children()\n                        ->scalarNode('threshold')\n                            ->defaultValue('high')\n                            ->info('Minimum ReDoS severity to report (safe|low|medium|high|critical).')\n                            ->beforeNormalization()\n                                ->ifString()\n                                ->then(static fn (string $value): string => strtolower($value))\n                            ->end()\n                            ->validate()\n                                ->ifNotInArray(['safe', 'low', 'medium', 'high', 'critical'])\n                                ->thenInvalid('Invalid \"regex_parser.redos.threshold\" value \"%s\". Allowed: safe, low, medium, high, critical.')\n                            ->end()\n                        ->end()\n                        ->arrayNode('ignored_patterns')\n                            ->scalarPrototype()->end()\n                            ->defaultValue([])\n                            ->info('List of patterns or full regexes to exclude from ReDoS analysis.')\n                        ->end()\n                    ->end()\n                ->end()\n                ->arrayNode('analysis')\n                    ->addDefaultsIfNotSet()\n                    ->children()\n                        ->integerNode('warning_threshold')\n                            ->defaultValue(50)\n                            ->min(0)\n                            ->info('Complexity score above which a warning is emitted.')\n                        ->end()\n                        ->integerNode('redos_threshold')\n                            ->defaultValue(100)\n                            ->min(0)\n                            ->info('Complexity score above which a pattern is flagged as ReDoS risk.')\n                        ->end()\n                        ->arrayNode('ignore_patterns')\n                            ->scalarPrototype()->end()\n                            ->defaultValue([])\n                            ->info('List of regex fragments to treat as safe (e.g. Symfony requirement constants).')\n                        ->end()\n                    ->end()\n                ->end()\n            ->end();\n\n        return $treeBuilder;\n    }\n}\n",
    "Bridge\/Symfony\/DependencyInjection\/RegexParserExtension.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\DependencyInjection;\n\nuse RegexParser\\Cache\\FilesystemCache;\nuse RegexParser\\Cache\\NullCache;\nuse RegexParser\\Cache\\PsrCacheAdapter;\nuse Symfony\\Component\\Config\\FileLocator;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\Definition;\nuse Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Reference;\nuse Symfony\\Component\\HttpKernel\\DependencyInjection\\Extension;\n\n\/**\n * Loads and manages configuration for the RegexParser bundle.\n *\/\nfinal class RegexParserExtension extends Extension\n{\n    \/**\n     * @param array<array<string, mixed>> $configs   an array of configuration values from the application's config files\n     * @param ContainerBuilder            $container the DI container builder instance\n     *\n     * @throws \\Exception if the service definition files cannot be loaded\n     *\/\n    #[\\Override]\n    public function load(array $configs, ContainerBuilder $container): void\n    {\n        \/\/ Pass kernel.debug to Configuration for default values\n        $debug = (bool) $container->getParameter('kernel.debug');\n        $configuration = new Configuration($debug);\n\n        \/**\n         * @var array{\n         *     enabled: bool,\n         *     max_pattern_length: int,\n         *     max_lookbehind_length: int,\n         *     cache: string|null,\n         *     cache_pool: string|null,\n         *     cache_prefix: string,\n         *     redos: array{\n         *         threshold: string,\n         *         ignored_patterns: array<int, string>,\n         *     },\n         *     analysis: array{\n         *         warning_threshold: int,\n         *         redos_threshold: int,\n         *         ignore_patterns: array<int, string>,\n         *     },\n         * } $config\n         *\/\n        $config = $this->processConfiguration($configuration, $configs);\n\n        \/\/ If the bundle is disabled entirely, do nothing\n        if (!$config['enabled']) {\n            return;\n        }\n\n        $ignoredPatterns = array_values(array_unique([\n            ...$config['analysis']['ignore_patterns'],\n            ...$config['redos']['ignored_patterns'],\n        ]));\n\n        \/\/ Set parameters\n        $container->setParameter('regex_parser.max_pattern_length', $config['max_pattern_length']);\n        $container->setParameter('regex_parser.max_lookbehind_length', $config['max_lookbehind_length']);\n        $container->setParameter('regex_parser.cache', $config['cache']);\n        $container->setParameter('regex_parser.cache_pool', $config['cache_pool']);\n        $container->setParameter('regex_parser.cache_prefix', $config['cache_prefix']);\n        $container->setParameter('regex_parser.redos.threshold', $config['redos']['threshold']);\n        $container->setParameter('regex_parser.redos.ignored_patterns', $ignoredPatterns);\n        $container->setParameter('regex_parser.analysis.warning_threshold', $config['analysis']['warning_threshold']);\n        $container->setParameter('regex_parser.analysis.redos_threshold', $config['analysis']['redos_threshold']);\n        $container->setParameter('regex_parser.analysis.ignore_patterns', $ignoredPatterns);\n\n        $container->setDefinition('regex_parser.cache', $this->buildCacheDefinition($config));\n\n        $loader = new PhpFileLoader($container, new FileLocator(__DIR__.'\/..\/Resources\/config'));\n\n        $loader->load('services.php');\n    }\n\n    \/**\n     * @return string the configuration alias\n     *\/\n    #[\\Override]\n    public function getAlias(): string\n    {\n        return 'regex_parser';\n    }\n\n    \/**\n     * @param array{\n     *     cache: string|null,\n     *     cache_pool: string|null,\n     *     cache_prefix: string,\n     * } $config\n     *\/\n    private function buildCacheDefinition(array $config): Definition\n    {\n        if (null !== $config['cache_pool'] && '' !== $config['cache_pool']) {\n            return (new Definition(PsrCacheAdapter::class))\n                ->setArguments([\n                    new Reference((string) $config['cache_pool']),\n                    (string) $config['cache_prefix'],\n                ]);\n        }\n\n        if (null !== $config['cache'] && '' !== $config['cache']) {\n            return (new Definition(FilesystemCache::class))\n                ->setArguments([(string) $config['cache']]);\n        }\n\n        return new Definition(NullCache::class);\n    }\n}\n",
    "Bridge\/Symfony\/Analyzer\/RouteRequirementAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\nuse RegexParser\\ReDoS\\ReDoSSeverity;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Routing\\RouteCollection;\n\n\/**\n * Analyses Symfony route requirements and reports regex issues.\n *\n * @internal\n *\/\nfinal readonly class RouteRequirementAnalyzer\n{\n    private const PATTERN_DELIMITERS = ['\/', '#', '~', '%'];\n\n    private ReDoSSeverity $redosSeverityThreshold;\n\n    \/**\n     * @var list<string>\n     *\/\n    private array $ignoredPatterns;\n\n    \/**\n     * @param list<string> $ignoredPatterns\n     *\/\n    public function __construct(\n        private Regex $regex,\n        private int $warningThreshold,\n        string $redosThreshold = ReDoSSeverity::HIGH->value,\n        array $ignoredPatterns = [],\n    ) {\n        $this->redosSeverityThreshold = ReDoSSeverity::tryFrom(strtolower($redosThreshold)) ?? ReDoSSeverity::HIGH;\n        $this->ignoredPatterns = $this->buildIgnoredPatterns($ignoredPatterns);\n    }\n\n    \/**\n     * @return list<AnalysisIssue>\n     *\/\n    public function analyze(RouteCollection $routes): array\n    {\n        $issues = [];\n\n        foreach ($routes as $name => $route) {\n            foreach ($route->getRequirements() as $parameter => $requirement) {\n                if (!\\is_scalar($requirement)) {\n                    continue;\n                }\n\n                $pattern = trim((string) $requirement);\n                if ('' === $pattern) {\n                    continue;\n                }\n\n                $fragment = $this->extractFragment($pattern);\n                $normalizedPattern = $this->normalizePattern($pattern);\n                $body = $this->trimPatternBody($normalizedPattern);\n\n                if ($this->isIgnored($fragment) || $this->isIgnored($body)) {\n                    continue;\n                }\n\n                $isTrivial = $this->isTriviallySafe($fragment) || $this->isTriviallySafe($body);\n\n                $result = $this->regex->validate($normalizedPattern);\n\n                if ($isTrivial) {\n                    if (!$result->isValid) {\n                        $issues[] = new AnalysisIssue(\\sprintf('Route \"%s\" requirement \"%s\" is invalid: %s (pattern: %s)', (string) $name, $parameter, $result->error ?? 'unknown error', $this->formatPattern($normalizedPattern)), true);\n                    }\n\n                    continue;\n                }\n\n                if (!$result->isValid) {\n                    $issues[] = new AnalysisIssue(\n                        \\sprintf('Route \"%s\" requirement \"%s\" is invalid: %s (pattern: %s)', (string) $name, $parameter, $result->error ?? 'unknown error', $this->formatPattern($normalizedPattern)),\n                        true,\n                    );\n\n                    continue;\n                }\n\n                $redos = $this->regex->analyzeReDoS($normalizedPattern);\n                if ($redos->exceedsThreshold($this->redosSeverityThreshold)) {\n                    $issues[] = new AnalysisIssue(\n                        \\sprintf(\n                            'Route \"%s\" requirement \"%s\" may be vulnerable to ReDoS (severity: %s, pattern: %s).',\n                            (string) $name,\n                            $parameter,\n                            strtoupper($redos->severity->value),\n                            $this->formatPattern($normalizedPattern),\n                        ),\n                        true,\n                    );\n\n                    continue;\n                }\n\n                if ($result->complexityScore >= $this->warningThreshold) {\n                    $issues[] = new AnalysisIssue(\n                        \\sprintf('Route \"%s\" requirement \"%s\" is complex (score: %d, pattern: %s).', (string) $name, $parameter, $result->complexityScore, $this->formatPattern($normalizedPattern)),\n                        false,\n                    );\n                }\n            }\n        }\n\n        return $issues;\n    }\n\n    private function normalizePattern(string $pattern): string\n    {\n        $firstChar = $pattern[0] ?? '';\n\n        if (\\in_array($firstChar, self::PATTERN_DELIMITERS, true)) {\n            return $pattern;\n        }\n\n        if (str_starts_with($pattern, '^') && str_ends_with($pattern, '$')) {\n            return '#'.$pattern.'#';\n        }\n\n        $delimiter = '#';\n        $body = str_replace($delimiter, '\\\\'.$delimiter, $pattern);\n\n        return $delimiter.'^'.$body.'$'.$delimiter;\n    }\n\n    private function trimPatternBody(string $pattern): string\n    {\n        if ('' === $pattern) {\n            return '';\n        }\n\n        $first = $pattern[0];\n        $last = $pattern[-1];\n\n        if ($first === $last) {\n            $pattern = substr($pattern, 1, -1);\n        }\n\n        if (str_starts_with($pattern, '^')) {\n            $pattern = substr($pattern, 1);\n        }\n\n        if (str_ends_with($pattern, '$')) {\n            $pattern = substr($pattern, 0, -1);\n        }\n\n        return $pattern;\n    }\n\n    private function extractFragment(string $pattern): string\n    {\n        if ('' === $pattern) {\n            return '';\n        }\n\n        $first = $pattern[0];\n        $last = $pattern[-1];\n\n        if ($first === $last && \\in_array($first, self::PATTERN_DELIMITERS, true)) {\n            $pattern = substr($pattern, 1, -1);\n        }\n\n        if (str_starts_with($pattern, '^')) {\n            $pattern = substr($pattern, 1);\n        }\n\n        if (str_ends_with($pattern, '$')) {\n            $pattern = substr($pattern, 0, -1);\n        }\n\n        return $pattern;\n    }\n\n    private function formatPattern(string $pattern): string\n    {\n        if (\\strlen($pattern) <= 80) {\n            return $pattern;\n        }\n\n        return substr($pattern, 0, 77).'...';\n    }\n\n    private function isIgnored(string $body): bool\n    {\n        if ('' === $body) {\n            return false;\n        }\n\n        return \\in_array($body, $this->ignoredPatterns, true);\n    }\n\n    private function isTriviallySafe(string $body): bool\n    {\n        if ('' === $body) {\n            return false;\n        }\n\n        return 1 === preg_match('#^[A-Za-z0-9._-]+(?:\\|[A-Za-z0-9._-]+)+$#', $body);\n    }\n\n    \/**\n     * @param list<string> $userIgnored\n     *\n     * @return list<string>\n     *\/\n    private function buildIgnoredPatterns(array $userIgnored): array\n    {\n        return array_values(array_unique([...$this->regex->getRedosIgnoredPatterns(), ...$userIgnored]));\n    }\n}\n",
    "Bridge\/Symfony\/Analyzer\/AnalysisIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\n\/**\n * @internal\n *\/\nfinal readonly class AnalysisIssue\n{\n    public function __construct(\n        public string $message,\n        public bool $isError,\n    ) {}\n}\n",
    "Bridge\/Symfony\/Analyzer\/ValidatorRegexAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\nuse RegexParser\\ReDoS\\ReDoSSeverity;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Validator\\Constraint;\nuse Symfony\\Component\\Validator\\Constraints\\Regex as SymfonyRegex;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadataInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Mapping\\MetadataInterface;\nuse Symfony\\Component\\Validator\\Mapping\\PropertyMetadataInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n\/**\n * Analyses Symfony Validator metadata for Regex constraints.\n *\n * @internal\n *\/\nfinal readonly class ValidatorRegexAnalyzer\n{\n    private ReDoSSeverity $redosSeverityThreshold;\n\n    \/**\n     * @var list<string>\n     *\/\n    private array $ignoredPatterns;\n\n    \/**\n     * @param list<string> $ignoredPatterns\n     *\/\n    public function __construct(\n        private Regex $regex,\n        private int $warningThreshold,\n        string $redosThreshold = ReDoSSeverity::HIGH->value,\n        array $ignoredPatterns = [],\n    ) {\n        $this->redosSeverityThreshold = ReDoSSeverity::tryFrom(strtolower($redosThreshold)) ?? ReDoSSeverity::HIGH;\n        $this->ignoredPatterns = $this->buildIgnoredPatterns($ignoredPatterns);\n    }\n\n    \/**\n     * @return list<AnalysisIssue>\n     *\/\n    public function analyze(?ValidatorInterface $validator, ?LoaderInterface $loader): array\n    {\n        if (null === $validator) {\n            return [];\n        }\n\n        $classes = [];\n        if (null !== $loader && method_exists($loader, 'getMappedClasses')) {\n            $classes = $loader->getMappedClasses();\n        }\n\n        $issues = [];\n        foreach ($classes as $className) {\n            if (!\\is_string($className) || '' === $className) {\n                continue;\n            }\n\n            try {\n                $metadata = $validator->getMetadataFor($className);\n            } catch (\\Throwable) {\n                continue;\n            }\n\n            $issues = array_merge(\n                $issues,\n                $this->analyzeMetadata($metadata, $className),\n            );\n        }\n\n        return $issues;\n    }\n\n    \/**\n     * @return list<AnalysisIssue>\n     *\/\n    private function analyzeMetadata(MetadataInterface $metadata, string $className): array\n    {\n        $issues = [];\n        $constraints = [];\n\n        if ($metadata instanceof ClassMetadataInterface) {\n            $constraints = $metadata->getConstraints();\n\n            foreach ($metadata->getConstrainedProperties() as $propertyName) {\n                foreach ($metadata->getPropertyMetadata($propertyName) as $propertyMetadata) {\n                    if (!$propertyMetadata instanceof PropertyMetadataInterface) {\n                        continue;\n                    }\n\n                    $issues = array_merge(\n                        $issues,\n                        $this->analyzeConstraints(\n                            $propertyMetadata->getConstraints(),\n                            \\sprintf('%s::$%s', $className, $propertyMetadata->getName()),\n                        ),\n                    );\n                }\n            }\n        }\n\n        return array_merge(\n            $issues,\n            $this->analyzeConstraints($constraints, $className),\n        );\n    }\n\n    \/**\n     * @param array<Constraint> $constraints\n     *\n     * @return list<AnalysisIssue>\n     *\/\n    private function analyzeConstraints(array $constraints, string $source): array\n    {\n        $issues = [];\n\n        foreach ($constraints as $constraint) {\n            if (!$constraint instanceof SymfonyRegex || null === $constraint->pattern || '' === $constraint->pattern) {\n                continue;\n            }\n\n            $pattern = (string) $constraint->pattern;\n            $fragment = $this->extractFragment($pattern);\n            $body = $this->trimPatternBody($pattern);\n\n            if ($this->isIgnored($fragment) || $this->isIgnored($body)) {\n                continue;\n            }\n\n            $isTrivial = $this->isTriviallySafe($fragment) || $this->isTriviallySafe($body);\n\n            $result = $this->regex->validate($pattern);\n\n            if ($isTrivial) {\n                if (!$result->isValid) {\n                    $issues[] = new AnalysisIssue(\\sprintf('Validator \"%s\" pattern is invalid: %s (pattern: %s)', $source, $result->error ?? 'unknown error', $this->formatPattern($pattern)), true);\n                }\n\n                continue;\n            }\n\n            if (!$result->isValid) {\n                $issues[] = new AnalysisIssue(\n                    \\sprintf('Validator \"%s\" pattern is invalid: %s (pattern: %s)', $source, $result->error ?? 'unknown error', $this->formatPattern($pattern)),\n                    true,\n                );\n\n                continue;\n            }\n\n            $redos = $this->regex->analyzeReDoS($pattern);\n            if ($redos->exceedsThreshold($this->redosSeverityThreshold)) {\n                $issues[] = new AnalysisIssue(\n                    \\sprintf(\n                        'Validator \"%s\" pattern may be vulnerable to ReDoS (severity: %s, pattern: %s).',\n                        $source,\n                        strtoupper($redos->severity->value),\n                        $this->formatPattern($pattern),\n                    ),\n                    true,\n                );\n\n                continue;\n            }\n\n            if ($result->complexityScore >= $this->warningThreshold) {\n                $issues[] = new AnalysisIssue(\n                    \\sprintf('Validator \"%s\" pattern is complex (score: %d, pattern: %s).', $source, $result->complexityScore, $this->formatPattern($pattern)),\n                    false,\n                );\n            }\n        }\n\n        return $issues;\n    }\n\n    private function formatPattern(string $pattern): string\n    {\n        if (\\strlen($pattern) <= 80) {\n            return $pattern;\n        }\n\n        return substr($pattern, 0, 77).'...';\n    }\n\n    private function trimPatternBody(string $pattern): string\n    {\n        if ('' === $pattern) {\n            return '';\n        }\n\n        $first = $pattern[0];\n        $last = $pattern[-1];\n\n        if ($first === $last) {\n            $pattern = substr($pattern, 1, -1);\n        }\n\n        if (str_starts_with($pattern, '^')) {\n            $pattern = substr($pattern, 1);\n        }\n\n        if (str_ends_with($pattern, '$')) {\n            $pattern = substr($pattern, 0, -1);\n        }\n\n        return $pattern;\n    }\n\n    private function extractFragment(string $pattern): string\n    {\n        if ('' === $pattern) {\n            return '';\n        }\n\n        $first = $pattern[0];\n        $last = $pattern[-1];\n\n        if ($first === $last && \\in_array($first, ['\/', '#', '~', '%'], true)) {\n            $pattern = substr($pattern, 1, -1);\n        }\n\n        if (str_starts_with($pattern, '^')) {\n            $pattern = substr($pattern, 1);\n        }\n\n        if (str_ends_with($pattern, '$')) {\n            $pattern = substr($pattern, 0, -1);\n        }\n\n        return $pattern;\n    }\n\n    private function isIgnored(string $body): bool\n    {\n        if ('' === $body) {\n            return false;\n        }\n\n        return \\in_array($body, $this->ignoredPatterns, true);\n    }\n\n    private function isTriviallySafe(string $body): bool\n    {\n        if ('' === $body) {\n            return false;\n        }\n\n        return 1 === preg_match('#^[A-Za-z0-9._-]+(?:\\|[A-Za-z0-9._-]+)+$#', $body);\n    }\n\n    \/**\n     * @param list<string> $userIgnored\n     *\n     * @return list<string>\n     *\/\n    private function buildIgnoredPatterns(array $userIgnored): array\n    {\n        return array_values(array_unique([...$this->regex->getRedosIgnoredPatterns(), ...$userIgnored]));\n    }\n}\n",
    "TestCaseGenerationResult.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Captures generated test cases for a regex pattern.\n *\/\nfinal readonly class TestCaseGenerationResult\n{\n    \/**\n     * @param list<string> $matching\n     * @param list<string> $nonMatching\n     * @param list<string> $notes\n     *\/\n    public function __construct(\n        public array $matching,\n        public array $nonMatching,\n        public array $notes = [],\n    ) {}\n}\n",
    "RegexOptions.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\nuse RegexParser\\Cache\\CacheInterface;\nuse RegexParser\\Cache\\FilesystemCache;\nuse RegexParser\\Cache\\NullCache;\nuse RegexParser\\Exception\\InvalidRegexOptionException;\n\n\/**\n * High-performance immutable configuration for Regex::create().\n *\n * This optimized options class provides intelligent validation, caching,\n * and efficient option processing for maximum performance.\n *\/\nfinal readonly class RegexOptions\n{\n    private const ALLOWED_KEYS = ['max_pattern_length', 'max_lookbehind_length', 'cache', 'redos_ignored_patterns'];\n\n    \/**\n     * @param array<string> $redosIgnoredPatterns\n     *\/\n    public function __construct(\n        public int $maxPatternLength,\n        public int $maxLookbehindLength,\n        public CacheInterface $cache,\n        public array $redosIgnoredPatterns = [],\n    ) {}\n\n    \/**\n     * Optimized array-based configuration with intelligent validation.\n     *\n     * @param array<string, mixed> $options\n     *\/\n    public static function fromArray(array $options): self\n    {\n        \/\/ Fast path for empty options\n        if ([] === $options) {\n            return new self(\n                Regex::DEFAULT_MAX_PATTERN_LENGTH,\n                Regex::DEFAULT_MAX_LOOKBEHIND_LENGTH,\n                new NullCache(),\n                [],\n            );\n        }\n\n        \/\/ Validate unknown keys with optimized check\n        self::validateKeys($options);\n\n        \/\/ Extract and validate options with early returns\n        $maxPatternLength = self::validateMaxPatternLength($options);\n        $maxLookbehindLength = self::validateMaxLookbehindLength($options);\n        $cache = self::validateAndNormalizeCache($options);\n        $redosIgnoredPatterns = self::validateAndNormalizeRedosPatterns($options);\n\n        return new self($maxPatternLength, $maxLookbehindLength, $cache, $redosIgnoredPatterns);\n    }\n\n    \/**\n     * High-performance key validation with clear error messages.\n     *\n     * @param array<string, mixed> $options\n     *\/\n    private static function validateKeys(array $options): void\n    {\n        $unknownKeys = [];\n        foreach (array_keys($options) as $key) {\n            if (!\\in_array($key, self::ALLOWED_KEYS, true)) {\n                $unknownKeys[] = $key;\n            }\n        }\n\n        if ([] !== $unknownKeys) {\n            throw new InvalidRegexOptionException(\\sprintf(\n                'Unknown option(s): %s. Allowed options are: %s.',\n                implode(', ', $unknownKeys),\n                implode(', ', self::ALLOWED_KEYS),\n            ));\n        }\n    }\n\n    \/**\n     * Optimized max pattern length validation.\n     *\n     * @param array<string, mixed> $options\n     *\/\n    private static function validateMaxPatternLength(array $options): int\n    {\n        $value = $options['max_pattern_length'] ?? Regex::DEFAULT_MAX_PATTERN_LENGTH;\n\n        if (!\\is_int($value) || $value <= 0) {\n            throw new InvalidRegexOptionException('\"max_pattern_length\" must be a positive integer.');\n        }\n\n        return $value;\n    }\n\n    \/**\n     * @param array<string, mixed> $options\n     *\/\n    private static function validateMaxLookbehindLength(array $options): int\n    {\n        $value = $options['max_lookbehind_length'] ?? Regex::DEFAULT_MAX_LOOKBEHIND_LENGTH;\n\n        if (!\\is_int($value) || $value < 0) {\n            throw new InvalidRegexOptionException('\"max_lookbehind_length\" must be a non-negative integer.');\n        }\n\n        return $value;\n    }\n\n    \/**\n     * Intelligent cache validation and normalization.\n     *\n     * @param array<string, mixed> $options\n     *\/\n    private static function validateAndNormalizeCache(array $options): CacheInterface\n    {\n        $cache = $options['cache'] ?? null;\n\n        if (null === $cache) {\n            return new NullCache();\n        }\n\n        if (\\is_string($cache)) {\n            if ('' === trim($cache)) {\n                throw new InvalidRegexOptionException('The \"cache\" option cannot be an empty string.');\n            }\n\n            return new FilesystemCache($cache);\n        }\n\n        if ($cache instanceof CacheInterface) {\n            return $cache;\n        }\n\n        throw new InvalidRegexOptionException(\n            'The \"cache\" option must be null, a cache path, or a CacheInterface implementation.',\n        );\n    }\n\n    \/**\n     * High-performance ReDoS patterns validation and normalization.\n     *\n     * @param array<string, mixed> $options\n     *\n     * @return array<string>\n     *\/\n    private static function validateAndNormalizeRedosPatterns(array $options): array\n    {\n        $patterns = $options['redos_ignored_patterns'] ?? [];\n\n        if (!\\is_array($patterns)) {\n            throw new InvalidRegexOptionException('\"redos_ignored_patterns\" must be a list of strings.');\n        }\n\n        if ([] === $patterns) {\n            return [];\n        }\n\n        \/\/ Validate all patterns are strings\n        foreach ($patterns as $pattern) {\n            if (!\\is_string($pattern)) {\n                throw new InvalidRegexOptionException('\"redos_ignored_patterns\" must contain only strings.');\n            }\n        }\n\n        \/\/ Efficient deduplication and normalization\n        \/** @var array<string> $result *\/\n        $result = array_values(array_unique($patterns));\n\n        return $result;\n    }\n}\n",
    "VisualizationResult.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Holds visualization output formats for a regex pattern.\n *\/\nfinal readonly class VisualizationResult\n{\n    public function __construct(\n        public string $mermaid,\n        public ?string $svg = null,\n        public ?string $renderedHtml = null,\n    ) {}\n}\n",
    "LiteralSet.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * High-performance immutable set of literal strings extracted from regex patterns.\n *\n * This optimized data structure provides efficient literal extraction with intelligent\n * size limits, lazy evaluation, and memory-efficient operations for regex optimization.\n *\/\nfinal readonly class LiteralSet\n{\n    private const MAX_SET_SIZE = 100; \/\/ Prevent memory explosion\n    private const MAX_STRING_LENGTH = 1000; \/\/ Prevent extremely long literals\n\n    \/**\n     * @var array<string>\n     *\/\n    public array $prefixes;\n\n    \/**\n     * @var array<string>\n     *\/\n    public array $suffixes;\n\n    \/**\n     * @param array<string> $prefixes\n     * @param array<string> $suffixes\n     *\/\n    public function __construct(\n        array $prefixes = [],\n        array $suffixes = [],\n        public bool $complete = false,\n    ) {\n        \/\/ Enforce size limits to prevent performance degradation\n        $this->prefixes = \\count($prefixes) > self::MAX_SET_SIZE\n            ? \\array_slice($prefixes, 0, self::MAX_SET_SIZE)\n            : $prefixes;\n\n        $this->suffixes = \\count($suffixes) > self::MAX_SET_SIZE\n            ? \\array_slice($suffixes, 0, self::MAX_SET_SIZE)\n            : $suffixes;\n    }\n\n    public static function empty(): self\n    {\n        return new self([], [], false);\n    }\n\n    public static function fromString(string $literal): self\n    {\n        \/\/ Limit string length to prevent memory issues\n        if (\\strlen($literal) > self::MAX_STRING_LENGTH) {\n            return self::empty();\n        }\n\n        return new self([$literal], [$literal], true);\n    }\n\n    public function concat(self $other): self\n    {\n        $newPrefixes = $this->prefixes;\n        $newSuffixes = $other->suffixes;\n        $newComplete = $this->complete && $other->complete;\n\n        \/\/ Only compute cross products when necessary and possible\n        if ($this->complete && !empty($other->prefixes)) {\n            $newPrefixes = $this->crossProduct($this->prefixes, $other->prefixes);\n        }\n\n        if ($other->complete && !empty($this->suffixes)) {\n            $newSuffixes = $this->crossProduct($this->suffixes, $other->suffixes);\n        }\n\n        return new self(\n            $this->deduplicate($newPrefixes),\n            $this->deduplicate($newSuffixes),\n            $newComplete,\n        );\n    }\n\n    public function unite(self $other): self\n    {\n        \/\/ Fast path for identical sets\n        if ($this === $other) {\n            return $this;\n        }\n\n        $newPrefixes = array_merge($this->prefixes, $other->prefixes);\n        $newSuffixes = array_merge($this->suffixes, $other->suffixes);\n        $newComplete = $this->complete && $other->complete;\n\n        return new self(\n            $this->deduplicate($newPrefixes),\n            $this->deduplicate($newSuffixes),\n            $newComplete,\n        );\n    }\n\n    public function getLongestPrefix(): ?string\n    {\n        return $this->computeLongestString($this->prefixes);\n    }\n\n    public function getLongestSuffix(): ?string\n    {\n        return $this->computeLongestString($this->suffixes);\n    }\n\n    public function isVoid(): bool\n    {\n        return empty($this->prefixes) && empty($this->suffixes);\n    }\n\n    \/**\n     * Optimized cross product with size limits and early termination.\n     *\n     * @param array<string> $left\n     * @param array<string> $right\n     *\n     * @return array<string>\n     *\/\n    private function crossProduct(array $left, array $right): array\n    {\n        $result = [];\n        $maxResults = self::MAX_SET_SIZE;\n\n        foreach ($left as $l) {\n            foreach ($right as $r) {\n                $combined = $l.$r;\n\n                \/\/ Skip if result would be too long\n                if (\\strlen($combined) > self::MAX_STRING_LENGTH) {\n                    continue;\n                }\n\n                $result[] = $combined;\n\n                \/\/ Early termination if we hit the limit\n                if (\\count($result) >= $maxResults) {\n                    return $result;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Memory-efficient deduplication with size limits.\n     *\n     * @param array<string> $items\n     *\n     * @return array<string>\n     *\/\n    private function deduplicate(array $items): array\n    {\n        if (empty($items)) {\n            return [];\n        }\n\n        $unique = array_unique($items);\n\n        \/\/ Enforce size limit after deduplication\n        if (\\count($unique) > self::MAX_SET_SIZE) {\n            $unique = \\array_slice($unique, 0, self::MAX_SET_SIZE, true);\n        }\n\n        return array_values($unique);\n    }\n\n    \/**\n     * Optimized longest string computation with early termination.\n     *\n     * @param array<string> $candidates\n     *\/\n    \/**\n     * @param array<string> $candidates\n     *\/\n    private function computeLongestString(array $candidates): ?string\n    {\n        if (empty($candidates)) {\n            return null;\n        }\n\n        $longest = '';\n        $maxLength = 0;\n\n        foreach ($candidates as $candidate) {\n            $length = \\strlen($candidate);\n            if ($length > $maxLength) {\n                $longest = $candidate;\n                $maxLength = $length;\n            }\n        }\n\n        \/\/ Handle edge case where longest is empty string but empty isn't in candidates\n        return 0 === $maxLength && !\\in_array('', $candidates, true) ? null : $longest;\n    }\n}\n",
    "OptimizationResult.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Captures optimization output with a simple change log.\n *\/\nfinal readonly class OptimizationResult\n{\n    \/**\n     * @param list<string> $changes\n     *\/\n    public function __construct(\n        public string $original,\n        public string $optimized,\n        public array $changes = [],\n    ) {}\n\n    public function isChanged(): bool\n    {\n        return $this->original !== $this->optimized;\n    }\n}\n",
    "GroupNumberingCollector.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\nuse RegexParser\\Node\\GroupType;\n\n\/**\n * Collects PCRE-aware group numbering metadata, including branch reset groups.\n *\/\nfinal class GroupNumberingCollector\n{\n    private int $nextGroupNumber = 1;\n\n    private int $maxGroupNumber = 0;\n\n    \/**\n     * @var list<int>\n     *\/\n    private array $captureSequence = [];\n\n    \/**\n     * @var array<string, list<int>>\n     *\/\n    private array $namedGroups = [];\n\n    public function collect(Node\\RegexNode $node): GroupNumbering\n    {\n        $this->nextGroupNumber = 1;\n        $this->maxGroupNumber = 0;\n        $this->captureSequence = [];\n        $this->namedGroups = [];\n\n        $this->collectNode($node->pattern);\n\n        foreach ($this->namedGroups as $name => $numbers) {\n            $this->namedGroups[$name] = array_values(array_unique($numbers));\n        }\n\n        return new GroupNumbering($this->maxGroupNumber, $this->captureSequence, $this->namedGroups);\n    }\n\n    private function collectNode(Node\\NodeInterface $node): void\n    {\n        if ($node instanceof Node\\GroupNode) {\n            if (GroupType::T_GROUP_BRANCH_RESET === $node->type) {\n                $this->collectBranchReset($node);\n\n                return;\n            }\n\n            if (GroupType::T_GROUP_CAPTURING === $node->type || GroupType::T_GROUP_NAMED === $node->type) {\n                $this->registerCapturingGroup($node);\n            }\n\n            $this->collectNode($node->child);\n\n            return;\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            foreach ($node->alternatives as $alt) {\n                $this->collectNode($alt);\n            }\n\n            return;\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            foreach ($node->children as $child) {\n                $this->collectNode($child);\n            }\n\n            return;\n        }\n\n        if ($node instanceof Node\\QuantifierNode) {\n            $this->collectNode($node->node);\n\n            return;\n        }\n\n        if ($node instanceof Node\\ConditionalNode) {\n            $this->collectNode($node->condition);\n            $this->collectNode($node->yes);\n            $this->collectNode($node->no);\n\n            return;\n        }\n\n        if ($node instanceof Node\\DefineNode) {\n            $this->collectNode($node->content);\n\n            return;\n        }\n\n        if ($node instanceof Node\\CharClassNode) {\n            $this->collectNode($node->expression);\n\n            return;\n        }\n\n        if ($node instanceof Node\\ClassOperationNode) {\n            $this->collectNode($node->left);\n            $this->collectNode($node->right);\n\n            return;\n        }\n\n        if ($node instanceof Node\\RangeNode) {\n            $this->collectNode($node->start);\n            $this->collectNode($node->end);\n        }\n    }\n\n    private function registerCapturingGroup(Node\\GroupNode $node): void\n    {\n        $number = $this->nextGroupNumber++;\n        $this->captureSequence[] = $number;\n        $this->maxGroupNumber = max($this->maxGroupNumber, $number);\n\n        if (GroupType::T_GROUP_NAMED === $node->type && null !== $node->name) {\n            $this->namedGroups[$node->name][] = $number;\n        }\n    }\n\n    private function collectBranchReset(Node\\GroupNode $node): void\n    {\n        $base = $this->nextGroupNumber;\n        $maxExtra = 0;\n\n        $alternatives = $node->child instanceof Node\\AlternationNode\n            ? $node->child->alternatives\n            : [$node->child];\n\n        foreach ($alternatives as $alt) {\n            $this->nextGroupNumber = $base;\n            $this->collectNode($alt);\n            $maxExtra = max($maxExtra, $this->nextGroupNumber - $base);\n        }\n\n        $this->nextGroupNumber = $base + $maxExtra;\n        $this->maxGroupNumber = max($this->maxGroupNumber, $this->nextGroupNumber - 1);\n    }\n}\n",
    "TolerantParseResult.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Outcome of a tolerant parse attempt.\n *\/\nfinal readonly class TolerantParseResult\n{\n    \/**\n     * @param array<\\Throwable> $errors\n     *\/\n    public function __construct(\n        public \\RegexParser\\Node\\RegexNode $ast,\n        public array $errors = [],\n    ) {}\n\n    public function hasErrors(): bool\n    {\n        return !empty($this->errors);\n    }\n}\n",
    "ValidationErrorCategory.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Categorizes validation errors for diagnostics and UX.\n *\/\nenum ValidationErrorCategory: string\n{\n    case SYNTAX = 'syntax';\n    case SEMANTIC = 'semantic';\n    case PCRE_RUNTIME = 'pcre-runtime';\n}\n",
    "ReDoS\/ReDoSConfidence.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\n\/**\n * Represents confidence in static ReDoS findings.\n *\/\nenum ReDoSConfidence: string\n{\n    case LOW = 'low';\n    case MEDIUM = 'medium';\n    case HIGH = 'high';\n}\n",
    "ReDoS\/CharSetAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\nuse RegexParser\\Node;\n\n\/**\n * Approximates leading\/trailing character sets for AST nodes.\n *\n * Used to detect mutually exclusive boundaries that avoid catastrophic backtracking.\n *\/\nfinal class CharSetAnalyzer\n{\n    public function firstChars(Node\\NodeInterface $node): CharSet\n    {\n        return $this->walk($node, true);\n    }\n\n    public function lastChars(Node\\NodeInterface $node): CharSet\n    {\n        return $this->walk($node, false);\n    }\n\n    private function walk(Node\\NodeInterface $node, bool $fromStart): CharSet\n    {\n        if ($node instanceof Node\\LiteralNode) {\n            return CharSet::fromChar($fromStart ? $node->value[0] : $node->value[\\strlen($node->value) - 1]);\n        }\n\n        if ($node instanceof Node\\CharTypeNode) {\n            return $this->fromCharType($node->value);\n        }\n\n        if ($node instanceof Node\\DotNode) {\n            return CharSet::full();\n        }\n\n        if ($node instanceof Node\\QuantifierNode) {\n            return $this->walk($node->node, $fromStart);\n        }\n\n        if ($node instanceof Node\\RangeNode) {\n            $start = $this->literalCodepoint($node->start);\n            $end = $this->literalCodepoint($node->end);\n\n            if (null === $start || null === $end) {\n                return CharSet::unknown();\n            }\n\n            return CharSet::fromRange(min($start, $end), max($start, $end));\n        }\n\n        if ($node instanceof Node\\CharClassNode) {\n            $set = CharSet::empty();\n\n            $parts = $node->expression instanceof Node\\AlternationNode ? $node->expression->alternatives : [$node->expression];\n            foreach ($parts as $part) {\n                $candidate = $this->walk($part, $fromStart);\n                $set = $set->union($candidate);\n            }\n\n            return $node->isNegated ? $set->complement() : $set;\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->walk($node->child, $fromStart);\n        }\n\n        if ($node instanceof Node\\AlternationNode) {\n            $set = CharSet::empty();\n            foreach ($node->alternatives as $alt) {\n                $set = $set->union($this->walk($alt, $fromStart));\n            }\n\n            return $set;\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            $children = $fromStart ? $node->children : array_reverse($node->children);\n            $set = CharSet::empty();\n\n            foreach ($children as $child) {\n                $candidate = $this->walk($child, $fromStart);\n                $set = $set->union($candidate);\n\n                if (!$this->isOptionalNode($child, $fromStart)) {\n                    break;\n                }\n            }\n\n            return $set;\n        }\n\n        return CharSet::unknown();\n    }\n\n    private function fromCharType(string $type): CharSet\n    {\n        return match ($type) {\n            'd' => CharSet::fromRange(\\ord('0'), \\ord('9')),\n            'D' => CharSet::fromRange(\\ord('0'), \\ord('9'))->complement(),\n            'w' => CharSet::fromRange(\\ord('0'), \\ord('9'))\n                ->union(CharSet::fromRange(\\ord('A'), \\ord('Z')))\n                ->union(CharSet::fromRange(\\ord('a'), \\ord('z')))\n                ->union(CharSet::fromChar('_')),\n            'W' => CharSet::fromRange(\\ord('0'), \\ord('9'))\n                ->union(CharSet::fromRange(\\ord('A'), \\ord('Z')))\n                ->union(CharSet::fromRange(\\ord('a'), \\ord('z')))\n                ->union(CharSet::fromChar('_'))\n                ->complement(),\n            's' => $this->whitespace(),\n            'S' => $this->whitespace()->complement(),\n            default => CharSet::unknown(),\n        };\n    }\n\n    private function whitespace(): CharSet\n    {\n        $set = CharSet::empty();\n        foreach ([9, 10, 11, 12, 13, 32] as $code) {\n            $set = $set->union(CharSet::fromRange($code, $code));\n        }\n\n        return $set;\n    }\n\n    private function literalCodepoint(Node\\NodeInterface $node): ?int\n    {\n        return $node instanceof Node\\LiteralNode ? \\ord($node->value[0]) : null;\n    }\n\n    private function isOptional(Node\\QuantifierNode $node): bool\n    {\n        return 0 === $this->quantifierMin($node->quantifier);\n    }\n\n    private function quantifierMin(string $quantifier): int\n    {\n        if (str_contains($quantifier, '*') || str_contains($quantifier, '?')) {\n            return 0;\n        }\n\n        if (str_contains($quantifier, '+')) {\n            return 1;\n        }\n\n        if (preg_match('\/\\{(\\d++)(?:,(\\d++)?)?\\}\/', $quantifier, $matches)) {\n            return (int) $matches[1];\n        }\n\n        return 1;\n    }\n\n    private function isOptionalNode(Node\\NodeInterface $node, bool $fromStart): bool\n    {\n        if ($node instanceof Node\\QuantifierNode) {\n            return $this->isOptional($node);\n        }\n\n        if ($node instanceof Node\\GroupNode) {\n            return $this->isOptionalNode($node->child, $fromStart);\n        }\n\n        if ($node instanceof Node\\SequenceNode) {\n            $children = $fromStart ? $node->children : array_reverse($node->children);\n            foreach ($children as $child) {\n                if ($this->isOptionalNode($child, $fromStart)) {\n                    continue;\n                }\n\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n}\n",
    "ReDoS\/CharSet.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\n\/**\n * Lightweight character set representation with basic set operations.\n *\/\nfinal readonly class CharSet\n{\n    private const ASCII_MAX = 0x7F;\n\n    \/**\n     * @param array<array{0:int, 1:int}> $ranges inclusive ranges of byte values\n     *\/\n    private function __construct(\n        private array $ranges = [],\n        private bool $unknown = false,\n    ) {}\n\n    public static function empty(): self\n    {\n        return new self();\n    }\n\n    public static function unknown(): self\n    {\n        return new self([], true);\n    }\n\n    public static function full(): self\n    {\n        return new self([[0, self::ASCII_MAX]]);\n    }\n\n    public static function fromRange(int $start, int $end): self\n    {\n        return new self([[max(0, $start), min(self::ASCII_MAX, $end)]]);\n    }\n\n    public static function fromChar(string $char): self\n    {\n        return '' === $char ? self::empty() : new self([[\\ord($char[0]), \\ord($char[0])]]);\n    }\n\n    public function isEmpty(): bool\n    {\n        return !$this->unknown && [] === $this->ranges;\n    }\n\n    public function isUnknown(): bool\n    {\n        return $this->unknown;\n    }\n\n    public function union(self $other): self\n    {\n        if ($this->unknown || $other->unknown) {\n            return self::unknown();\n        }\n\n        $merged = array_merge($this->ranges, $other->ranges);\n        if ([] === $merged) {\n            return self::empty();\n        }\n\n        usort($merged, static fn (array $a, array $b): int => $a[0] <=> $b[0]);\n\n        $result = [];\n        foreach ($merged as [$start, $end]) {\n            if ([] === $result) {\n                $result[] = [$start, $end];\n\n                continue;\n            }\n\n            [$lastStart, $lastEnd] = $result[\\count($result) - 1];\n            if ($start <= $lastEnd + 1) {\n                $result[\\count($result) - 1] = [$lastStart, max($lastEnd, $end)];\n\n                continue;\n            }\n\n            $result[] = [$start, $end];\n        }\n\n        return new self($result);\n    }\n\n    public function intersects(self $other): bool\n    {\n        if ($this->unknown || $other->unknown) {\n            return true;\n        }\n\n        foreach ($this->ranges as [$start, $end]) {\n            foreach ($other->ranges as [$oStart, $oEnd]) {\n                if ($start <= $oEnd && $oStart <= $end) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public function complement(): self\n    {\n        if ($this->unknown) {\n            return self::unknown();\n        }\n\n        if ([] === $this->ranges) {\n            return self::full();\n        }\n\n        $complement = [];\n        $cursor = 0;\n\n        foreach ($this->ranges as [$start, $end]) {\n            if ($cursor < $start) {\n                $complement[] = [$cursor, $start - 1];\n            }\n            $cursor = $end + 1;\n        }\n\n        if ($cursor <= self::ASCII_MAX) {\n            $complement[] = [$cursor, self::ASCII_MAX];\n        }\n\n        return new self($complement);\n    }\n}\n",
    "ReDoS\/ReDoSAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\nuse RegexParser\\NodeVisitor\\ReDoSProfileNodeVisitor;\nuse RegexParser\\Regex;\n\nfinal class ReDoSAnalyzer\n{\n    \/**\n     * @var list<string>\n     *\/\n    private array $ignoredPatternsNormalized = [];\n\n    \/**\n     * @param list<string> $ignoredPatterns\n     *\/\n    public function __construct(\n        private readonly ?Regex $regex = null,\n        \/**\n         * @var list<string>\n         *\/\n        private array $ignoredPatterns = [],\n        private readonly ReDoSSeverity $threshold = ReDoSSeverity::HIGH,\n    ) {\n        $this->ignoredPatterns = array_values(array_unique($this->ignoredPatterns));\n        $this->ignoredPatternsNormalized = $this->normalizeIgnoredPatterns($this->ignoredPatterns);\n    }\n\n    public function analyze(string $regex, ?ReDoSSeverity $threshold = null): ReDoSAnalysis\n    {\n        $threshold ??= $this->threshold;\n\n        if ($this->shouldIgnore($regex)) {\n            return new ReDoSAnalysis(\n                ReDoSSeverity::SAFE,\n                0,\n                null,\n                [],\n                null,\n                null,\n                null,\n                ReDoSConfidence::LOW,\n                null,\n                [],\n            );\n        }\n\n        try {\n            $ast = ($this->regex ?? Regex::create())->parse($regex);\n            $visitor = new ReDoSProfileNodeVisitor();\n            $ast->accept($visitor);\n\n            $result = $visitor->getResult();\n\n            return new ReDoSAnalysis(\n                $result['severity'],\n                match ($result['severity']) {\n                    ReDoSSeverity::SAFE => 0,\n                    ReDoSSeverity::LOW => 2,\n                    ReDoSSeverity::MEDIUM => 5,\n                    ReDoSSeverity::HIGH => 8,\n                    ReDoSSeverity::CRITICAL => 10,\n                    ReDoSSeverity::UNKNOWN => 5,\n                },\n                $result['vulnerablePattern'],\n                array_values($result['recommendations']),\n                null,\n                $result['vulnerablePattern'],\n                $result['trigger'],\n                $result['confidence'],\n                $result['falsePositiveRisk'],\n                array_values($result['findings']),\n            );\n        } catch (\\Throwable $e) {\n            return new ReDoSAnalysis(\n                ReDoSSeverity::UNKNOWN,\n                0,\n                null,\n                ['Analysis incomplete: '.$e->getMessage()],\n                $e::class.': '.$e->getMessage(),\n                null,\n                null,\n                ReDoSConfidence::LOW,\n                null,\n                [],\n            );\n        }\n    }\n\n    private function shouldIgnore(string $regex): bool\n    {\n        if ([] === $this->ignoredPatterns) {\n            return false;\n        }\n\n        $normalized = $this->normalizePattern($regex);\n\n        return \\in_array($normalized, $this->ignoredPatternsNormalized, true)\n            || \\in_array($normalized, $this->ignoredPatterns, true)\n            || \\in_array($regex, $this->ignoredPatterns, true);\n    }\n\n    private function normalizePattern(string $regex): string\n    {\n        try {\n            [$pattern] = ($this->regex ?? Regex::create())->extractPatternAndFlags($regex);\n\n            return $pattern;\n        } catch (\\Throwable) {\n            return $regex;\n        }\n    }\n\n    \/**\n     * @param list<string> $patterns\n     *\n     * @return list<string>\n     *\/\n    private function normalizeIgnoredPatterns(array $patterns): array\n    {\n        $normalized = [];\n        foreach ($patterns as $pattern) {\n            $normalized[] = $this->normalizePattern($pattern);\n        }\n\n        return array_values(array_unique($normalized));\n    }\n}\n",
    "ReDoS\/ReDoSSeverity.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\n\/**\n * @api\n *\/\nenum ReDoSSeverity: string\n{\n    \/**\n     * No significant ReDoS risk detected.\n     *\/\n    case SAFE = 'safe';\n\n    \/**\n     * Low risk.\n     *\/\n    case LOW = 'low';\n\n    \/**\n     * Medium risk.\n     *\/\n    case MEDIUM = 'medium';\n\n    \/**\n     * Analysis could not determine the risk.\n     *\/\n    case UNKNOWN = 'unknown';\n\n    \/**\n     * High risk.\n     *\/\n    case HIGH = 'high';\n\n    \/**\n     * Critical risk.\n     *\/\n    case CRITICAL = 'critical';\n}\n",
    "ReDoS\/ReDoSAnalysis.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\n\/**\n * Encapsulates the results of a Regular Expression Denial of Service (ReDoS) analysis.\n *\n * @api\n *\/\nfinal readonly class ReDoSAnalysis\n{\n    public ?string $vulnerableSubpattern;\n\n    \/**\n     * @param list<string>       $recommendations\n     * @param list<ReDoSFinding> $findings\n     *\/\n    public function __construct(\n        public ReDoSSeverity $severity,\n        public int $score,\n        public ?string $vulnerablePart = null,\n        public array $recommendations = [],\n        public ?string $error = null,\n        ?string $vulnerableSubpattern = null,\n        public ?string $trigger = null,\n        public ?ReDoSConfidence $confidence = null,\n        public ?string $falsePositiveRisk = null,\n        public array $findings = [],\n    ) {\n        $this->vulnerableSubpattern = $vulnerableSubpattern ?? $vulnerablePart;\n    }\n\n    public function getVulnerableSubpattern(): ?string\n    {\n        return $this->vulnerableSubpattern ?? $this->vulnerablePart;\n    }\n\n    public function isSafe(): bool\n    {\n        return ReDoSSeverity::SAFE === $this->severity || ReDoSSeverity::LOW === $this->severity;\n    }\n\n    public function exceedsThreshold(ReDoSSeverity $threshold): bool\n    {\n        return $this->severityScore($this->severity) >= $this->severityScore($threshold);\n    }\n\n    private function severityScore(ReDoSSeverity $severity): int\n    {\n        return match ($severity) {\n            ReDoSSeverity::SAFE => 0,\n            ReDoSSeverity::LOW => 1,\n            ReDoSSeverity::UNKNOWN => 2,\n            ReDoSSeverity::MEDIUM => 3,\n            ReDoSSeverity::HIGH => 4,\n            ReDoSSeverity::CRITICAL => 5,\n        };\n    }\n}\n",
    "ReDoS\/ReDoSFinding.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\ReDoS;\n\n\/**\n * Describes a specific ReDoS risk detection.\n *\/\nfinal readonly class ReDoSFinding\n{\n    public function __construct(\n        public ReDoSSeverity $severity,\n        public string $message,\n        public string $pattern,\n        public ?string $trigger = null,\n        public ?string $suggestedRewrite = null,\n        public ReDoSConfidence $confidence = ReDoSConfidence::MEDIUM,\n        public ?string $falsePositiveRisk = null,\n    ) {}\n}\n",
    "Lexer.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\nuse RegexParser\\Exception\\LexerException;\n\n\/**\n * High-performance regex lexer with precompiled patterns and intelligent token recognition.\n *\n * This optimized lexer uses precompiled regex patterns and priority-based matching\n * for maximum performance while maintaining full compatibility with PCRE syntax.\n *\/\nfinal class Lexer\n{\n    \/\/ Token priority maps for efficient matching\n    private const TOKENS_OUTSIDE = [\n        'T_COMMENT_OPEN', 'T_CALLOUT', 'T_PCRE_VERB', 'T_GROUP_MODIFIER_OPEN',\n        'T_GROUP_OPEN', 'T_GROUP_CLOSE', 'T_CHAR_CLASS_OPEN', 'T_QUANTIFIER',\n        'T_ALTERNATION', 'T_DOT', 'T_ANCHOR', 'T_ASSERTION', 'T_KEEP',\n        'T_CHAR_TYPE', 'T_G_REFERENCE', 'T_BACKREF', 'T_OCTAL_LEGACY',\n        'T_OCTAL', 'T_UNICODE', 'T_UNICODE_PROP', 'T_UNICODE_NAMED',\n        'T_CONTROL_CHAR', 'T_QUOTE_MODE_START', 'T_QUOTE_MODE_END',\n        'T_LITERAL_ESCAPED', 'T_LITERAL',\n    ];\n\n    private const TOKENS_INSIDE = [\n        'T_CHAR_CLASS_CLOSE', 'T_POSIX_CLASS', 'T_CHAR_TYPE', 'T_OCTAL_LEGACY',\n        'T_OCTAL', 'T_UNICODE', 'T_UNICODE_PROP', 'T_UNICODE_NAMED',\n        'T_QUOTE_MODE_START', 'T_LITERAL_ESCAPED', 'T_CLASS_INTERSECTION',\n        'T_CLASS_SUBTRACTION', 'T_LITERAL',\n    ];\n\n    \/\/ Optimized regex patterns broken into focused components\n    private const PATTERNS_OUTSIDE = [\n        'T_COMMENT_OPEN' => '\\\\(\\\\?\\\\#',\n        'T_CALLOUT' => '\\\\(\\\\?C [^)]* \\\\)',\n        'T_PCRE_VERB' => '\\\\(\\\\* [^)]+ \\\\)',\n        'T_GROUP_MODIFIER_OPEN' => '\\\\(\\\\?',\n        'T_GROUP_OPEN' => '\\\\(',\n        'T_GROUP_CLOSE' => '\\\\)',\n        'T_CHAR_CLASS_OPEN' => '\\\\[',\n        'T_QUANTIFIER' => '(?: [\\\\*\\\\+\\\\?] | \\\\{\\\\d+(?:,\\\\d*)?\\\\} ) [\\\\?\\\\+]?',\n        'T_ALTERNATION' => '\\\\|',\n        'T_DOT' => '\\\\.',\n        'T_ANCHOR' => '\\\\^|\\\\$',\n        'T_ASSERTION' => '\\\\\\\\ (?: b\\\\{g\\\\} | B\\\\{g\\\\} | [AzZGbB] )',\n        'T_KEEP' => '\\\\\\\\ K',\n        'T_CHAR_TYPE' => '\\\\\\\\ [dswDSWhvRCX]',\n        'T_G_REFERENCE' => '\\\\\\\\ g (?: \\\\{[a-zA-Z0-9_+-]+\\\\} | <[a-zA-Z0-9_]+> | [0-9+-]+ )?',\n        'T_BACKREF' => '\\\\\\\\ (?: k(?:<[a-zA-Z0-9_]+> | \\\\{[a-zA-Z0-9_]+\\\\}) | (?<v_backref_num> [1-9]\\\\d*) )',\n        'T_OCTAL_LEGACY' => '\\\\\\\\ [0-7]{1,3}',\n        'T_OCTAL' => '\\\\\\\\ o\\\\{[0-7]+\\\\}',\n        'T_UNICODE' => '\\\\\\\\ x [0-9a-fA-F]{1,2} | \\\\\\\\ u\\\\{[0-9a-fA-F]+\\\\} | \\\\\\\\ x\\\\{[0-9a-fA-F]+\\\\}',\n        'T_UNICODE_PROP' => '\\\\\\\\ [pP] (?: \\\\{ (?<v1_prop> \\\\^? [a-zA-Z0-9_]+) \\\\} | (?<v2_prop> [a-zA-Z]) )',\n        'T_UNICODE_NAMED' => '\\\\\\\\ N\\\\{[a-zA-Z0-9_ ]+\\\\}',\n        'T_CONTROL_CHAR' => '\\\\\\\\ c [A-Z]',\n        'T_QUOTE_MODE_START' => '\\\\\\\\ Q',\n        'T_QUOTE_MODE_END' => '\\\\\\\\ E',\n        'T_LITERAL_ESCAPED' => '\\\\\\\\ .',\n        'T_LITERAL' => '[^\\\\\\\\]',\n    ];\n\n    private const PATTERNS_INSIDE = [\n        'T_CHAR_CLASS_CLOSE' => '\\\\]',\n        'T_POSIX_CLASS' => '\\\\[ \\\\: (?<v_posix> \\\\^? [a-zA-Z]+) \\\\: \\\\]',\n        'T_CHAR_TYPE' => '\\\\\\\\ [dswDSWhvR]',\n        'T_OCTAL_LEGACY' => '\\\\\\\\ 0[0-7]{0,2}',\n        'T_OCTAL' => '\\\\\\\\ o\\\\{[0-7]+\\\\}',\n        'T_UNICODE' => '\\\\\\\\ x [0-9a-fA-F]{1,2} | \\\\\\\\ u\\\\{[0-9a-fA-F]+\\\\} | \\\\\\\\ x\\\\{[0-9a-fA-F]+\\\\}',\n        'T_UNICODE_PROP' => '\\\\\\\\ [pP] (?: \\\\{ (?<v1_prop> \\\\^? [a-zA-Z0-9_]+) \\\\} | (?<v2_prop> [a-zA-Z]) )',\n        'T_QUOTE_MODE_START' => '\\\\\\\\ Q',\n        'T_LITERAL_ESCAPED' => '\\\\\\\\ .',\n        'T_CLASS_INTERSECTION' => '&&',\n        'T_CLASS_SUBTRACTION' => '--',\n        'T_LITERAL' => '[^\\\\\\\\]',\n    ];\n\n    \/\/ Precompiled regex patterns for maximum performance\n    private static ?string $regexOutside = null;\n\n    private static ?string $regexInside = null;\n\n    private string $pattern;\n\n    private int $position = 0;\n\n    private int $length = 0;\n\n    private bool $inCharClass = false;\n\n    private bool $inQuoteMode = false;\n\n    private bool $inCommentMode = false;\n\n    private int $charClassStartPosition = 0;\n\n    public function tokenize(string $pattern): TokenStream\n    {\n        if (!preg_match('\/\/u', $pattern)) {\n            throw LexerException::withContext('Input string is not valid UTF-8.', 0, $pattern);\n        }\n\n        $this->pattern = $pattern;\n        $this->length = \\strlen($this->pattern);\n        $this->resetState();\n\n        \/** @var array<Token> $tokens *\/\n        $tokens = [];\n\n        while ($this->position < $this->length) {\n            if ($this->handleTunnelModes($tokens)) {\n                continue;\n            }\n\n            [$regex, $tokenMap] = $this->getCurrentContext();\n            [$matchedValue, $startPos, $matches] = $this->matchAtPosition($regex);\n            $tokens[] = $this->createToken($tokenMap, $matches, $matchedValue, $startPos, $tokens);\n        }\n\n        $this->validateFinalState();\n        $tokens[] = new Token(TokenType::T_EOF, '', $this->position);\n\n        return new TokenStream($tokens, $pattern);\n    }\n\n    private function getRegexOutside(): string\n    {\n        return self::$regexOutside ??= $this->compilePattern(self::PATTERNS_OUTSIDE);\n    }\n\n    private function getRegexInside(): string\n    {\n        return self::$regexInside ??= $this->compilePattern(self::PATTERNS_INSIDE);\n    }\n\n    \/**\n     * Compile patterns into an optimized regex with named groups.\n     *\n     * @param array<string, string> $patterns\n     *\/\n    private function compilePattern(array $patterns): string\n    {\n        $regexParts = [];\n        foreach ($patterns as $name => $pattern) {\n            $regexParts[] = \"(?<{$name}> {$pattern} )\";\n        }\n\n        return '\/(?:'.implode('|', $regexParts).')\/xsuA';\n    }\n\n    private function resetState(): void\n    {\n        $this->position = 0;\n        $this->inCharClass = false;\n        $this->inQuoteMode = false;\n        $this->inCommentMode = false;\n        $this->charClassStartPosition = 0;\n    }\n\n    \/**\n     * @param array<Token> $tokens\n     *\/\n    private function handleTunnelModes(array &$tokens): bool\n    {\n        if ($this->inQuoteMode) {\n            if ($token = $this->consumeQuoteMode()) {\n                $tokens[] = $token;\n            }\n\n            return true;\n        }\n\n        if ($this->inCommentMode) {\n            if ($token = $this->consumeCommentMode()) {\n                $tokens[] = $token;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    \/**\n     * @return array{0: string, 1: array<string>}\n     *\/\n    private function getCurrentContext(): array\n    {\n        if ($this->inCharClass) {\n            return [$this->getRegexInside(), self::TOKENS_INSIDE];\n        }\n\n        return [$this->getRegexOutside(), self::TOKENS_OUTSIDE];\n    }\n\n    \/**\n     * @return array{0: string, 1: int, 2: array<int|string, string|null>}\n     *\/\n    private function matchAtPosition(string $regex): array\n    {\n        $result = preg_match($regex, $this->pattern, $matches, \\PREG_UNMATCHED_AS_NULL, $this->position);\n\n        if (false === $result) {\n            throw LexerException::withContext(\n                \\sprintf('PCRE Error during tokenization: %s', preg_last_error_msg()),\n                $this->position,\n                $this->pattern,\n            );\n        }\n\n        if (0 === $result) {\n            $context = substr($this->pattern, $this->position, 10);\n\n            throw LexerException::withContext(\n                \\sprintf('Unable to tokenize pattern at position %d. Context: \"%s...\"', $this->position, $context),\n                $this->position,\n                $this->pattern,\n            );\n        }\n\n        $matchedValue = (string) $matches[0];\n        $startPos = $this->position;\n        $this->position += \\strlen($matchedValue);\n\n        return [$matchedValue, $startPos, $matches];\n    }\n\n    \/**\n     * @param array<string>                  $tokenMap\n     * @param array<int|string, string|null> $matches\n     * @param array<Token>                   $currentTokens\n     *\/\n    private function createToken(\n        array $tokenMap,\n        array $matches,\n        string $matchedValue,\n        int $startPos,\n        array $currentTokens\n    ): Token {\n        foreach ($tokenMap as $tokenName) {\n            \/** @var string $tokenName *\/\n            if (!isset($matches[$tokenName])) {\n                continue;\n            }\n\n            $type = TokenType::from(strtolower(substr($tokenName, 2)));\n\n            if ($token = $this->handleStatefulToken($type, $matchedValue, $startPos, $currentTokens)) {\n                return $token;\n            }\n\n            $value = $this->extractTokenValue($type, $matchedValue, $matches);\n\n            return new Token($type, $value, $startPos);\n        }\n\n        throw LexerException::withContext(\n            \\sprintf('Lexer internal error: No known token matched at position %d.', $startPos),\n            $startPos,\n            $this->pattern,\n        );\n    }\n\n    \/**\n     * @param array<Token> $currentTokens\n     *\/\n    private function handleStatefulToken(\n        TokenType $type,\n        string $matchedValue,\n        int $startPos,\n        array $currentTokens\n    ): ?Token {\n        return match ($type) {\n            TokenType::T_CHAR_CLASS_OPEN => $this->openCharClass($startPos),\n            TokenType::T_CHAR_CLASS_CLOSE => $this->closeCharClass($startPos, $currentTokens),\n            TokenType::T_COMMENT_OPEN => $this->openComment($startPos),\n            TokenType::T_QUOTE_MODE_START => $this->openQuoteMode($startPos),\n            default => $this->handleContextualLiteral($type, $matchedValue, $startPos, $currentTokens),\n        };\n    }\n\n    private function openCharClass(int $startPos): Token\n    {\n        $this->inCharClass = true;\n        $this->charClassStartPosition = $startPos;\n\n        return new Token(TokenType::T_CHAR_CLASS_OPEN, '[', $startPos);\n    }\n\n    \/**\n     * @param array<Token> $currentTokens\n     *\/\n    private function closeCharClass(int $startPos, array $currentTokens): Token\n    {\n        if ($this->isAtCharClassStart($startPos, $currentTokens)) {\n            return new Token(TokenType::T_LITERAL, ']', $startPos);\n        }\n\n        $this->inCharClass = false;\n\n        return new Token(TokenType::T_CHAR_CLASS_CLOSE, ']', $startPos);\n    }\n\n    private function openComment(int $startPos): Token\n    {\n        $this->inCommentMode = true;\n\n        return new Token(TokenType::T_COMMENT_OPEN, '(?#', $startPos);\n    }\n\n    private function openQuoteMode(int $startPos): Token\n    {\n        $this->inQuoteMode = true;\n\n        return new Token(TokenType::T_QUOTE_MODE_START, '\\Q', $startPos);\n    }\n\n    \/**\n     * @param array<Token> $currentTokens\n     *\/\n    private function handleContextualLiteral(\n        TokenType $type,\n        string $matchedValue,\n        int $startPos,\n        array $currentTokens\n    ): ?Token {\n        if (!$this->inCharClass || TokenType::T_LITERAL !== $type) {\n            return null;\n        }\n\n        if ($this->isAtCharClassStart($startPos, $currentTokens) && '^' === $matchedValue) {\n            return new Token(TokenType::T_NEGATION, '^', $startPos);\n        }\n\n        if (!$this->isAtCharClassStart($startPos, $currentTokens) && '-' === $matchedValue) {\n            return new Token(TokenType::T_RANGE, '-', $startPos);\n        }\n\n        return null;\n    }\n\n    \/**\n     * @param array<Token> $currentTokens\n     *\/\n    private function isAtCharClassStart(int $startPos, array $currentTokens): bool\n    {\n        $lastToken = end($currentTokens);\n\n        return ($startPos === $this->charClassStartPosition + 1)\n            || ($startPos === $this->charClassStartPosition + 2\n                && $lastToken instanceof Token\n                && TokenType::T_NEGATION === $lastToken->type);\n    }\n\n    private function consumeQuoteMode(): ?Token\n    {\n        if (!preg_match('\/(.*?)((\\\\\\\\E|$))\/suA', $this->pattern, $matches, \\PREG_UNMATCHED_AS_NULL, $this->position)) {\n            $this->inQuoteMode = false;\n            $this->position = $this->length;\n\n            return null;\n        }\n\n        $literalText = $matches[1];\n        $endSequence = $matches[2];\n        $startPos = $this->position;\n\n        if ('' !== $literalText) {\n            $this->position += \\strlen($literalText);\n\n            return new Token(TokenType::T_LITERAL, $literalText, $startPos);\n        }\n\n        if ('\\E' === $endSequence) {\n            $this->inQuoteMode = false;\n            $token = new Token(TokenType::T_QUOTE_MODE_END, '\\E', $this->position);\n            $this->position += 2;\n\n            return $token;\n        }\n\n        $this->position = $this->length;\n\n        return null;\n    }\n\n    private function consumeCommentMode(): ?Token\n    {\n        if (!preg_match('\/([^)]*)(\\)|$)\/uA', $this->pattern, $matches, \\PREG_UNMATCHED_AS_NULL, $this->position)) {\n            $this->inCommentMode = false;\n            $this->position = $this->length;\n\n            return null;\n        }\n\n        $commentText = $matches[1];\n        $endSequence = $matches[2];\n        $startPos = $this->position;\n\n        if ('' !== $commentText) {\n            $this->position += \\strlen($commentText);\n\n            return new Token(TokenType::T_LITERAL, $commentText, $startPos);\n        }\n\n        if (')' === $endSequence) {\n            $this->inCommentMode = false;\n            $token = new Token(TokenType::T_GROUP_CLOSE, ')', $this->position);\n            $this->position++;\n\n            return $token;\n        }\n\n        $this->position = $this->length;\n\n        return null;\n    }\n\n    \/**\n     * @param array<int|string, string|null> $matches\n     *\/\n    private function extractTokenValue(TokenType $type, string $matchedValue, array $matches): string\n    {\n        return match ($type) {\n            TokenType::T_LITERAL_ESCAPED => match (substr($matchedValue, 1)) {\n                't' => \"\\t\", 'n' => \"\\n\", 'r' => \"\\r\", 'f' => \"\\f\", 'v' => \"\\v\",\n                'e' => \"\\x1B\", 'a' => \"\\x07\", default => substr($matchedValue, 1),\n            },\n            TokenType::T_PCRE_VERB => substr($matchedValue, 2, -1),\n            TokenType::T_CALLOUT => substr($matchedValue, 3, -1),\n            TokenType::T_ASSERTION, TokenType::T_CHAR_TYPE, TokenType::T_KEEP => substr($matchedValue, 1),\n            TokenType::T_BACKREF => $matchedValue,\n            TokenType::T_OCTAL_LEGACY => substr($matchedValue, 1),\n            TokenType::T_POSIX_CLASS => $matches['v_posix'] ?? '',\n            TokenType::T_UNICODE => $this->parseUnicodeEscape($matchedValue),\n            TokenType::T_UNICODE_PROP => $this->normalizeUnicodeProp($matchedValue, $matches),\n            TokenType::T_UNICODE_NAMED => substr($matchedValue, 3, -1),\n            TokenType::T_CONTROL_CHAR => substr($matchedValue, 2),\n            TokenType::T_CLASS_INTERSECTION => '&&',\n            TokenType::T_CLASS_SUBTRACTION => '--',\n            default => $matchedValue,\n        };\n    }\n\n    private function parseUnicodeEscape(string $escape): string\n    {\n        if (preg_match('\/^\\\\\\\\x([0-9a-fA-F]{1,2})$\/', $escape, $m)) {\n            $code = (int) hexdec($m[1]);\n            if ($code <= 0xFF) {\n                return \\chr($code);\n            }\n        }\n\n        \/\/ For other cases, keep as string\n        return $escape;\n    }\n\n    \/**\n     * @param array<int|string, string|null> $matches\n     *\/\n    private function normalizeUnicodeProp(string $matchedValue, array $matches): string\n    {\n        $prop = (string) ($matches['v1_prop'] ?? $matches['v2_prop'] ?? '');\n        $isNegated = str_starts_with($matchedValue, '\\\\P');\n\n        if (!$isNegated) {\n            return $prop;\n        }\n\n        return str_starts_with($prop, '^') ? substr($prop, 1) : '^'.$prop;\n    }\n\n    private function validateFinalState(): void\n    {\n        if ($this->inCharClass) {\n            throw LexerException::withContext(\n                'Unclosed character class \"]\" at end of input.',\n                $this->position,\n                $this->pattern,\n            );\n        }\n\n        if ($this->inCommentMode) {\n            throw LexerException::withContext(\n                'Unclosed comment \")\" at end of input.',\n                $this->position,\n                $this->pattern,\n            );\n        }\n    }\n}\n",
    "Node\/ConditionalNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a conditional sub-pattern.\n *\/\nfinal readonly class ConditionalNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $condition,\n        public NodeInterface $yes,\n        public NodeInterface $no,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitConditional($this);\n    }\n}\n",
    "Node\/AnchorNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents an anchor in a regular expression.\n *\/\nfinal readonly class AnchorNode extends AbstractNode\n{\n    public function __construct(\n        public string $value,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitAnchor($this);\n    }\n}\n",
    "Node\/UnicodePropNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a Unicode property match.\n *\/\nfinal readonly class UnicodePropNode extends AbstractNode\n{\n    public function __construct(\n        public string $prop,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitUnicodeProp($this);\n    }\n}\n",
    "Node\/CalloutNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nfinal readonly class CalloutNode extends AbstractNode\n{\n    public function __construct(\n        public int|string $identifier,\n        public bool $isStringIdentifier,\n        int $startPosition,\n        int $endPosition,\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    public function accept(NodeVisitorInterface $visitor): mixed\n    {\n        return $visitor->visitCallout($this);\n    }\n}\n",
    "Node\/PosixClassNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a POSIX character class.\n *\/\nfinal readonly class PosixClassNode extends AbstractNode\n{\n    public function __construct(\n        public string $class,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitPosixClass($this);\n    }\n}\n",
    "Node\/DefineNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a DEFINE block in a regular expression.\n *\/\nfinal readonly class DefineNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $content,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor): mixed\n    {\n        return $visitor->visitDefine($this);\n    }\n}\n",
    "Node\/RangeNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a character range.\n *\/\nfinal readonly class RangeNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $start,\n        public NodeInterface $end,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitRange($this);\n    }\n}\n",
    "Node\/CommentNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents an inline comment in a regular expression.\n *\/\nfinal readonly class CommentNode extends AbstractNode\n{\n    public function __construct(\n        public string $comment,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitComment($this);\n    }\n}\n",
    "Node\/CharTypeNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a predefined character type.\n *\/\nfinal readonly class CharTypeNode extends AbstractNode\n{\n    public function __construct(\n        public string $value,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitCharType($this);\n    }\n}\n",
    "Node\/QuantifierType.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\n\/**\n * Defines the \"greediness\" of a quantifier.\n *\/\nenum QuantifierType: string\n{\n    \/** Greedy (e.g., \"*\", \"+\"). *\/\n    case T_GREEDY = 'greedy';\n\n    \/** Lazy (non-greedy) (e.g., \"*?\", \"+?\"). *\/\n    case T_LAZY = 'lazy';\n\n    \/** Possessive (e.g., \"*+\", \"++\"). *\/\n    case T_POSSESSIVE = 'possessive';\n}\n",
    "Node\/SequenceNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a sequence of atoms.\n *\/\nfinal readonly class SequenceNode extends AbstractNode\n{\n    \/**\n     * @param array<NodeInterface> $children\n     *\/\n    public function __construct(\n        public array $children,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitSequence($this);\n    }\n}\n",
    "Node\/DotNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents the dot wildcard character.\n *\/\nfinal readonly class DotNode extends AbstractNode\n{\n    public function __construct(int $startPosition, int $endPosition)\n    {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitDot($this);\n    }\n}\n",
    "Node\/ScriptRunNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a script run verb (e.g., (*script_run:Latin), (*sr:Latin)).\n *\n * This node represents PCRE2 script run assertions that ensure\n * all characters in the subject string belong to the same script.\n *\/\nfinal readonly class ScriptRunNode extends AbstractNode\n{\n    \/**\n     * Initializes a script run node.\n     *\n     * @param string $script        The script name (e.g., 'Latin').\n     * @param int    $startPosition the start position\n     * @param int    $endPosition   the end position\n     *\/\n    public function __construct(\n        public string $script,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * Implements the visitor pattern for traversing the AST.\n     *\n     * @template T The return type of the visitor's methods.\n     *\n     * @param NodeVisitorInterface<T> $visitor the visitor object that is traversing the tree\n     *\n     * @return T the result of the visitor's processing for this node\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitScriptRun($this);\n    }\n}\n",
    "Node\/GroupNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a grouping construct in a regular expression.\n *\/\nfinal readonly class GroupNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $child,\n        public GroupType $type,\n        public ?string $name = null,\n        public ?string $flags = null,\n        int $startPosition = 0,\n        int $endPosition = 0\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitGroup($this);\n    }\n}\n",
    "Node\/AbstractNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\n\/**\n * Abstract base class for all AST nodes.\n *\/\nabstract readonly class AbstractNode implements NodeInterface\n{\n    public function __construct(public int $startPosition, public int $endPosition) {}\n\n    public function getStartPosition(): int\n    {\n        return $this->startPosition;\n    }\n\n    public function getEndPosition(): int\n    {\n        return $this->endPosition;\n    }\n}\n",
    "Node\/BackrefNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a backreference to a captured group.\n *\/\nfinal readonly class BackrefNode extends AbstractNode\n{\n    public function __construct(\n        public string $ref,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitBackref($this);\n    }\n}\n",
    "Node\/ClassOperationNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a character class operation (intersection && or subtraction --).\n *\n * This node handles extended character class operations in PCRE2,\n * allowing complex class combinations like [a&&b] or [a--b].\n *\/\nfinal readonly class ClassOperationNode extends AbstractNode\n{\n    \/**\n     * Initializes a class operation node.\n     *\n     * @param ClassOperationType $type          the operation type (intersection or subtraction)\n     * @param NodeInterface      $left          the left operand\n     * @param NodeInterface      $right         the right operand\n     * @param int                $startPosition the start position\n     * @param int                $endPosition   the end position\n     *\/\n    public function __construct(\n        public ClassOperationType $type,\n        public NodeInterface $left,\n        public NodeInterface $right,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * Implements the visitor pattern for traversing the AST.\n     *\n     * @template T The return type of the visitor's methods.\n     *\n     * @param NodeVisitorInterface<T> $visitor the visitor object that is traversing the tree\n     *\n     * @return T the result of the visitor's processing for this node\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitClassOperation($this);\n    }\n}\n",
    "Node\/CharClassNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a character class in a regular expression.\n *\/\nfinal readonly class CharClassNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $expression,\n        public bool $isNegated,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitCharClass($this);\n    }\n}\n",
    "Node\/SubroutineNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a subroutine call.\n *\/\nfinal readonly class SubroutineNode extends AbstractNode\n{\n    public function __construct(\n        public string $reference,\n        public string $syntax,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitSubroutine($this);\n    }\n}\n",
    "Node\/AlternationNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents an alternation in a regular expression.\n *\/\nfinal readonly class AlternationNode extends AbstractNode\n{\n    \/**\n     * @param array<NodeInterface> $alternatives\n     *\/\n    public function __construct(\n        public array $alternatives,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitAlternation($this);\n    }\n}\n",
    "Node\/LiteralNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a literal character or sequence in a regex.\n *\/\nfinal readonly class LiteralNode extends AbstractNode\n{\n    public function __construct(\n        public string $value,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitLiteral($this);\n    }\n}\n",
    "Node\/PcreVerbNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a PCRE verb.\n *\/\nfinal readonly class PcreVerbNode extends AbstractNode\n{\n    public function __construct(\n        public string $verb,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitPcreVerb($this);\n    }\n}\n",
    "Node\/CharLiteralNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a single character literal expressed via escape syntax (unicode or octal).\n *\/\nfinal readonly class CharLiteralNode extends AbstractNode\n{\n    public function __construct(\n        public string $originalRepresentation,\n        public int $codePoint,\n        public CharLiteralType $type,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitCharLiteral($this);\n    }\n}\n",
    "Node\/QuantifierNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a quantifier.\n *\/\nfinal readonly class QuantifierNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $node,\n        public string $quantifier,\n        public QuantifierType $type,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitQuantifier($this);\n    }\n}\n",
    "Node\/RegexNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Root node of the regex AST.\n *\/\nfinal readonly class RegexNode extends AbstractNode\n{\n    public function __construct(\n        public NodeInterface $pattern,\n        public string $flags,\n        public string $delimiter,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * Implements the visitor pattern for traversing the AST.\n     *\n     * This method is the entry point for any `NodeVisitorInterface` that needs to\n     * process this `RegexNode`. It allows for operations like compilation, validation,\n     * or explanation to be performed without adding logic to the node itself. The method\n     * simply dispatches the call to the appropriate `visitRegex` method on the visitor.\n     *\n     * @template T The return type of the visitor's methods.\n     *\n     * @param NodeVisitorInterface<T> $visitor the visitor object that is traversing the tree\n     *\n     * @return T the result of the visitor's processing for this node\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitRegex($this);\n    }\n}\n",
    "Node\/AssertionNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a zero-width assertion.\n *\/\nfinal readonly class AssertionNode extends AbstractNode\n{\n    public function __construct(\n        public string $value,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitAssertion($this);\n    }\n}\n",
    "Node\/KeepNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents the \\K keep assertion.\n *\/\nfinal readonly class KeepNode extends AbstractNode\n{\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitKeep($this);\n    }\n}\n",
    "Node\/NodeInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Base interface for all AST nodes.\n *\/\ninterface NodeInterface\n{\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor);\n\n    public function getStartPosition(): int;\n\n    public function getEndPosition(): int;\n}\n",
    "Node\/ControlCharNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a control character escape sequence (e.g., \\cM).\n *\n * This node represents control character escapes in PCRE2,\n * where \\c followed by a letter produces the corresponding control character.\n *\/\nfinal readonly class ControlCharNode extends AbstractNode\n{\n    \/**\n     * Initializes a control character node.\n     *\n     * @param string $char          The control character identifier (e.g., 'M' for \\cM).\n     * @param int    $startPosition the start position\n     * @param int    $endPosition   the end position\n     *\/\n    public function __construct(\n        public string $char,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * Implements the visitor pattern for traversing the AST.\n     *\n     * @template T The return type of the visitor's methods.\n     *\n     * @param NodeVisitorInterface<T> $visitor the visitor object that is traversing the tree\n     *\n     * @return T the result of the visitor's processing for this node\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitControlChar($this);\n    }\n}\n",
    "Node\/CharLiteralType.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\n\/**\n * Categorizes the different character literal escape syntaxes.\n *\/\nenum CharLiteralType: string\n{\n    case UNICODE = 'unicode';\n    case UNICODE_NAMED = 'unicode_named';\n    case OCTAL = 'octal';\n    case OCTAL_LEGACY = 'octal_legacy';\n\n    public function label(): string\n    {\n        return match ($this) {\n            self::UNICODE => 'Unicode',\n            self::UNICODE_NAMED => 'Unicode named',\n            self::OCTAL => 'Octal',\n            self::OCTAL_LEGACY => 'Legacy Octal',\n        };\n    }\n}\n",
    "Node\/UnicodeNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nreadonly class UnicodeNode extends AbstractNode\n{\n    \/**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     *\/\n    public function __construct(\n        public readonly string $code,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitUnicode($this);\n    }\n}\n",
    "Node\/LimitMatchNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a (*LIMIT_MATCH=d) verb.\n *\n * This verb imposes a limit on the number of internal matches that can occur.\n * It's a safeguard against catastrophic backtracking on certain patterns.\n *\/\nfinal readonly class LimitMatchNode extends AbstractNode\n{\n    public function __construct(\n        public int $limit,\n        int $startPosition,\n        int $endPosition,\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitLimitMatch($this);\n    }\n}\n",
    "Node\/VersionConditionNode.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n\/**\n * Represents a version condition in conditional groups (e.g., (?(VERSION>=10.0)...)).\n *\n * This node represents PCRE2 version conditions that allow\n * conditional matching based on the PCRE library version.\n *\/\nfinal readonly class VersionConditionNode extends AbstractNode\n{\n    \/**\n     * Initializes a version condition node.\n     *\n     * @param string $operator      The comparison operator (e.g., '>=').\n     * @param string $version       The version string (e.g., '10.0').\n     * @param int    $startPosition the start position\n     * @param int    $endPosition   the end position\n     *\/\n    public function __construct(\n        public string $operator,\n        public string $version,\n        int $startPosition,\n        int $endPosition\n    ) {\n        parent::__construct($startPosition, $endPosition);\n    }\n\n    \/**\n     * Implements the visitor pattern for traversing the AST.\n     *\n     * @template T The return type of the visitor's methods.\n     *\n     * @param NodeVisitorInterface<T> $visitor the visitor object that is traversing the tree\n     *\n     * @return T the result of the visitor's processing for this node\n     *\/\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitVersionCondition($this);\n    }\n}\n",
    "Node\/GroupType.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\n\/**\n * Defines the semantic type of a group.\n *\/\nenum GroupType: string\n{\n    \/** A capturing group (...). *\/\n    case T_GROUP_CAPTURING = 'capturing';\n\n    \/** A non-capturing group (?:...). *\/\n    case T_GROUP_NON_CAPTURING = 'non_capturing';\n\n    \/** A named capturing group (?<name>...) or (?P<name>...). *\/\n    case T_GROUP_NAMED = 'named';\n\n    \/** A positive lookahead (?=...). *\/\n    case T_GROUP_LOOKAHEAD_POSITIVE = 'lookahead_positive';\n\n    \/** A negative lookahead (?!...). *\/\n    case T_GROUP_LOOKAHEAD_NEGATIVE = 'lookahead_negative';\n\n    \/** A positive lookbehind (?<=...). *\/\n    case T_GROUP_LOOKBEHIND_POSITIVE = 'lookbehind_positive';\n\n    \/** A negative lookbehind (?<!...). *\/\n    case T_GROUP_LOOKBEHIND_NEGATIVE = 'lookbehind_negative';\n\n    \/** Inline flags (?i:...). *\/\n    case T_GROUP_INLINE_FLAGS = 'inline_flags';\n\n    \/** An atomic group (?>...). *\/\n    case T_GROUP_ATOMIC = 'atomic';\n\n    \/** A branch reset group (?|...). *\/\n    case T_GROUP_BRANCH_RESET = 'branch_reset';\n}\n",
    "Node\/ClassOperationType.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Node;\n\n\/**\n * Defines the type of character class operation.\n *\/\nenum ClassOperationType: string\n{\n    \/** Intersection operation (&&). *\/\n    case INTERSECTION = 'intersection';\n\n    \/** Subtraction operation (--). *\/\n    case SUBTRACTION = 'subtraction';\n}\n",
    "GroupNumbering.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Represents PCRE-aware group numbering metadata for a regex pattern.\n *\/\nfinal readonly class GroupNumbering\n{\n    \/**\n     * @param list<int>                $captureSequence\n     * @param array<string, list<int>> $namedGroups\n     *\/\n    public function __construct(\n        public int $maxGroupNumber,\n        public array $captureSequence,\n        public array $namedGroups,\n    ) {}\n\n    public function hasNamedGroup(string $name): bool\n    {\n        return isset($this->namedGroups[$name]);\n    }\n\n    \/**\n     * @return list<int>\n     *\/\n    public function getNamedGroupNumbers(string $name): array\n    {\n        return $this->namedGroups[$name] ?? [];\n    }\n\n    public function getCaptureCount(): int\n    {\n        return \\count($this->captureSequence);\n    }\n}\n",
    "Exception\/ParserException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Represents an error that occurred during the parsing phase.\n *\n * @see \\RegexParser\\Parser\n *\n * @phpstan-consistent-constructor\n *\/\nclass ParserException extends \\Exception implements RegexParserExceptionInterface\n{\n    use VisualContextTrait;\n\n    public function __construct(string $message, ?int $position = null, ?string $pattern = null, ?\\Throwable $previous = null)\n    {\n        $this->initializeContext($position, $pattern);\n\n        parent::__construct($message, 0, $previous);\n    }\n\n    public static function withContext(string $message, int $position, string $pattern, ?\\Throwable $previous = null): static\n    {\n        return new static($message, $position, $pattern, $previous);\n    }\n}\n",
    "Exception\/SemanticErrorException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Represents a semantic validation error in a regex pattern.\n *\/\nfinal class SemanticErrorException extends ParserException implements RegexParserExceptionInterface\n{\n    public function __construct(\n        string $message,\n        ?int $position = null,\n        ?string $pattern = null,\n        ?\\Throwable $previous = null,\n        private readonly string $errorCode = 'regex.semantic',\n        private readonly ?string $hint = null,\n    ) {\n        parent::__construct($message, $position, $pattern, $previous);\n    }\n\n    public function getErrorCode(): string\n    {\n        return $this->errorCode;\n    }\n\n    public function getHint(): ?string\n    {\n        return $this->hint;\n    }\n}\n",
    "Exception\/VisualContextTrait.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Provides common visual context helpers for parser-related exceptions.\n *\/\ntrait VisualContextTrait\n{\n    private const MAX_CONTEXT_WIDTH = 80;\n\n    private ?int $position = null;\n\n    private ?string $pattern = null;\n\n    private string $visualSnippet = '';\n\n    public function getPosition(): ?int\n    {\n        return $this->position;\n    }\n\n    public function getPattern(): ?string\n    {\n        return $this->pattern;\n    }\n\n    public function getVisualSnippet(): string\n    {\n        return $this->visualSnippet;\n    }\n\n    private function initializeContext(?int $position, ?string $pattern): void\n    {\n        $this->position = $position;\n        $this->pattern = $pattern;\n        $this->visualSnippet = $this->buildVisualSnippet($position, $pattern);\n    }\n\n    private function buildVisualSnippet(?int $position, ?string $pattern): string\n    {\n        if (null === $pattern || null === $position || $position < 0) {\n            return '';\n        }\n\n        $length = \\strlen($pattern);\n        $caretIndex = $position > $length ? $length : $position;\n\n        $lineStart = strrpos($pattern, \"\\n\", $caretIndex - $length);\n        $lineStart = false === $lineStart ? 0 : $lineStart + 1;\n        $lineEnd = strpos($pattern, \"\\n\", $caretIndex);\n        $lineEnd = false === $lineEnd ? $length : $lineEnd;\n\n        $lineNumber = substr_count($pattern, \"\\n\", 0, $lineStart) + 1;\n\n        $displayStart = $lineStart;\n        $displayEnd = $lineEnd;\n\n        if (($displayEnd - $displayStart) > self::MAX_CONTEXT_WIDTH) {\n            $half = intdiv(self::MAX_CONTEXT_WIDTH, 2);\n            $displayStart = max($lineStart, $caretIndex - $half);\n            $displayEnd = min($lineEnd, $displayStart + self::MAX_CONTEXT_WIDTH);\n\n            if (($displayEnd - $displayStart) > self::MAX_CONTEXT_WIDTH) {\n                $displayStart = $displayEnd - self::MAX_CONTEXT_WIDTH;\n            }\n        }\n\n        $prefixEllipsis = $displayStart > $lineStart ? '...' : '';\n        $suffixEllipsis = $displayEnd < $lineEnd ? '...' : '';\n\n        $excerpt = $prefixEllipsis\n            .substr($pattern, $displayStart, $displayEnd - $displayStart)\n            .$suffixEllipsis;\n\n        $caretOffset = ('' === $prefixEllipsis ? 0 : 3) + ($caretIndex - $displayStart);\n        if ($caretOffset < 0) {\n            $caretOffset = 0;\n        }\n\n        $lineLabel = 'Line '.$lineNumber.': ';\n\n        return $lineLabel.$excerpt.\"\\n\"\n            .str_repeat(' ', \\strlen($lineLabel) + $caretOffset).'^';\n    }\n}\n",
    "Exception\/LexerException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Represents an error that occurred during the lexical analysis phase.\n *\n * @see \\RegexParser\\Lexer\n *\/\nfinal class LexerException extends \\Exception implements RegexParserExceptionInterface\n{\n    use VisualContextTrait;\n\n    public function __construct(string $message, ?int $position = null, ?string $pattern = null, ?\\Throwable $previous = null)\n    {\n        $this->initializeContext($position, $pattern);\n\n        parent::__construct($message, 0, $previous);\n    }\n\n    public static function withContext(string $message, int $position, string $pattern, ?\\Throwable $previous = null): self\n    {\n        return new self($message, $position, $pattern, $previous);\n    }\n}\n",
    "Exception\/InvalidRegexOptionException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Thrown when invalid options are passed to `Regex::create()`.\n *\/\nfinal class InvalidRegexOptionException extends \\InvalidArgumentException implements RegexParserExceptionInterface {}\n",
    "Exception\/SyntaxErrorException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Represents a specific type of parsing error related to invalid syntax.\n *\n * @see \\RegexParser\\Parser\n *\/\nfinal class SyntaxErrorException extends ParserException implements RegexParserExceptionInterface {}\n",
    "Exception\/RecursionLimitException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Indicates that parsing was halted due to excessive recursion depth.\n *\n * @see \\RegexParser\\Parser\n *\/\nfinal class RecursionLimitException extends ParserException implements RegexParserExceptionInterface {}\n",
    "Exception\/PcreRuntimeException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Represents a PCRE compilation\/runtime error detected during validation.\n *\/\nfinal class PcreRuntimeException extends ParserException implements RegexParserExceptionInterface\n{\n    public function __construct(\n        string $message,\n        ?int $position = null,\n        ?string $pattern = null,\n        ?\\Throwable $previous = null,\n        private readonly ?string $errorCode = null,\n    ) {\n        parent::__construct($message, $position, $pattern, $previous);\n    }\n\n    public function getErrorCode(): ?string\n    {\n        return $this->errorCode;\n    }\n}\n",
    "Exception\/RegexParserExceptionInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Defines a common contract for all exceptions thrown by the regex-parser library.\n *\/\ninterface RegexParserExceptionInterface extends \\Throwable {}\n",
    "Exception\/ResourceLimitException.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser\\Exception;\n\n\/**\n * Indicates that parsing was halted because a resource limit was exceeded.\n *\n * @see \\RegexParser\\Parser\n *\/\nfinal class ResourceLimitException extends ParserException implements RegexParserExceptionInterface {}\n",
    "LiteralExtractionResult.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * Structured literal extraction output for fast prefilters.\n *\/\nfinal readonly class LiteralExtractionResult\n{\n    \/**\n     * @param list<string> $literals\n     * @param list<string> $patterns\n     *\/\n    public function __construct(\n        public array $literals,\n        public array $patterns,\n        public string $confidence,\n        public LiteralSet $literalSet,\n    ) {}\n}\n",
    "TokenStream.php": "<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace RegexParser;\n\n\/**\n * High-performance token stream with direct indexing and intelligent caching.\n *\n * This implementation eliminates O(n) array operations and provides constant-time\n * access to tokens through direct array indexing with minimal memory overhead.\n *\/\nfinal class TokenStream\n{\n    private int $position = 0;\n\n    private int $maxPosition = 0;\n\n    \/**\n     * @param array<Token> $tokens\n     *\/\n    public function __construct(\n        private readonly array $tokens,\n        private readonly string $pattern\n    ) {\n        $this->maxPosition = \\count($this->tokens) - 1;\n    }\n\n    \/**\n     * @throws \\RuntimeException\n     *\/\n    public function current(): Token\n    {\n        if ($this->position > $this->maxPosition) {\n            throw new \\RuntimeException('Token stream is exhausted');\n        }\n\n        return $this->tokens[$this->position];\n    }\n\n    \/**\n     * @throws \\RuntimeException\n     *\/\n    public function next(): void\n    {\n        if ($this->position > $this->maxPosition) {\n            throw new \\RuntimeException('Token stream is exhausted');\n        }\n\n        $this->position++;\n    }\n\n    \/**\n     * @throws \\RuntimeException\n     *\/\n    public function rewind(int $count = 1): void\n    {\n        if ($count < 1) {\n            return;\n        }\n\n        $newPosition = $this->position - $count;\n        if ($newPosition < 0) {\n            throw new \\RuntimeException(\\sprintf(\n                'Cannot rewind %d tokens, would go before start of stream',\n                $count,\n            ));\n        }\n\n        $this->position = $newPosition;\n    }\n\n    public function setPosition(int $position): void\n    {\n        if ($position < 0 || $position > $this->maxPosition + 1) {\n            throw new \\RuntimeException(\\sprintf(\n                'Position %d is out of bounds [0, %d]',\n                $position,\n                $this->maxPosition + 1,\n            ));\n        }\n\n        $this->position = $position;\n    }\n\n    public function peek(int $offset = 1): Token\n    {\n        $targetPos = $this->position + $offset;\n\n        if ($targetPos < 0) {\n            return new Token(TokenType::T_EOF, '', 0);\n        }\n\n        if ($targetPos > $this->maxPosition) {\n            return new Token(TokenType::T_EOF, '', $targetPos);\n        }\n\n        return $this->tokens[$targetPos];\n    }\n\n    public function hasMore(): bool\n    {\n        return $this->position <= $this->maxPosition;\n    }\n\n    public function getPosition(): int\n    {\n        return $this->position;\n    }\n\n    public function getPattern(): string\n    {\n        return $this->pattern;\n    }\n\n    \/**\n     * @return array<Token>\n     *\/\n    public function getTokens(): array\n    {\n        return $this->tokens;\n    }\n\n    \/**\n     * Returns true if current token is EOF\n     *\/\n    public function isAtEnd(): bool\n    {\n        return $this->position > $this->maxPosition\n               || TokenType::T_EOF === $this->tokens[$this->position]->type;\n    }\n}\n",
    "autoload.php": "<?php\n\ndeclare(strict_types=1);\n\nspl_autoload_register(function (string $class): void {\n    $prefix = 'RegexParser\\\\';\n    $baseDir = __DIR__.'\/src\/';\n\n    $len = strlen($prefix);\n    if (strncmp($prefix, $class, $len) !== 0) {\n        return;\n    }\n\n    $relativeClass = substr($class, $len);\n    $file = $baseDir.str_replace('\\\\', '\/', $relativeClass).'.php';\n\n    if (file_exists($file)) {\n        require $file;\n    }\n});\n\n\/\/ Alias the main Regex class to global namespace for compatibility\nif (!class_exists('Regex')) {\n    class_alias('RegexParser\\\\Regex', 'Regex');\n}"
}