{
    "RegexCompiler.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nuse Psr\\SimpleCache\\CacheInterface;\nuse Psr\\SimpleCache\\InvalidArgumentException;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Stream\\TokenStream;\n\n/**\n * RegexCompiler - The high-level facade for parsing regex strings.\n *\n * This class combines the Lexer and Parser to provide a convenient API for\n * end-users who want to parse a raw regex string into an AST.\n *\n * Architecture:\n * - String validation (length, delimiters, flags) happens HERE\n * - Lexer tokenizes the pattern into a TokenStream\n * - Parser operates purely on the TokenStream to produce the AST\n *\n * This separation ensures:\n * - Parser has no knowledge of raw strings or lexer internals\n * - Easy testing of Parser with mock TokenStreams\n * - Better modularity and maintainability\n *\n * @example Basic usage:\n * ```php\n * $compiler = new RegexCompiler();\n * $ast = $compiler->parse('/[a-z]+/i');\n * ```\n * @example With custom options:\n * ```php\n * $compiler = new RegexCompiler([\n *     'max_pattern_length' => 50000,\n *     'max_recursion_depth' => 100,\n *     'cache' => $psr16Cache,\n * ]);\n * $ast = $compiler->parse('/complex-pattern/');\n * ```\n * @example Parsing from existing TokenStream (advanced):\n * ```php\n * $lexer = new Lexer($pattern);\n * $stream = new TokenStream($lexer->tokenize());\n * $ast = $parser->parseTokenStream($stream, $flags, $delimiter, strlen($pattern));\n * ```\n */\nfinal class RegexCompiler\n{\n    /**\n     * Default hard limit on the regex string length.\n     */\n    public const int DEFAULT_MAX_PATTERN_LENGTH = 100_000;\n\n    private readonly int $maxPatternLength;\n\n    /**\n     * Runtime cache for parsed ASTs (Layer 1).\n     *\n     * @var array<string, RegexNode>\n     */\n    private array $runtimeCache = [];\n\n    private ?CacheInterface $cache = null;\n\n    private ?Lexer $lexer = null;\n\n    private readonly Parser $parser;\n\n    /**\n     * @param array{\n     *     max_pattern_length?: int,\n     *     max_recursion_depth?: int,\n     *     max_nodes?: int,\n     *     cache?: CacheInterface|null,\n     * } $options Configuration options\n     */\n    public function __construct(array $options = [])\n    {\n        $this->maxPatternLength = (int) ($options['max_pattern_length'] ?? self::DEFAULT_MAX_PATTERN_LENGTH);\n        $this->cache = $options['cache'] ?? null;\n\n        // Create Parser with its own options (recursion/node limits)\n        $this->parser = new Parser($options);\n    }\n\n    /**\n     * Parses a full regex string (including delimiters and flags) into an AST.\n     *\n     * Implements a two-layer caching strategy:\n     * 1. Runtime Cache (Layer 1): Fast in-memory cache for repeated calls\n     * 2. PSR-16 Persistent Cache (Layer 2): Optional external cache\n     *\n     * @throws ParserException if the regex syntax is invalid\n     */\n    public function parse(string $regex): RegexNode\n    {\n        if (\\strlen($regex) > $this->maxPatternLength) {\n            throw new ParserException(\\sprintf('Regex pattern exceeds maximum length of %d characters.', $this->maxPatternLength));\n        }\n\n        // Generate cache key\n        $cacheKey = 'regex_parser_'.md5($regex);\n\n        // Layer 1: Check runtime cache\n        if (isset($this->runtimeCache[$cacheKey])) {\n            return $this->runtimeCache[$cacheKey];\n        }\n\n        // Layer 2: Check persistent cache (if available)\n        if (null !== $this->cache) {\n            try {\n                $cached = $this->cache->get($cacheKey);\n                if ($cached instanceof RegexNode) {\n                    $this->runtimeCache[$cacheKey] = $cached;\n\n                    return $cached;\n                }\n            } catch (InvalidArgumentException) {\n                // Cache key is invalid - proceed with parsing\n            }\n        }\n\n        // Cache miss - proceed with actual parsing\n        [$pattern, $flags, $delimiter] = $this->extractPatternAndFlags($regex);\n\n        // Tokenize the pattern\n        $lexer = $this->getLexer($pattern);\n        $stream = new TokenStream($lexer->tokenize());\n\n        // Parse the token stream\n        $ast = $this->parser->parseTokenStream($stream, $flags, $delimiter, \\strlen($pattern));\n\n        // Save to runtime cache (Layer 1)\n        $this->runtimeCache[$cacheKey] = $ast;\n\n        // Save to persistent cache (Layer 2) if available\n        if (null !== $this->cache) {\n            try {\n                $this->cache->set($cacheKey, $ast);\n            } catch (InvalidArgumentException) {\n                // Cache write failed - continue without caching\n            }\n        }\n\n        return $ast;\n    }\n\n    /**\n     * Gets a cached AST if available, null otherwise.\n     * Useful for checking cache state without triggering a parse.\n     */\n    public function getCached(string $regex): ?RegexNode\n    {\n        $cacheKey = 'regex_parser_'.md5($regex);\n\n        if (isset($this->runtimeCache[$cacheKey])) {\n            return $this->runtimeCache[$cacheKey];\n        }\n\n        if (null !== $this->cache) {\n            try {\n                $cached = $this->cache->get($cacheKey);\n                if ($cached instanceof RegexNode) {\n                    return $cached;\n                }\n            } catch (InvalidArgumentException) {\n                // Ignore cache errors\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Clears the runtime cache.\n     */\n    public function clearRuntimeCache(): void\n    {\n        $this->runtimeCache = [];\n    }\n\n    /**\n     * Returns the underlying Parser instance.\n     * Useful for advanced scenarios where direct TokenStream parsing is needed.\n     */\n    public function getParser(): Parser\n    {\n        return $this->parser;\n    }\n\n    private function getLexer(string $pattern): Lexer\n    {\n        if (null === $this->lexer) {\n            $this->lexer = new Lexer($pattern);\n        } else {\n            $this->lexer->reset($pattern);\n        }\n\n        return $this->lexer;\n    }\n\n    /**\n     * Extracts pattern, flags, and delimiter from a regex string.\n     *\n     * @return array{0: string, 1: string, 2: string} [pattern, flags, delimiter]\n     */\n    private function extractPatternAndFlags(string $regex): array\n    {\n        $len = \\strlen($regex);\n        if ($len < 2) {\n            throw new ParserException('Regex is too short. It must include delimiters.');\n        }\n\n        $delimiter = $regex[0];\n        $closingDelimiter = match ($delimiter) {\n            '(' => ')',\n            '[' => ']',\n            '{' => '}',\n            '<' => '>',\n            default => $delimiter,\n        };\n\n        // Find the last occurrence of the closing delimiter that is NOT escaped\n        for ($i = $len - 1; $i > 0; $i--) {\n            if ($regex[$i] === $closingDelimiter) {\n                $escapes = 0;\n                for ($j = $i - 1; $j > 0 && '\\\\' === $regex[$j]; $j--) {\n                    $escapes++;\n                }\n\n                if (0 === $escapes % 2) {\n                    $pattern = substr($regex, 1, $i - 1);\n                    $flags = substr($regex, $i + 1);\n\n                    if (!preg_match('/^[imsxADSUXJu]*$/', $flags)) {\n                        $invalid = preg_replace('/[imsxADSUXJu]/', '', $flags);\n\n                        throw new ParserException(\\sprintf('Unknown regex flag(s) found: \"%s\"', $invalid ?? $flags));\n                    }\n\n                    return [$pattern, $flags, $delimiter];\n                }\n            }\n        }\n\n        throw new ParserException(\\sprintf('No closing delimiter \"%s\" found.', $closingDelimiter));\n    }\n}\n",
    "TokenType.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nenum TokenType: string\n{\n    /** A single literal character (e.g., \"a\", \"1\"). */\n    case T_LITERAL = 'literal';\n\n    /** A special character class type (e.g., \\d, \\s, \\w). */\n    case T_CHAR_TYPE = 'char_type';\n\n    /** A group opening parenthesis \"(\". */\n    case T_GROUP_OPEN = 'group_open';\n\n    /** A group closing parenthesis \")\". */\n    case T_GROUP_CLOSE = 'group_close';\n\n    /** A special group opening sequence (e.g., \"(?\"). */\n    case T_GROUP_MODIFIER_OPEN = 'group_modifier_open';\n\n    /** A character class opening bracket \"[\". */\n    case T_CHAR_CLASS_OPEN = 'char_class_open';\n\n    /** A character class closing bracket \"]\". */\n    case T_CHAR_CLASS_CLOSE = 'char_class_close';\n\n    /** A quantifier (e.g., \"*\", \"+\", \"?\", \"{n,m}\", \"*?\", \"++\", \"{n,m}+\"). */\n    case T_QUANTIFIER = 'quantifier';\n\n    /** The alternation pipe \"|\". */\n    case T_ALTERNATION = 'alternation';\n\n    /** The wildcard dot \".\". */\n    case T_DOT = 'dot';\n\n    /** An anchor (e.g., \"^\", \"$\"). */\n    case T_ANCHOR = 'anchor';\n\n    /** The end-of-file marker. */\n    case T_EOF = 'eof';\n\n    /** A range operator \"-\" inside a character class. */\n    case T_RANGE = 'range';\n\n    /** A negation operator \"^\" at the start of a character class. */\n    case T_NEGATION = 'negation';\n\n    /** A backreference (e.g., \"\\1\", \"\\k<name>\"). */\n    case T_BACKREF = 'backref';\n\n    /** A Unicode escape (e.g., \"\\xHH\", \"\\u{HHHH}\"). */\n    case T_UNICODE = 'unicode';\n\n    /** A POSIX class inside a character class (e.g., \"[:alpha:]\"). */\n    case T_POSIX_CLASS = 'posix_class';\n\n    /** An assertion (e.g., \\b, \\B, \\A, \\z, \\Z, \\G). */\n    case T_ASSERTION = 'assertion';\n\n    /** A Unicode property (e.g., \\p{L}, \\P{^L}). */\n    case T_UNICODE_PROP = 'unicode_prop';\n\n    /** An octal escape (e.g., \\o{777}). */\n    case T_OCTAL = 'octal';\n\n    /** A legacy octal escape (e.g., \\012). */\n    case T_OCTAL_LEGACY = 'octal_legacy';\n\n    /** A comment opening in group (?#). */\n    case T_COMMENT_OPEN = 'comment_open';\n\n    /** A PCRE verb (e.g., \"(*FAIL)\", \"(*COMMIT)\"). */\n    case T_PCRE_VERB = 'pcre_verb';\n\n    /** A \\g reference (e.g., \"\\g{1}\", \"\\g<name>\", \"\\g-1\"). */\n    case T_G_REFERENCE = 'g_reference';\n\n    /** The \\K \"keep\" assertion. */\n    case T_KEEP = 'keep';\n\n    /** A literal generated from an escaped sequence (e.g., \"\\*\"). */\n    case T_LITERAL_ESCAPED = 'literal_escaped';\n\n    /** The \\Q sequence start. */\n    case T_QUOTE_MODE_START = 'quote_mode_start';\n\n    /** The \\E sequence end. */\n    case T_QUOTE_MODE_END = 'quote_mode_end';\n}\n",
    "Regex.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nuse Psr\\SimpleCache\\CacheInterface;\nuse RegexParser\\Builder\\RegexBuilder;\nuse RegexParser\\Exception\\LexerException;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\NodeVisitor\\CompilerNodeVisitor;\nuse RegexParser\\NodeVisitor\\ComplexityScoreVisitor;\nuse RegexParser\\NodeVisitor\\DumperNodeVisitor;\nuse RegexParser\\NodeVisitor\\ExplainVisitor;\nuse RegexParser\\NodeVisitor\\LiteralExtractorVisitor;\nuse RegexParser\\NodeVisitor\\MermaidVisitor;\nuse RegexParser\\NodeVisitor\\OptimizerNodeVisitor;\nuse RegexParser\\NodeVisitor\\SampleGeneratorVisitor;\nuse RegexParser\\NodeVisitor\\ValidatorNodeVisitor;\n\n/**\n * Main service for parsing, validating, and manipulating regex patterns.\n *\n * This class provides a high-level API for common regex operations.\n * It uses RegexCompiler internally, which combines Lexer + Parser\n * for convenient string-based parsing with caching support.\n */\nclass Regex\n{\n    /**\n     * @param RegexCompiler          $compiler  the configured compiler instance (combines Lexer + Parser)\n     * @param ValidatorNodeVisitor   $validator a reusable validator visitor\n     * @param ExplainVisitor         $explainer a reusable explain visitor\n     * @param SampleGeneratorVisitor $generator a reusable sample generator visitor\n     * @param OptimizerNodeVisitor   $optimizer a reusable optimizer visitor\n     * @param DumperNodeVisitor      $dumper    a reusable dumper visitor\n     * @param ComplexityScoreVisitor $scorer    a reusable complexity scorer\n     */\n    public function __construct(\n        private readonly RegexCompiler $compiler,\n        private readonly ValidatorNodeVisitor $validator,\n        private readonly ExplainVisitor $explainer,\n        private readonly SampleGeneratorVisitor $generator,\n        private readonly OptimizerNodeVisitor $optimizer,\n        private readonly DumperNodeVisitor $dumper,\n        private readonly ComplexityScoreVisitor $scorer,\n    ) {}\n\n    /**\n     * Static constructor for easy use without a DI container.\n     *\n     * @param array{\n     *     max_pattern_length?: int,\n     *     max_recursion_depth?: int,\n     *     max_nodes?: int,\n     *     cache?: CacheInterface|null,\n     * } $options Options for the compiler (e.g., 'max_pattern_length', 'max_recursion_depth', 'max_nodes').\n     */\n    public static function create(array $options = []): self\n    {\n        return new self(\n            new RegexCompiler($options),\n            new ValidatorNodeVisitor(),\n            new ExplainVisitor(),\n            new SampleGeneratorVisitor(),\n            new OptimizerNodeVisitor(),\n            new DumperNodeVisitor(),\n            new ComplexityScoreVisitor(),\n        );\n    }\n\n    /**\n     * Parses a full PCRE regex string into an Abstract Syntax Tree.\n     *\n     * @throws LexerException|ParserException\n     */\n    public function parse(string $regex): RegexNode\n    {\n        return $this->compiler->parse($regex);\n    }\n\n    /**\n     * Validates the syntax and semantics (e.g., ReDoS, valid backrefs) of a regex.\n     */\n    public function validate(string $regex): ValidationResult\n    {\n        try {\n            $ast = $this->compiler->parse($regex);\n            $validator = clone $this->validator;\n            $ast->accept($validator);\n\n            $scorer = clone $this->scorer;\n            $score = $ast->accept($scorer);\n\n            return new ValidationResult(true, null, $score);\n        } catch (LexerException|ParserException $e) {\n            return new ValidationResult(false, $e->getMessage());\n        }\n    }\n\n    /**\n     * Explains the regex in a human-readable format.\n     *\n     * @throws LexerException|ParserException\n     */\n    public function explain(string $regex): string\n    {\n        $ast = $this->compiler->parse($regex);\n\n        return $ast->accept(clone $this->explainer);\n    }\n\n    /**\n     * Generates a random sample string that matches the regex.\n     *\n     * @throws LexerException|ParserException\n     */\n    public function generate(string $regex): string\n    {\n        $ast = $this->compiler->parse($regex);\n\n        return $ast->accept(clone $this->generator);\n    }\n\n    /**\n     * Optimizes the regex AST and returns the simplified regex string.\n     *\n     * @throws LexerException|ParserException\n     */\n    public function optimize(string $regex): string\n    {\n        $ast = $this->compiler->parse($regex);\n\n        $optimizedAst = $ast->accept(clone $this->optimizer);\n\n        $compiler = new CompilerNodeVisitor();\n\n        return $optimizedAst->accept($compiler);\n    }\n\n    /**\n     * Visualizes the regex AST as a Mermaid.js flowchart.\n     *\n     * Useful for debugging complex patterns and documentation.\n     *\n     * @throws LexerException|ParserException\n     */\n    public function visualize(string $regex): string\n    {\n        $ast = $this->compiler->parse($regex);\n\n        return $ast->accept(new MermaidVisitor());\n    }\n\n    /**\n     * Dumps the AST as a string for debugging.\n     *\n     * @throws LexerException|ParserException\n     */\n    public function dump(string $regex): string\n    {\n        $ast = $this->compiler->parse($regex);\n\n        return $ast->accept(clone $this->dumper);\n    }\n\n    /**\n     * Extracts literal strings that must appear in any match.\n     * useful for pre-match optimizations (e.g. strpos check).\n     *\n     * @throws LexerException|ParserException\n     */\n    public function extractLiterals(string $regex): LiteralSet\n    {\n        $ast = $this->compiler->parse($regex);\n\n        $visitor = new LiteralExtractorVisitor();\n\n        return $ast->accept($visitor);\n    }\n\n    /**\n     * Performs a detailed ReDoS vulnerability analysis.\n     * Returns a report with severity, score, and recommendations.\n     */\n    public function analyzeReDoS(string $regex): ReDoSAnalysis\n    {\n        $analyzer = new ReDoSAnalyzer($this->compiler);\n\n        return $analyzer->analyze($regex);\n    }\n\n    /**\n     * Returns a fluent builder to construct regex programmatically.\n     */\n    public static function builder(): RegexBuilder\n    {\n        return RegexBuilder::create();\n    }\n\n    /**\n     * Returns the underlying RegexCompiler instance.\n     * Useful for advanced scenarios requiring direct access to the compiler.\n     */\n    public function getCompiler(): RegexCompiler\n    {\n        return $this->compiler;\n    }\n\n    /**\n     * Returns the underlying Parser instance.\n     * Useful for advanced scenarios requiring direct TokenStream parsing.\n     */\n    public function getParser(): Parser\n    {\n        return $this->compiler->getParser();\n    }\n}\n",
    "Token.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\n/**\n * Data Transfer Object representing a single token.\n */\nclass Token\n{\n    /**\n     * @param TokenType $type     The token type (e.g., T_LITERAL).\n     * @param string    $value    The string value of the token (e.g., \"a\", \"*\", \"\\d\").\n     * @param int       $position the 0-based character offset in the original string\n     */\n    public function __construct(\n        public readonly TokenType $type,\n        public readonly string $value,\n        public readonly int $position,\n    ) {}\n}\n",
    "NodeVisitor/CompilerNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that recompiles the AST back into a regex string.\n *\n * @implements NodeVisitorInterface<string>\n */\nclass CompilerNodeVisitor implements NodeVisitorInterface\n{\n    // PCRE meta-characters that must be escaped *outside* a character class.\n    // Note: The delimiter is handled dynamically via $this->delimiter.\n    // '|' is not included because it's handled by AlternationNode, not LiteralNode.\n    private const array META_CHARACTERS = [\n        '\\\\' => true, '.' => true, '^' => true, '$' => true,\n        '[' => true, ']' => true, '(' => true, ')' => true,\n        '*' => true, '+' => true, '?' => true, '{' => true, '}' => true,\n    ];\n\n    // Meta-characters that must be escaped *inside* a character class.\n    // '-' is crucial to escape to prevent creating unintended ranges.\n    // '^' is crucial to escape to prevent unintended negation if placed at start.\n    private const array CHAR_CLASS_META = [\n        '\\\\' => true, ']' => true, '-' => true, '^' => true,\n    ];\n\n    /**\n     * Tracks if we are currently compiling inside a character class.\n     */\n    private bool $inCharClass = false;\n\n    /**\n     * The current regex delimiter (needed to escape it in literals).\n     */\n    private string $delimiter = '/';\n\n    public function visitRegex(RegexNode $node): string\n    {\n        // Store the delimiter so visitLiteral can escape it properly\n        $this->delimiter = $node->delimiter;\n\n        // Re-add the dynamic delimiter and flags\n        $map = ['(' => ')', '[' => ']', '{' => '}', '<' => '>'];\n        $closingDelimiter = $map[$node->delimiter] ?? $node->delimiter;\n\n        return $node->delimiter.$node->pattern->accept($this).$closingDelimiter.$node->flags;\n    }\n\n    public function visitAlternation(AlternationNode $node): string\n    {\n        return implode('|', array_map(fn ($alt) => $alt->accept($this), $node->alternatives));\n    }\n\n    public function visitSequence(SequenceNode $node): string\n    {\n        // Concatenates the results of the sequence's children\n        return implode('', array_map(fn ($child) => $child->accept($this), $node->children));\n    }\n\n    public function visitGroup(GroupNode $node): string\n    {\n        $child = $node->child->accept($this);\n        $flags = $node->flags ?? '';\n\n        return match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => '('.$child.')',\n            GroupType::T_GROUP_NON_CAPTURING => '(?:'.$child.')',\n            GroupType::T_GROUP_NAMED => '(?<'.$node->name.'>'.$child.')',\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => '(?='.$child.')',\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => '(?!'.$child.')',\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => '(?<='.$child.')',\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => '(?<!'.$child.')',\n            GroupType::T_GROUP_ATOMIC => '(?>'.$child.')',\n            GroupType::T_GROUP_BRANCH_RESET => '(?|'.$child.')',\n            // For inline flags, only add ':' if there's actual content\n            GroupType::T_GROUP_INLINE_FLAGS => '' === $child ? '(?'.$flags.')' : '(?'.$flags.':'.$child.')',\n        };\n    }\n\n    public function visitQuantifier(QuantifierNode $node): string\n    {\n        /** @var string $nodeCompiled */\n        $nodeCompiled = $node->node->accept($this);\n\n        // Add non-capturing group if needed (e.g., \"abc*\" vs \"(?:abc)*\")\n        if ($node->node instanceof SequenceNode || $node->node instanceof AlternationNode) {\n            $nodeCompiled = '(?:'.$nodeCompiled.')';\n        }\n\n        $suffix = match ($node->type) {\n            QuantifierType::T_LAZY => '?',\n            QuantifierType::T_POSSESSIVE => '+',\n            default => '',\n        };\n\n        return $nodeCompiled.$node->quantifier.$suffix;\n    }\n\n    public function visitLiteral(LiteralNode $node): string\n    {\n        // Use different escaping rules depending on context\n        $meta = $this->inCharClass ? self::CHAR_CLASS_META : self::META_CHARACTERS;\n\n        // Special case: ']' is not meta if it's not in a char class\n        if (!$this->inCharClass && ']' === $node->value) {\n            return $node->value;\n        }\n\n        $result = '';\n        $length = mb_strlen($node->value);\n        for ($i = 0; $i < $length; $i++) {\n            $char = mb_substr($node->value, $i, 1);\n            // Always escape the delimiter character (both inside and outside char classes)\n            if ($char === $this->delimiter || isset($meta[$char])) {\n                $result .= '\\\\'.$char;\n            } else {\n                $result .= $char;\n            }\n        }\n\n        return $result;\n    }\n\n    public function visitCharType(CharTypeNode $node): string\n    {\n        // Re-add the backslash\n        return '\\\\'.$node->value;\n    }\n\n    public function visitDot(DotNode $node): string\n    {\n        return '.';\n    }\n\n    public function visitAnchor(AnchorNode $node): string\n    {\n        return $node->value;\n    }\n\n    public function visitAssertion(AssertionNode $node): string\n    {\n        return '\\\\'.$node->value;\n    }\n\n    public function visitKeep(KeepNode $node): string\n    {\n        return '\\K';\n    }\n\n    public function visitCharClass(CharClassNode $node): string\n    {\n        $this->inCharClass = true; // Set context for visitLiteral\n\n        $parts = implode('', array_map(fn ($part) => $part->accept($this), $node->parts));\n        $result = '['.($node->isNegated ? '^' : '').$parts.']';\n\n        $this->inCharClass = false; // Unset context\n\n        return $result;\n    }\n\n    public function visitRange(RangeNode $node): string\n    {\n        // Note: visitLiteral will handle escaping for start/end if they are meta-chars\n        return $node->start->accept($this).'-'.$node->end->accept($this);\n    }\n\n    public function visitBackref(BackrefNode $node): string\n    {\n        // For numeric backreferences, ensure backslash is present\n        if (ctype_digit($node->ref)) {\n            return '\\\\'.$node->ref;\n        }\n\n        // For \\g{N}, \\k<name>, etc., return as-is\n        return $node->ref;\n    }\n\n    public function visitUnicode(UnicodeNode $node): string\n    {\n        return $node->code; // Already \\xHH or \\u{...}\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): string\n    {\n        if (str_starts_with($node->prop, '^')) {\n            return '\\p{'.$node->prop.'}';\n        }\n\n        if (\\strlen($node->prop) > 1) {\n            return '\\p{'.$node->prop.'}';\n        }\n\n        return '\\p'.$node->prop;\n    }\n\n    public function visitOctal(OctalNode $node): string\n    {\n        return $node->code; // Already \\o{...}\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): string\n    {\n        return '\\\\'.$node->code;\n    }\n\n    public function visitPosixClass(PosixClassNode $node): string\n    {\n        return '[[:'.$node->class.':]]';\n    }\n\n    public function visitComment(CommentNode $node): string\n    {\n        return '(?#'.$node->comment.')';\n    }\n\n    public function visitConditional(ConditionalNode $node): string\n    {\n        // Special handling for condition: BackrefNode should output just the ref (no backslash)\n        if ($node->condition instanceof BackrefNode) {\n            $cond = $node->condition->ref;\n        } else {\n            $cond = $node->condition->accept($this);\n        }\n\n        $yes = $node->yes->accept($this);\n        $no = $node->no->accept($this);\n        if ('' === $no) {\n            return '(?('.$cond.')'.$yes.')';\n        }\n\n        return '(?('.$cond.')'.$yes.'|'.$no.')';\n    }\n\n    public function visitSubroutine(SubroutineNode $node): string\n    {\n        return match ($node->syntax) {\n            '&' => '(?&'.$node->reference.')',\n            'P>' => '(?P>'.$node->reference.')',\n            'g' => '\\g<'.$node->reference.'>', // Re-compile as \\g<name>\n            default => '(?'.$node->reference.')', // Handles (?R), (?1), (?-1)\n        };\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): string\n    {\n        return '(*'.$node->verb.')';\n    }\n\n    public function visitDefine(DefineNode $node): string\n    {\n        return '(?(DEFINE)'.$node->content->accept($this).')';\n    }\n}\n",
    "NodeVisitor/ComplexityScoreVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that calculates a numeric \"complexity score\" for the regex.\n * This score can be used to heuristically identify overly complex patterns\n * that may be inefficient or difficult to maintain.\n *\n * @implements NodeVisitorInterface<int>\n */\nclass ComplexityScoreVisitor implements NodeVisitorInterface\n{\n    /**\n     * Base score for a node.\n     */\n    private const int BASE_SCORE = 1;\n    /**\n     * Score multiplier for unbounded quantifiers (*, +, {n,}).\n     */\n    private const int UNBOUNDED_QUANTIFIER_SCORE = 10;\n    /**\n     * Score for complex constructs like lookarounds or backreferences.\n     */\n    private const int COMPLEX_CONSTRUCT_SCORE = 5;\n    /**\n     * Exponential multiplier for nested quantifiers.\n     */\n    private const int NESTING_MULTIPLIER = 2;\n\n    /**\n     * Tracks the depth of nested quantifiers.\n     */\n    private int $quantifierDepth = 0;\n\n    public function visitRegex(RegexNode $node): int\n    {\n        // Reset state for this run\n        $this->quantifierDepth = 0;\n\n        // The score of a regex is the score of its pattern\n        return $node->pattern->accept($this);\n    }\n\n    public function visitAlternation(AlternationNode $node): int\n    {\n        // Score is the sum of all alternatives, plus a base score for the alternation itself\n        $score = self::BASE_SCORE;\n        foreach ($node->alternatives as $alt) {\n            $score += $alt->accept($this);\n        }\n\n        return $score;\n    }\n\n    public function visitSequence(SequenceNode $node): int\n    {\n        // Score is the sum of all children\n        $score = 0;\n        foreach ($node->children as $child) {\n            $score += $child->accept($this);\n        }\n\n        return $score;\n    }\n\n    public function visitGroup(GroupNode $node): int\n    {\n        $childScore = $node->child->accept($this);\n\n        // Lookarounds are considered complex\n        if (\\in_array(\n            $node->type,\n            [\n                GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n                GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n                GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n                GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n            ],\n            true,\n        )) {\n            return self::COMPLEX_CONSTRUCT_SCORE + $childScore;\n        }\n\n        return self::BASE_SCORE + $childScore;\n    }\n\n    public function visitQuantifier(QuantifierNode $node): int\n    {\n        $quant = $node->quantifier;\n        $isUnbounded = \\in_array($quant, ['*', '+'], true) || preg_match('/^\\{\\d+,\\}$/', $quant);\n        $score = 0;\n\n        if ($isUnbounded) {\n            $score += self::UNBOUNDED_QUANTIFIER_SCORE;\n            if ($this->quantifierDepth > 0) {\n                // Exponentially penalize nested unbounded quantifiers\n                $score *= (self::NESTING_MULTIPLIER * $this->quantifierDepth);\n            }\n            $this->quantifierDepth++;\n        } else {\n            // Bounded quantifiers are simpler\n            $score += self::BASE_SCORE;\n        }\n\n        // Add the score of the quantified node\n        $score += $node->node->accept($this);\n\n        if ($isUnbounded) {\n            $this->quantifierDepth--;\n        }\n\n        return $score;\n    }\n\n    public function visitCharClass(CharClassNode $node): int\n    {\n        // Score is the sum of parts inside the class\n        $score = self::BASE_SCORE;\n        foreach ($node->parts as $part) {\n            $score += $part->accept($this);\n        }\n\n        return $score;\n    }\n\n    public function visitBackref(BackrefNode $node): int\n    {\n        return self::COMPLEX_CONSTRUCT_SCORE;\n    }\n\n    public function visitConditional(ConditionalNode $node): int\n    {\n        // Conditionals are highly complex\n        $score = self::COMPLEX_CONSTRUCT_SCORE * 2;\n        $score += $node->condition->accept($this);\n        $score += $node->yes->accept($this);\n        $score += $node->no->accept($this);\n\n        return $score;\n    }\n\n    public function visitSubroutine(SubroutineNode $node): int\n    {\n        // Subroutines/recursion are highly complex\n        return self::COMPLEX_CONSTRUCT_SCORE * 2;\n    }\n\n    // --- Simple nodes have a base score of 1 ---\n\n    public function visitLiteral(LiteralNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitCharType(CharTypeNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitDot(DotNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitAnchor(AnchorNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitAssertion(AssertionNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitKeep(KeepNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitRange(RangeNode $node): int\n    {\n        return self::BASE_SCORE + $node->start->accept($this) + $node->end->accept($this);\n    }\n\n    public function visitUnicode(UnicodeNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitOctal(OctalNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitPosixClass(PosixClassNode $node): int\n    {\n        return self::BASE_SCORE;\n    }\n\n    public function visitComment(CommentNode $node): int\n    {\n        // Comments do not add to complexity\n        return 0;\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): int\n    {\n        return self::COMPLEX_CONSTRUCT_SCORE;\n    }\n\n    public function visitDefine(DefineNode $node): int\n    {\n        // DEFINE blocks add complexity from their content\n        return self::COMPLEX_CONSTRUCT_SCORE + $node->content->accept($this);\n    }\n}\n",
    "NodeVisitor/LiteralExtractorVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\LiteralSet;\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * Extracts literal strings that must appear in any match.\n *\n * This visitor analyzes the regex AST to identify fixed strings\n * that are guaranteed to appear in every possible match. These\n * literals can be used for fast-path optimizations (e.g. strpos check).\n *\n * @implements NodeVisitorInterface<LiteralSet>\n */\nfinal class LiteralExtractorVisitor implements NodeVisitorInterface\n{\n    /**\n     * Maximum number of literals generated to prevent explosion (e.g. [a-z]{10}).\n     */\n    private const int MAX_LITERALS_COUNT = 128;\n\n    private bool $caseInsensitive = false;\n\n    public function visitRegex(RegexNode $node): LiteralSet\n    {\n        $this->caseInsensitive = str_contains($node->flags, 'i');\n\n        return $node->pattern->accept($this);\n    }\n\n    public function visitAlternation(AlternationNode $node): LiteralSet\n    {\n        $result = null;\n\n        foreach ($node->alternatives as $alt) {\n            /** @var LiteralSet $altSet */\n            $altSet = $alt->accept($this);\n\n            if (null === $result) {\n                $result = $altSet;\n            } else {\n                $result = $result->unite($altSet);\n            }\n\n            // Safety valve for memory\n            if (\\count($result->prefixes) > self::MAX_LITERALS_COUNT) {\n                return LiteralSet::empty();\n            }\n        }\n\n        return $result ?? LiteralSet::empty();\n    }\n\n    public function visitSequence(SequenceNode $node): LiteralSet\n    {\n        $result = LiteralSet::fromString(''); // Start with empty complete string\n\n        foreach ($node->children as $child) {\n            /** @var LiteralSet $childSet */\n            $childSet = $child->accept($this);\n            $result = $result->concat($childSet);\n\n            // Safety valve\n            if (\\count($result->prefixes) > self::MAX_LITERALS_COUNT) {\n                return LiteralSet::empty();\n            }\n        }\n\n        return $result;\n    }\n\n    public function visitGroup(GroupNode $node): LiteralSet\n    {\n        // Handle inline flags if present\n        $previousState = $this->caseInsensitive;\n        if ($node->flags) {\n            if (str_contains($node->flags, '-i')) {\n                $this->caseInsensitive = false;\n            } elseif (str_contains($node->flags, 'i')) {\n                $this->caseInsensitive = true;\n            }\n        }\n\n        /** @var LiteralSet $result */\n        $result = $node->child->accept($this);\n\n        // Restore state\n        $this->caseInsensitive = $previousState;\n\n        return $result;\n    }\n\n    public function visitQuantifier(QuantifierNode $node): LiteralSet\n    {\n        // Case 1: Exact quantifier {n} -> repeat literals n times\n        if (preg_match('/^\\{(\\d+)\\}$/', $node->quantifier, $m)) {\n            $count = (int) $m[1];\n            if (0 === $count) {\n                return LiteralSet::fromString(''); // Matches empty string\n            }\n\n            /** @var LiteralSet $childSet */\n            $childSet = $node->node->accept($this);\n\n            // Repeat concatenation\n            $result = $childSet;\n            for ($i = 1; $i < $count; $i++) {\n                $result = $result->concat($childSet);\n                if (\\count($result->prefixes) > self::MAX_LITERALS_COUNT) {\n                    return LiteralSet::empty();\n                }\n            }\n\n            return $result;\n        }\n\n        // Case 2: + or {n,} (At least 1)\n        // We can extract the literal from the node, but it's not complete anymore because of the tail\n        if ('+' === $node->quantifier || preg_match('/^\\{(\\d+),/', $node->quantifier)) {\n            /** @var LiteralSet $childSet */\n            $childSet = $node->node->accept($this);\n\n            // The literal is present at least once, but followed by unknown quantity.\n            // So suffixes are lost, completeness is lost.\n            return new LiteralSet($childSet->prefixes, [], false);\n        }\n\n        // Case 3: * or ? (Optional)\n        // Cannot guarantee presence.\n        return LiteralSet::empty();\n    }\n\n    public function visitLiteral(LiteralNode $node): LiteralSet\n    {\n        if ($this->caseInsensitive) {\n            return $this->expandCaseInsensitive($node->value);\n        }\n\n        return LiteralSet::fromString($node->value);\n    }\n\n    public function visitCharClass(CharClassNode $node): LiteralSet\n    {\n        // Optimization: Single character class [a] is literal 'a'\n        if (!$node->isNegated && 1 === \\count($node->parts) && $node->parts[0] instanceof LiteralNode) {\n            return $this->visitLiteral($node->parts[0]);\n        }\n\n        // [abc] is effectively an alternation a|b|c\n        // We only handle simple literals inside char classes for now to avoid complexity\n        if (!$node->isNegated) {\n            $literals = [];\n            foreach ($node->parts as $part) {\n                if ($part instanceof LiteralNode) {\n                    if ($this->caseInsensitive) {\n                        $expanded = $this->expandCaseInsensitive($part->value);\n                        array_push($literals, ...$expanded->prefixes);\n                    } else {\n                        $literals[] = $part->value;\n                    }\n                } else {\n                    // Range, char type, etc. -> considered non-literal for simplicity\n                    return LiteralSet::empty();\n                }\n            }\n\n            return new LiteralSet($literals, $literals, true); // Complete single char match\n        }\n\n        return LiteralSet::empty();\n    }\n\n    // --- The following nodes interrupt literal sequences ---\n\n    public function visitCharType(CharTypeNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitDot(DotNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitAnchor(AnchorNode $node): LiteralSet\n    {\n        // Anchors match empty strings, so they are \"complete\" empty matches\n        // This allows /^abc/ to return prefix 'abc'\n        return LiteralSet::fromString('');\n    }\n\n    public function visitAssertion(AssertionNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    public function visitKeep(KeepNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    public function visitRange(RangeNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitBackref(BackrefNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitUnicode(UnicodeNode $node): LiteralSet\n    {\n        // Could resolve hex, but for now treat as empty set unless we decode it\n        // Assuming RegexParser doesn't decode unicode in AST yet (it keeps raw \\xHH)\n        return LiteralSet::empty();\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitOctal(OctalNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitPosixClass(PosixClassNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitComment(CommentNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    public function visitConditional(ConditionalNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitSubroutine(SubroutineNode $node): LiteralSet\n    {\n        return LiteralSet::empty();\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): LiteralSet\n    {\n        return LiteralSet::fromString('');\n    }\n\n    public function visitDefine(DefineNode $node): LiteralSet\n    {\n        // DEFINE blocks don't produce any literal matches\n        return LiteralSet::empty();\n    }\n\n    /**\n     * Generates case variants. Currently limited to basic ASCII for performance/simplicity.\n     * Only expands if resulting set size is small.\n     */\n    private function expandCaseInsensitive(string $value): LiteralSet\n    {\n        // Limit expansion length\n        if (\\strlen($value) > 8) {\n            return LiteralSet::empty(); // Too expensive to compute permutations\n        }\n\n        $results = [''];\n        for ($i = 0; $i < \\strlen($value); $i++) {\n            $char = $value[$i];\n            $lower = strtolower($char);\n            $upper = strtoupper($char);\n\n            $nextResults = [];\n            foreach ($results as $prefix) {\n                if ($lower === $upper) {\n                    $nextResults[] = $prefix.$char;\n                } else {\n                    $nextResults[] = $prefix.$lower;\n                    $nextResults[] = $prefix.$upper;\n                }\n            }\n            $results = $nextResults;\n        }\n\n        if (\\count($results) > self::MAX_LITERALS_COUNT) {\n            return LiteralSet::empty();\n        }\n\n        return new LiteralSet($results, $results, true);\n    }\n}\n",
    "NodeVisitor/HtmlExplainVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that explains the AST in an HTML format for rich display.\n *\n * @implements NodeVisitorInterface<string>\n */\nclass HtmlExplainVisitor implements NodeVisitorInterface\n{\n    private const array CHAR_TYPE_MAP = [\n        'd' => 'any digit (0-9)',\n        'D' => 'any non-digit',\n        's' => 'any whitespace character',\n        'S' => 'any non-whitespace character',\n        'w' => 'any \"word\" character (alphanumeric or _)',\n        'W' => 'any \"non-word\" character',\n        'h' => 'any horizontal whitespace',\n        'H' => 'any non-horizontal whitespace',\n        'v' => 'any vertical whitespace',\n        'V' => 'any non-vertical whitespace',\n        'R' => 'a generic newline (\\\\r\\\\n, \\\\r, or \\\\n)',\n    ];\n\n    private const array ANCHOR_MAP = [\n        '^' => 'the start of the string (or line, with /m flag)',\n        '$' => 'the end of the string (or line, with /m flag)',\n    ];\n\n    private const array ASSERTION_MAP = [\n        'A' => 'the absolute start of the string',\n        'z' => 'the absolute end of the string',\n        'Z' => 'the end of the string (before final newline)',\n        'G' => 'the position of the last successful match',\n        'b' => 'a word boundary',\n        'B' => 'a non-word boundary',\n    ];\n\n    public function visitRegex(RegexNode $node): string\n    {\n        $patternExplain = $node->pattern->accept($this);\n        $flags = $node->flags ? $this->e(' (with flags: '.$node->flags.')') : '';\n\n        return \\sprintf(\n            \"<div class=\\\"regex-explain\\\">\\n<strong>Regex matches%s:</strong>\\n<ul>%s</ul>\\n</div>\",\n            $flags,\n            $patternExplain,\n        );\n    }\n\n    public function visitAlternation(AlternationNode $node): string\n    {\n        $alts = array_map(\n            fn (NodeInterface $alt) => $alt->accept($this),\n            $node->alternatives,\n        );\n\n        return \\sprintf(\n            \"<li><strong>EITHER:</strong>\\n<ul>%s</ul>\\n</li>\",\n            implode(\"\\n<li><strong>OR:</strong>\\n<ul>\", $alts),\n        );\n    }\n\n    public function visitSequence(SequenceNode $node): string\n    {\n        $parts = array_map(fn ($child) => $child->accept($this), $node->children);\n        $parts = array_filter($parts, fn ($part) => '' !== $part);\n\n        return implode(\"\\n\", $parts);\n    }\n\n    public function visitGroup(GroupNode $node): string\n    {\n        $childExplain = $node->child->accept($this);\n        $type = match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => 'Start Capturing Group',\n            GroupType::T_GROUP_NON_CAPTURING => 'Start Non-Capturing Group',\n            GroupType::T_GROUP_NAMED => \\sprintf(\"Start Capturing Group (named: '%s')\", $this->e($node->name)),\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => 'Start Positive Lookahead',\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => 'Start Negative Lookahead',\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => 'Start Positive Lookbehind',\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => 'Start Negative Lookbehind',\n            GroupType::T_GROUP_ATOMIC => 'Start Atomic Group',\n            GroupType::T_GROUP_BRANCH_RESET => 'Start Branch Reset Group',\n            GroupType::T_GROUP_INLINE_FLAGS => \\sprintf(\"Start Group (with flags: '%s')\", $this->e($node->flags)),\n        };\n\n        return \\sprintf(\n            \"<li><span title=\\\"%s\\\"><strong>%s:</strong></span>\\n<ul>%s</ul>\\n</li>\",\n            $this->e($type),\n            $this->e($type),\n            $childExplain,\n        );\n    }\n\n    public function visitQuantifier(QuantifierNode $node): string\n    {\n        $childExplain = $node->node->accept($this);\n        $quantExplain = $this->explainQuantifierValue($node->quantifier, $node->type);\n\n        // If the child is simple (one line <li>), put it on one line.\n        if (str_starts_with($childExplain, '<li>') && !str_contains(substr($childExplain, 4), '<li>')) {\n            // Inject the quantifier explanation into the child's <li>\n            return str_replace('<li>', \\sprintf('<li>(%s) ', $this->e($quantExplain)), $childExplain);\n        }\n\n        // If the child is complex, wrap it\n        return \\sprintf(\n            \"<li><strong>Quantifier (%s):</strong>\\n<ul>%s</ul>\\n</li>\",\n            $this->e($quantExplain),\n            $childExplain,\n        );\n    }\n\n    public function visitLiteral(LiteralNode $node): string\n    {\n        $explanation = $this->explainLiteral($node->value);\n\n        return \\sprintf(\n            '<li><span title=\"Literal: %s\">Literal: <strong>%s</strong></span></li>',\n            $this->e($explanation),\n            $this->e($explanation),\n        );\n    }\n\n    public function visitCharType(CharTypeNode $node): string\n    {\n        $explanation = self::CHAR_TYPE_MAP[$node->value] ?? 'unknown (\\\\'.$node->value.')';\n\n        return \\sprintf(\n            '<li><span title=\"Character Type: %s\">Character Type: <strong>\\%s</strong> (%s)</span></li>',\n            $this->e($explanation),\n            $this->e($node->value),\n            $this->e($explanation),\n        );\n    }\n\n    public function visitDot(DotNode $node): string\n    {\n        $explanation = 'any character (except newline, unless /s flag is used)';\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Wildcard: <strong>.</strong> (%s)</span></li>',\n            $this->e($explanation),\n            $this->e($explanation),\n        );\n    }\n\n    public function visitAnchor(AnchorNode $node): string\n    {\n        $explanation = self::ANCHOR_MAP[$node->value] ?? $node->value;\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Anchor: <strong>%s</strong> (%s)</span></li>',\n            $this->e($explanation),\n            $this->e($node->value),\n            $this->e($explanation),\n        );\n    }\n\n    public function visitAssertion(AssertionNode $node): string\n    {\n        $explanation = self::ASSERTION_MAP[$node->value] ?? '\\\\'.$node->value;\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Assertion: <strong>\\%s</strong> (%s)</span></li>',\n            $this->e($explanation),\n            $this->e($node->value),\n            $this->e($explanation),\n        );\n    }\n\n    public function visitKeep(KeepNode $node): string\n    {\n        $explanation = '\\K (reset match start)';\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Assertion: <strong>\\K</strong> (%s)</span></li>',\n            $this->e($explanation),\n            $this->e($explanation),\n        );\n    }\n\n    public function visitCharClass(CharClassNode $node): string\n    {\n        $neg = $node->isNegated ? '<strong>NOT</strong> ' : '';\n        $parts = array_map(fn (NodeInterface $part) => $part->accept($this), $node->parts);\n\n        // Char class parts are just strings, not <li>\n        $parts = array_map(strip_tags(...), $parts);\n\n        $explanation = \\sprintf('any character %sin [ %s ]', $neg, implode(', ', $parts));\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Character Class: [ %s%s ]</span></li>',\n            $this->e(strip_tags($explanation)),\n            $neg,\n            $this->e(implode(', ', $parts)),\n        );\n    }\n\n    public function visitRange(RangeNode $node): string\n    {\n        $start = ($node->start instanceof LiteralNode)\n            ? $this->explainLiteral($node->start->value)\n            : $node->start->accept($this);\n\n        $end = ($node->end instanceof LiteralNode)\n            ? $this->explainLiteral($node->end->value)\n            : $node->end->accept($this);\n\n        return \\sprintf('Range: from %s to %s', $this->e($start), $this->e($end));\n    }\n\n    public function visitBackref(BackrefNode $node): string\n    {\n        $explanation = \\sprintf('matches text from group \"%s\"', $node->ref);\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Backreference: <strong>\\%s</strong></span></li>',\n            $this->e($explanation),\n            $this->e($node->ref),\n        );\n    }\n\n    public function visitUnicode(UnicodeNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"Unicode: %s\">Unicode: <strong>%s</strong></span></li>',\n            $this->e($node->code),\n            $this->e($node->code),\n        );\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): string\n    {\n        $type = str_starts_with($node->prop, '^') ? 'non-matching' : 'matching';\n        $prop = ltrim($node->prop, '^');\n        $explanation = \\sprintf('any character %s \"%s\"', $type, $prop);\n        $prefix = str_starts_with($node->prop, '^') ? 'P' : 'p';\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Unicode Property: <strong>\\%s{%s}</strong></span></li>',\n            $this->e($explanation),\n            $prefix,\n            $this->e($prop),\n        );\n    }\n\n    public function visitOctal(OctalNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"Octal: %s\">Octal: <strong>%s</strong></span></li>',\n            $this->e($node->code),\n            $this->e($node->code),\n        );\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"Legacy Octal: %s\">Legacy Octal: <strong>\\%s</strong></span></li>',\n            $this->e($node->code),\n            $this->e($node->code),\n        );\n    }\n\n    public function visitPosixClass(PosixClassNode $node): string\n    {\n        return \\sprintf('POSIX Class: [[:%s:]]', $this->e($node->class));\n    }\n\n    public function visitComment(CommentNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"Comment\" style=\"color: #888; font-style: italic;\">Comment: %s</span></li>',\n            $this->e($node->comment),\n        );\n    }\n\n    public function visitConditional(ConditionalNode $node): string\n    {\n        $cond = $node->condition->accept($this);\n        $yes = $node->yes->accept($this);\n\n        // Check if the 'no' branch is an empty literal node\n        $hasElseBranch = !($node->no instanceof LiteralNode && '' === $node->no->value);\n        $no = $hasElseBranch ? $node->no->accept($this) : '';\n\n        // Condition node will be a <li>, just need its text\n        $condText = trim(strip_tags($cond));\n\n        if ('' === $no || '<li></li>' === $no) {\n            return \\sprintf(\n                \"<li><strong>Conditional: IF</strong> (%s) <strong>THEN:</strong>\\n<ul>%s</ul>\\n</li>\",\n                $this->e($condText),\n                $yes,\n            );\n        }\n\n        return \\sprintf(\n            \"<li><strong>Conditional: IF</strong> (%s) <strong>THEN:</strong>\\n<ul>%s</ul>\\n<strong>ELSE:</strong>\\n<ul>%s</ul>\\n</li>\",\n            $this->e($condText),\n            $yes,\n            $no,\n        );\n    }\n\n    public function visitSubroutine(SubroutineNode $node): string\n    {\n        $ref = match ($node->reference) {\n            'R' => 'the entire pattern',\n            '0' => 'the entire pattern',\n            default => 'group '.$this->e($node->reference),\n        };\n        $explanation = \\sprintf('recurses to %s', $ref);\n\n        return \\sprintf(\n            '<li><span title=\"%s\">Subroutine Call: <strong>(%s%s)</strong></span></li>',\n            $this->e($explanation),\n            $this->e($node->syntax),\n            $this->e($node->reference),\n        );\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): string\n    {\n        return \\sprintf(\n            '<li><span title=\"PCRE Verb\">PCRE Verb: <strong>(*%s)</strong></span></li>',\n            $this->e($node->verb),\n        );\n    }\n\n    public function visitDefine(DefineNode $node): string\n    {\n        $content = $node->content->accept($this);\n\n        return \\sprintf(\n            \"<li><strong>DEFINE Block</strong> (defines subpatterns without matching):\\n<ul>%s</ul>\\n</li>\",\n            $content,\n        );\n    }\n\n    private function explainQuantifierValue(string $q, QuantifierType $type): string\n    {\n        $desc = match ($q) {\n            '*' => 'zero or more times',\n            '+' => 'one or more times',\n            '?' => 'zero or one time',\n            default => preg_match('/^\\{(\\d+)(?:,(\\d*))?\\}$/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    \\sprintf('at least %d times', $m[1]) :\n                    \\sprintf('between %d and %d times', $m[1], $m[2])\n                ) :\n                    \\sprintf('exactly %d times', $m[1])\n                ) :\n                'with quantifier '.$q, // Fallback\n        };\n\n        $desc .= match ($type) {\n            QuantifierType::T_LAZY => ' (as few as possible)',\n            QuantifierType::T_POSSESSIVE => ' (and do not backtrack)',\n            default => '',\n        };\n\n        return $desc;\n    }\n\n    private function explainLiteral(string $value): string\n    {\n        return match ($value) {\n            ' ' => \"' ' (space)\",\n            \"\\t\" => \"'\\\\t' (tab)\",\n            \"\\n\" => \"'\\\\n' (newline)\",\n            \"\\r\" => \"'\\\\r' (carriage return)\",\n            default => ctype_print($value) ? \"'\".$value.\"'\" : '(non-printable char)',\n        };\n    }\n\n    /**\n     * Helper for HTML escaping.\n     */\n    private function e(?string $s): string\n    {\n        return htmlspecialchars((string) $s, \\ENT_QUOTES, 'UTF-8');\n    }\n}\n",
    "NodeVisitor/DumperNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that dumps the AST as a string for debugging.\n *\n * @implements NodeVisitorInterface<string>\n */\nclass DumperNodeVisitor implements NodeVisitorInterface\n{\n    private int $indent = 0;\n\n    public function visitRegex(RegexNode $node): string\n    {\n        $str = \"Regex(delimiter: {$node->delimiter}, flags: {$node->flags})\\n\";\n        $this->indent += 2;\n        $str .= $node->pattern->accept($this);\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    public function visitAlternation(AlternationNode $node): string\n    {\n        $str = str_repeat(' ', $this->indent).\"Alternation:\\n\";\n        $this->indent += 2;\n        foreach ($node->alternatives as $alt) {\n            $str .= str_repeat(' ', $this->indent).$alt->accept($this).\"\\n\";\n        }\n        $this->indent -= 2;\n\n        return rtrim($str, \"\\n\");\n    }\n\n    public function visitSequence(SequenceNode $node): string\n    {\n        $str = str_repeat(' ', $this->indent).\"Sequence:\\n\";\n        $this->indent += 2;\n        foreach ($node->children as $child) {\n            $str .= str_repeat(' ', $this->indent).$child->accept($this).\"\\n\";\n        }\n        $this->indent -= 2;\n\n        return rtrim($str, \"\\n\");\n    }\n\n    public function visitGroup(GroupNode $node): string\n    {\n        $name = $node->name ?? '';\n        $flags = $node->flags ?? '';\n\n        // Only include \"name:\" label if name is not empty\n        $nameStr = ('' !== $name) ? \" name: {$name}\" : '';\n        $str = \"Group(type: {$node->type->value}{$nameStr} flags: {$flags})\\n\";\n        $this->indent += 2;\n        $str .= $node->child->accept($this);\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    public function visitQuantifier(QuantifierNode $node): string\n    {\n        return \"Quantifier(quant: {$node->quantifier}, type: {$node->type->value})\\n\".$this->indent(\n            $node->node->accept($this),\n        );\n    }\n\n    public function visitLiteral(LiteralNode $node): string\n    {\n        return \"Literal('{$node->value}')\";\n    }\n\n    public function visitCharType(CharTypeNode $node): string\n    {\n        return \"CharType('\\\\{$node->value}')\";\n    }\n\n    public function visitDot(DotNode $node): string\n    {\n        return 'Dot(.)';\n    }\n\n    public function visitAnchor(AnchorNode $node): string\n    {\n        return \"Anchor({$node->value})\";\n    }\n\n    public function visitAssertion(AssertionNode $node): string\n    {\n        return \"Assertion(\\\\{$node->value})\";\n    }\n\n    public function visitKeep(KeepNode $node): string\n    {\n        return 'Keep(\\K)';\n    }\n\n    public function visitCharClass(CharClassNode $node): string\n    {\n        $neg = $node->isNegated ? '^' : '';\n        $str = \"CharClass({$neg})\\n\";\n        $this->indent += 2;\n        foreach ($node->parts as $part) {\n            $str .= $this->indent($part->accept($this)).\"\\n\";\n        }\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    public function visitRange(RangeNode $node): string\n    {\n        return \"Range({$node->start->accept($this)} - {$node->end->accept($this)})\";\n    }\n\n    public function visitBackref(BackrefNode $node): string\n    {\n        return \"Backref(\\\\{$node->ref})\";\n    }\n\n    public function visitUnicode(UnicodeNode $node): string\n    {\n        return \"Unicode({$node->code})\";\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): string\n    {\n        return \"UnicodeProp(\\\\p{{$node->prop}})\";\n    }\n\n    public function visitOctal(OctalNode $node): string\n    {\n        return \"Octal({$node->code})\";\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): string\n    {\n        return \"OctalLegacy(\\\\{$node->code})\";\n    }\n\n    public function visitPosixClass(PosixClassNode $node): string\n    {\n        return \"PosixClass([[:{$node->class}:]])\";\n    }\n\n    public function visitComment(CommentNode $node): string\n    {\n        return \"Comment('{$node->comment}')\";\n    }\n\n    public function visitConditional(ConditionalNode $node): string\n    {\n        $str = \"Conditional:\\n\";\n        $this->indent += 2;\n        $str .= $this->indent('Condition: '.$node->condition->accept($this)).\"\\n\";\n        $str .= $this->indent('Yes: '.$node->yes->accept($this)).\"\\n\";\n        $str .= $this->indent('No: '.$node->no->accept($this)).\"\\n\";\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    public function visitSubroutine(SubroutineNode $node): string\n    {\n        return \"Subroutine(ref: {$node->reference}, syntax: '{$node->syntax}')\";\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): string\n    {\n        return \"PcreVerb(value: {$node->verb})\";\n    }\n\n    public function visitDefine(DefineNode $node): string\n    {\n        $str = \"Define:\\n\";\n        $this->indent += 2;\n        $str .= $this->indent('Content: '.$node->content->accept($this)).\"\\n\";\n        $this->indent -= 2;\n\n        return $str;\n    }\n\n    private function indent(string $str): string\n    {\n        $indentStr = str_repeat(' ', $this->indent);\n\n        return $indentStr.str_replace(\"\\n\", \"\\n\".$indentStr, $str);\n    }\n}\n",
    "NodeVisitor/SampleGeneratorVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that generates a random sample string that matches the AST.\n *\n * @implements NodeVisitorInterface<string>\n */\nclass SampleGeneratorVisitor implements NodeVisitorInterface\n{\n    private ?int $seed = null;\n\n    /**\n     * Stores generated text from capturing groups.\n     * Keyed by both numeric index and name (if available).\n     *\n     * @var array<int|string, string>\n     */\n    private array $captures = [];\n\n    private int $groupCounter = 1;\n\n    /**\n     * @param int $maxRepetition max times to repeat for * or + quantifiers\n     *                           to prevent excessively long or infinite samples\n     */\n    public function __construct(private readonly int $maxRepetition = 3) {}\n\n    /**\n     * Seeds the Mersenne Twister random number generator.\n     * This allows for generating deterministic, reproducible samples.\n     */\n    public function setSeed(int $seed): void\n    {\n        $this->seed = $seed;\n        mt_srand($seed);\n    }\n\n    /**\n     * Reseeds the random number generator with a random value.\n     */\n    public function resetSeed(): void\n    {\n        $this->seed = null;\n        mt_srand();\n    }\n\n    public function visitRegex(RegexNode $node): string\n    {\n        // Reset state for this run\n        $this->captures = [];\n        $this->groupCounter = 1;\n\n        // Ensure we are seeded if the user expects it\n        if (null !== $this->seed) {\n            mt_srand($this->seed);\n        }\n\n        // Note: Flags (like /i) are ignored, as we generate the sample\n        // from the literal pattern.\n        return $node->pattern->accept($this);\n    }\n\n    public function visitAlternation(AlternationNode $node): string\n    {\n        if (empty($node->alternatives)) {\n            return '';\n        }\n\n        // Pick one of the alternatives at random\n        $randomKey = mt_rand(0, \\count($node->alternatives) - 1);\n        $chosenAlt = $node->alternatives[$randomKey];\n\n        return $chosenAlt->accept($this);\n    }\n\n    public function visitSequence(SequenceNode $node): string\n    {\n        $parts = array_map(fn ($child) => $child->accept($this), $node->children);\n\n        return implode('', $parts);\n    }\n\n    public function visitGroup(GroupNode $node): string\n    {\n        // Lookarounds are zero-width assertions and should not generate text\n        if (\\in_array($node->type, [\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n        ], true)) {\n            return '';\n        }\n\n        $result = $node->child->accept($this);\n\n        // Store the result if it's a capturing group\n        if (GroupType::T_GROUP_CAPTURING === $node->type) {\n            $this->captures[$this->groupCounter++] = $result;\n        } elseif (GroupType::T_GROUP_NAMED === $node->type) {\n            $this->captures[$this->groupCounter++] = $result;\n            if ($node->name) {\n                $this->captures[$node->name] = $result;\n            }\n        }\n\n        // For non-capturing, etc., just return the child's result\n        return $result;\n    }\n\n    public function visitQuantifier(QuantifierNode $node): string\n    {\n        [$min, $max] = $this->parseQuantifierRange($node->quantifier);\n\n        // Pick a random number of repetitions\n        try {\n            // $min and $max are guaranteed to be in the correct order\n            // by parseQuantifierRange()\n            $repeats = ($min === $max) ? $min : mt_rand($min, $max);\n        } catch (\\Throwable) {\n            $repeats = $min; // Fallback\n        }\n\n        $parts = [];\n        for ($i = 0; $i < $repeats; $i++) {\n            $parts[] = $node->node->accept($this);\n        }\n\n        return implode('', $parts);\n    }\n\n    public function visitLiteral(LiteralNode $node): string\n    {\n        return $node->value;\n    }\n\n    public function visitCharType(CharTypeNode $node): string\n    {\n        return $this->generateForCharType($node->value);\n    }\n\n    public function visitDot(DotNode $node): string\n    {\n        // Generate a random, simple, printable ASCII char\n        return $this->getRandomChar(['a', 'b', 'c', '1', '2', '3', ' ']);\n    }\n\n    public function visitAnchor(AnchorNode $node): string\n    {\n        // Anchors do not generate text\n        return '';\n    }\n\n    public function visitAssertion(AssertionNode $node): string\n    {\n        // Assertions do not generate text\n        return '';\n    }\n\n    public function visitKeep(KeepNode $node): string\n    {\n        // \\K does not generate text\n        return '';\n    }\n\n    public function visitCharClass(CharClassNode $node): string\n    {\n        if ($node->isNegated) {\n            // Generating for a negated class is complex.\n            // We'd have to know the full set of all possible chars\n            // (ASCII? Unicode?) and subtract the parts.\n            // For a sample, it's safer to return a known \"safe\" char\n            // that is unlikely to be in the negated set.\n            return '!'; // e.g., a \"safe\" punctuation mark\n        }\n\n        if (empty($node->parts)) {\n            // e.g., [] which can never match\n            throw new \\RuntimeException('Cannot generate sample for empty character class');\n        }\n\n        // Pick one of the parts at random\n        $randomKey = mt_rand(0, \\count($node->parts) - 1);\n\n        return $node->parts[$randomKey]->accept($this);\n    }\n\n    public function visitRange(RangeNode $node): string\n    {\n        if (!$node->start instanceof LiteralNode || !$node->end instanceof LiteralNode) {\n            // Should be caught by Validator, but good to check\n            return $node->start->accept($this);\n        }\n\n        // Generate a random character within the ASCII range\n        try {\n            $ord1 = \\ord($node->start->value);\n            $ord2 = \\ord($node->end->value);\n\n            return \\chr(mt_rand($ord1, $ord2));\n        } catch (\\Throwable) {\n            // Fallback if ord() fails\n            return $node->start->value;\n        }\n    }\n\n    public function visitBackref(BackrefNode $node): string\n    {\n        $ref = $node->ref;\n\n        // Check numeric reference first\n        if (ctype_digit($ref)) {\n            $key = (int) $ref;\n            if (isset($this->captures[$key])) {\n                return $this->captures[$key];\n            }\n        }\n\n        // Check string/named reference (e.g. for (?&name) conditionals)\n        if (isset($this->captures[$ref])) {\n            return $this->captures[$ref];\n        }\n\n        // Handle named \\k<name> or \\k{name} backrefs\n        // $ref is guaranteed to be a string here.\n        if (preg_match('/^\\\\\\\\k<(\\w+)>$/', $ref, $m) || preg_match('/^\\\\\\\\k\\{(\\w+)\\}$/', $ref, $m)) {\n            return $this->captures[$m[1]] ?? '';\n        }\n\n        // Backreference to a group that hasn't matched yet\n        // (or doesn't exist). In a real engine, this fails the match.\n        // For generation, we must return empty string.\n        return '';\n    }\n\n    public function visitUnicode(UnicodeNode $node): string\n    {\n        if (preg_match('/^\\\\\\\\x([0-9a-fA-F]{2})$/', $node->code, $m)) {\n            return \\chr((int) hexdec($m[1]));\n        }\n        if (preg_match('/^\\\\\\\\u\\{([0-9a-fA-F]+)\\}$/', $node->code, $m)) {\n            return mb_chr((int) hexdec($m[1]), 'UTF-8');\n        }\n\n        // Fallback for unknown unicode\n        return '?';\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): string\n    {\n        // Too complex to generate a *random* char for a property.\n        // Return a known-good sample.\n        if (str_contains($node->prop, 'L')) { // 'L' (Letter)\n            return $this->getRandomChar(['a', 'b', 'c']);\n        }\n        if (str_contains($node->prop, 'N')) { // 'N' (Number)\n            return $this->getRandomChar(['1', '2', '3']);\n        }\n        if (str_contains($node->prop, 'P')) { // 'P' (Punctuation)\n            return $this->getRandomChar(['.', ',', '!']);\n        }\n\n        return $this->getRandomChar(['a', '1', '.']); // Generic fallback\n    }\n\n    public function visitOctal(OctalNode $node): string\n    {\n        if (preg_match('/^\\\\\\\\o\\{([0-7]+)\\}$/', $node->code, $m)) {\n            return mb_chr((int) octdec($m[1]), 'UTF-8');\n        }\n\n        return '?';\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): string\n    {\n        return mb_chr((int) octdec($node->code), 'UTF-8');\n    }\n\n    public function visitPosixClass(PosixClassNode $node): string\n    {\n        return match (strtolower($node->class)) {\n            'alpha' => $this->getRandomChar(['a', 'b', 'C', 'Z']),\n            'alnum' => $this->getRandomChar(['a', 'Z', '1', '9']),\n            'digit' => $this->getRandomChar(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']),\n            'xdigit' => $this->getRandomChar(['0', '9', 'a', 'f', 'A', 'F']),\n            'space' => $this->getRandomChar([' ', \"\\t\", \"\\n\"]),\n            'lower' => $this->getRandomChar(['a', 'b', 'c', 'z']),\n            'upper' => $this->getRandomChar(['A', 'B', 'C', 'Z']),\n            'punct' => $this->getRandomChar(['.', '!', ',', '?']),\n            'word' => $this->getRandomChar(['a', 'Z', '0', '9', '_']),\n            'blank' => $this->getRandomChar([' ', \"\\t\"]),\n            'cntrl' => \"\\x00\", // Control character\n            'graph', 'print' => $this->getRandomChar(['!', '@', '#']),\n            default => $this->getRandomChar(['a', '1', ' ']),\n        };\n    }\n\n    public function visitComment(CommentNode $node): string\n    {\n        // Comments do not generate text\n        return '';\n    }\n\n    public function visitConditional(ConditionalNode $node): string\n    {\n        // This is complex. Does the condition (e.g., group 1) exist?\n        // We'll randomly choose to satisfy the condition or not.\n        try {\n            $choice = mt_rand(0, 1);\n        } catch (\\Throwable) {\n            $choice = 0; // Fallback\n        }\n\n        if (1 === $choice) {\n            // Simulate \"YES\" path\n            return $node->yes->accept($this);\n        }\n\n        // Simulate \"NO\" path\n        return $node->no->accept($this);\n    }\n\n    public function visitSubroutine(SubroutineNode $node): string\n    {\n        // Recursive generation is a deep computer science problem\n        // (can lead to infinite loops). Safest to throw.\n        throw new \\LogicException('Sample generation for subroutines is not supported.');\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): string\n    {\n        // Verbs do not generate text\n        return '';\n    }\n\n    public function visitDefine(DefineNode $node): string\n    {\n        // DEFINE blocks do not generate text, they only define subpatterns\n        return '';\n    }\n\n    /**\n     * @return array{0: int, 1: int} [min, max]\n     */\n    private function parseQuantifierRange(string $q): array\n    {\n        $range = match ($q) {\n            '*' => [0, $this->maxRepetition],\n            '+' => [1, $this->maxRepetition],\n            '?' => [0, 1],\n            default => preg_match('/^\\{(\\d+)(?:,(\\d*))?\\}$/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    [(int) $m[1], (int) $m[1] + $this->maxRepetition] : // {n,}\n                    [(int) $m[1], (int) $m[2]] // {n,m}\n                ) :\n                    [(int) $m[1], (int) $m[1]] // {n}\n                ) :\n                // @codeCoverageIgnoreStart\n                [0, 0], // Fallback\n            // @codeCoverageIgnoreEnd\n        };\n\n        // Ensure min <= max, as Validator may not have run.\n        // This handles invalid cases like {5,2} and silences PHPStan\n        if ($range[1] < $range[0]) {\n            $range[1] = $range[0];\n        }\n\n        return $range;\n    }\n\n    /**\n     * @param array<string> $chars\n     */\n    private function getRandomChar(array $chars): string\n    {\n        if (empty($chars)) {\n            return '?'; // Safe fallback\n        }\n        $key = mt_rand(0, \\count($chars) - 1);\n\n        return $chars[$key];\n    }\n\n    private function generateForCharType(string $type): string\n    {\n        try {\n            return match ($type) {\n                'd' => (string) mt_rand(0, 9),\n                'D' => $this->getRandomChar(['a', ' ', '!']), // Not a digit\n                's' => $this->getRandomChar([' ', \"\\t\", \"\\n\"]),\n                'S' => $this->getRandomChar(['a', '1', '!']), // Not whitespace\n                'w' => $this->getRandomChar(['a', 'Z', '5', '_']),\n                'W' => $this->getRandomChar(['!', ' ', '@']), // Not word\n                'h' => $this->getRandomChar([' ', \"\\t\"]),\n                'H' => $this->getRandomChar(['a', '1', \"\\n\"]), // Not horiz space\n                'v' => \"\\n\", // vertical space\n                'V' => $this->getRandomChar(['a', '1', ' ']), // Not vert space\n                'R' => $this->getRandomChar([\"\\r\\n\", \"\\r\", \"\\n\"]),\n                default => '?',\n            };\n            // @codeCoverageIgnoreStart\n        } catch (\\Throwable) {\n            return '?'; // Fallback for mt_rand failure\n        }\n        // @codeCoverageIgnoreEnd\n    }\n}\n",
    "NodeVisitor/ValidatorNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * Validates the semantic rules of a parsed regex Abstract Syntax Tree (AST).\n *\n * This visitor traverses the AST and checks for logical errors that are not\n * simple syntax errors, such as:\n * - Catastrophic backtracking (ReDoS) from nested quantifiers.\n * - Invalid quantifier ranges (e.g., {5,2}).\n * - Variable-length quantifiers inside lookbehinds.\n * - References to non-existent capturing groups (backreferences/subroutines).\n * - Duplicate capturing group names.\n * - Invalid character ranges (e.g., [z-a]).\n * - Invalid Unicode properties or POSIX classes.\n *\n * @implements NodeVisitorInterface<void>\n */\nfinal class ValidatorNodeVisitor implements NodeVisitorInterface\n{\n    private const array VALID_ASSERTIONS = [\n        'A' => true, 'z' => true, 'Z' => true,\n        'G' => true, 'b' => true, 'B' => true,\n    ];\n\n    private const array VALID_PCRE_VERBS = [\n        'FAIL' => true, 'ACCEPT' => true, 'COMMIT' => true,\n        'PRUNE' => true, 'SKIP' => true, 'THEN' => true,\n        'DEFINE' => true, 'MARK' => true,\n        'UTF8' => true, 'UTF' => true, 'UCP' => true,\n        'CR' => true, 'LF' => true, 'CRLF' => true,\n        'BSR_ANYCRLF' => true, 'BSR_UNICODE' => true,\n        'NO_AUTO_POSSESS' => true,\n        'script_run' => true, 'atomic_script_run' => true,\n    ];\n\n    private const array VALID_POSIX_CLASSES = [\n        'alnum' => true, 'alpha' => true, 'ascii' => true,\n        'blank' => true, 'cntrl' => true, 'digit' => true,\n        'graph' => true, 'lower' => true, 'print' => true,\n        'punct' => true, 'space' => true, 'upper' => true,\n        'word' => true, 'xdigit' => true,\n    ];\n\n    /**\n     * Tracks the depth of nested unbounded quantifiers to detect ReDoS.\n     */\n    private int $quantifierDepth = 0;\n\n    /**\n     * Tracks if the visitor is currently inside a lookbehind.\n     */\n    private bool $inLookbehind = false;\n\n    /**\n     * Tracks the highest *defined* capturing group number.\n     */\n    private int $groupCount = 0;\n\n    /**\n     * Tracks all *defined* named groups to check for duplicates.\n     *\n     * @var array<string, true>\n     */\n    private array $namedGroups = [];\n\n    /**\n     * Caches the validation result for Unicode properties.\n     *\n     * @var array<string, bool>\n     */\n    private static array $unicodePropCache = [];\n\n    /**\n     * @throws ParserException\n     */\n    public function visitRegex(RegexNode $node): void\n    {\n        // Reset state for this validation run. This ensures the visitor\n        // instance is clean, even if it's reused (though cloning is safer).\n        $this->quantifierDepth = 0;\n        $this->inLookbehind = false;\n        $this->groupCount = 0;\n        $this->namedGroups = [];\n\n        // Note: The Parser is responsible for validating the flags themselves\n        // (e.g., no unknown flags). This visitor only cares about *how* flags\n        // (like 'u') might affect semantic validation.\n\n        $node->pattern->accept($this);\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitAlternation(AlternationNode $node): void\n    {\n        // Note: PHP 7.3+ (PCRE2) supports variable-length lookbehinds,\n        // so we no longer enforce fixed-length or same-length alternation restrictions.\n\n        foreach ($node->alternatives as $alt) {\n            $alt->accept($this);\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitSequence(SequenceNode $node): void\n    {\n        foreach ($node->children as $child) {\n            $child->accept($this);\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitGroup(GroupNode $node): void\n    {\n        $wasInLookbehind = $this->inLookbehind;\n\n        if (\\in_array(\n            $node->type,\n            [GroupType::T_GROUP_LOOKBEHIND_POSITIVE, GroupType::T_GROUP_LOOKBEHIND_NEGATIVE],\n            true,\n        )) {\n            $this->inLookbehind = true;\n        }\n\n        // Track defined capturing groups\n        if (GroupType::T_GROUP_CAPTURING === $node->type) {\n            $this->groupCount++;\n        } elseif (GroupType::T_GROUP_NAMED === $node->type) {\n            $this->groupCount++;\n            if (null !== $node->name) {\n                if (isset($this->namedGroups[$node->name])) {\n                    throw new ParserException(\\sprintf('Duplicate group name \"%s\" at position %d.', $node->name, $node->startPos));\n                }\n                $this->namedGroups[$node->name] = true;\n            }\n        }\n\n        $node->child->accept($this);\n\n        $this->inLookbehind = $wasInLookbehind; // Restore state\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitQuantifier(QuantifierNode $node): void\n    {\n        // 1. Validate quantifier range (e.g., {5,2})\n        [$min, $max] = $this->parseQuantifierBounds($node->quantifier);\n        if (-1 !== $max && $min > $max) {\n            throw new ParserException(\\sprintf('Invalid quantifier range \"%s\": min > max at position %d.', $node->quantifier, $node->startPos));\n        }\n\n        $isUnbounded = -1 === $max; // *, +, or {n,}\n\n        // Possessive quantifiers (*+, ++, ?+, {n,}+) cannot backtrack,\n        // so they are safe from catastrophic backtracking (ReDoS).\n        $isPossessive = QuantifierType::T_POSSESSIVE === $node->type;\n\n        // Note: PHP 7.3+ (PCRE2) supports variable-length lookbehinds,\n        // so we no longer enforce fixed-length restrictions here.\n\n        // 2. Check for Catastrophic Backtracking (ReDoS)\n        // Only non-possessive unbounded quantifiers can cause ReDoS.\n        if ($isUnbounded && !$isPossessive) {\n            if ($this->quantifierDepth > 0) {\n                throw new ParserException(\\sprintf('Potential catastrophic backtracking (ReDoS): nested unbounded quantifier \"%s\" at position %d.', $node->quantifier, $node->startPos));\n            }\n            $this->quantifierDepth++;\n        }\n\n        $node->node->accept($this);\n\n        if ($isUnbounded && !$isPossessive) {\n            $this->quantifierDepth--;\n        }\n    }\n\n    public function visitLiteral(LiteralNode $node): void\n    {\n        // No semantic validation needed for literals\n    }\n\n    public function visitCharType(CharTypeNode $node): void\n    {\n        // No semantic validation needed for char types\n    }\n\n    public function visitDot(DotNode $node): void\n    {\n        // No semantic validation needed for dot\n    }\n\n    public function visitAnchor(AnchorNode $node): void\n    {\n        // No semantic validation needed for anchors\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitAssertion(AssertionNode $node): void\n    {\n        if (!isset(self::VALID_ASSERTIONS[$node->value])) {\n            // This should be caught by the Lexer/Parser, but validates as a safeguard.\n            throw new ParserException(\\sprintf('Invalid assertion: \\%s at position %d.', $node->value, $node->startPos));\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitKeep(KeepNode $node): void\n    {\n        if ($this->inLookbehind) {\n            throw new ParserException('\\K (keep) is not allowed in lookbehinds at position %d.', $node->startPos);\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitCharClass(CharClassNode $node): void\n    {\n        foreach ($node->parts as $part) {\n            $part->accept($this);\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitRange(RangeNode $node): void\n    {\n        // 1. Validation: Ensure start and end nodes represent a single character.\n        // We allow LiteralNode, but also UnicodeNode, OctalNode, etc.\n        if (!$this->isSingleCharNode($node->start) || !$this->isSingleCharNode($node->end)) {\n            throw new ParserException(\\sprintf(\n                'Invalid range at position %d: ranges must be between literal characters or single escape sequences. Found %s and %s.',\n                $node->startPos,\n                $node->start::class,\n                $node->end::class,\n            ));\n        }\n\n        // 2. Validation: Ensure characters are single-byte or single codepoint (for LiteralNodes).\n        if ($node->start instanceof LiteralNode && mb_strlen($node->start->value) > 1) {\n            throw new ParserException(\\sprintf('Invalid range at position %d: start char must be a single character.', $node->startPos));\n        }\n        if ($node->end instanceof LiteralNode && mb_strlen($node->end->value) > 1) {\n            throw new ParserException(\\sprintf('Invalid range at position %d: end char must be a single character.', $node->startPos));\n        }\n\n        // 3. Validation: ASCII/Unicode order check.\n        // Note: We only strictly compare two LiteralNodes here to avoid complex cross-type decoding logic.\n        if ($node->start instanceof LiteralNode && $node->end instanceof LiteralNode) {\n            if (mb_ord($node->start->value) > mb_ord($node->end->value)) {\n                throw new ParserException(\\sprintf(\n                    'Invalid range \"%s-%s\" at position %d: start character comes after end character.',\n                    $node->start->value,\n                    $node->end->value,\n                    $node->startPos,\n                ));\n            }\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitBackref(BackrefNode $node): void\n    {\n        $ref = $node->ref;\n\n        if (ctype_digit($ref)) {\n            // Numeric backref: \\1, \\2, etc.\n            $num = (int) $ref;\n            if (0 === $num) {\n                throw new ParserException('Backreference \\0 is not valid');\n            }\n            if ($num > $this->groupCount) {\n                throw new ParserException(\\sprintf('Backreference to non-existent group: \\%d at position %d.', $num, $node->startPos));\n            }\n\n            return;\n        }\n\n        // Named backref: \\k<name> or \\k'name' or \\k{name}\n        if (preg_match('/^\\\\\\\\k[<{\\'](?<name>\\w+)[>}\\']$/', $ref, $matches)) {\n            $name = $matches['name'];\n            if (!isset($this->namedGroups[$name])) {\n                throw new ParserException(\\sprintf('Backreference to non-existent named group: \"%s\"', $name));\n            }\n\n            return;\n        }\n\n        // Bare name (used in conditionals like (?(name)...))\n        if (preg_match('/^\\w+$/', $ref)) {\n            if (!isset($this->namedGroups[$ref])) {\n                throw new ParserException(\\sprintf('Backreference to non-existent named group: \"%s\"', $ref));\n            }\n\n            return;\n        }\n\n        // \\g backref: \\g{N}, \\gN, \\g{-N}\n        if (preg_match('/^\\\\\\\\g\\{?(?<num>[0-9+-]+)\\}?$/', $ref, $matches)) {\n            $numStr = $matches['num'];\n            if ('0' === $numStr || '+0' === $numStr || '-0' === $numStr) {\n                return; // \\g{0} is a valid reference to the entire pattern.\n            }\n\n            $num = (int) $numStr;\n            if ($num > 0 && $num > $this->groupCount) {\n                throw new ParserException(\\sprintf('Backreference to non-existent group: \\g{%d} at position %d.', $num, $node->startPos));\n            }\n            if ($num < 0 && abs($num) > $this->groupCount) {\n                throw new ParserException(\\sprintf('Relative backreference \\g{%d} at position %d exceeds total group count (%d).', $num, $node->startPos, $this->groupCount));\n            }\n\n            return;\n        }\n\n        // Note: \\g<name> is a subroutine, handled by visitSubroutine, not a backref\n        throw new ParserException(\\sprintf('Invalid backreference syntax: \"%s\" at position %d.', $ref, $node->startPos));\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitUnicode(UnicodeNode $node): void\n    {\n        // The Lexer/Parser combination already ensures these are\n        // syntactically valid hex/octal. We validate the *value*.\n        $code = -1;\n        if (preg_match('/^\\\\\\\\x([0-9a-fA-F]{2})$/', $node->code, $m)) {\n            $code = (int) hexdec($m[1]);\n        } elseif (preg_match('/^\\\\\\\\u\\{([0-9a-fA-F]+)\\}$/', $node->code, $m)) {\n            $code = (int) hexdec($m[1]);\n        }\n\n        if ($code > 0x10FFFF) {\n            throw new ParserException(\\sprintf('Invalid Unicode codepoint \"%s\" (out of range) at position %d.', $node->code, $node->startPos));\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitUnicodeProp(UnicodePropNode $node): void\n    {\n        // The only 100% \"prod-ready\" way to validate a Unicode property\n        // is to check it against the PCRE engine being used.\n        $prop = $node->prop;\n        $key = (mb_strlen($prop) > 1 || str_starts_with($prop, '^')) ? \"p{{$prop}}\" : \"p{$prop}\";\n\n        if (!isset(self::$unicodePropCache[$key])) {\n            // We use error suppression as preg_match will warn on an invalid property.\n            // We check the *return value* and preg_last_error() to confirm validity.\n            // The 'u' flag is essential.\n            $result = @preg_match(\"/^\\\\{$key}$/u\", '');\n            $error = preg_last_error();\n\n            // PREG_NO_ERROR means it compiled successfully.\n            self::$unicodePropCache[$key] = false !== $result && \\PREG_NO_ERROR === $error;\n        }\n\n        if (false === self::$unicodePropCache[$key]) {\n            throw new ParserException(\\sprintf('Invalid or unsupported Unicode property: \\%s at position %d.', $key, $node->startPos));\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitOctal(OctalNode $node): void\n    {\n        // \\o{...}\n        if (preg_match('/^\\\\\\\\o\\{([0-9]+)\\}$/', $node->code, $m)) {\n            $octalStr = $m[1];\n\n            // Check if all digits are valid octal (0-7)\n            if (!preg_match('/^[0-7]+$/', $octalStr)) {\n                throw new ParserException(\\sprintf('Invalid octal codepoint \"%s\" at position %d.', $node->code, $node->startPos));\n            }\n\n            // PCRE limits \\o{} to single-byte values (0-255)\n            $code = (int) octdec($octalStr);\n            if ($code > 0xFF) {\n                throw new ParserException(\\sprintf('Invalid octal codepoint \"%s\" at position %d.', $node->code, $node->startPos));\n            }\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitOctalLegacy(OctalLegacyNode $node): void\n    {\n        // \\0 is treated as an invalid backreference\n        if ('0' === $node->code) {\n            throw new ParserException('Backreference \\0 is not valid');\n        }\n\n        // \\0...\n        $code = (int) octdec($node->code);\n        if ($code > 0x10FFFF) {\n            // This is unlikely as \\077 is max, but good to check.\n            throw new ParserException(\\sprintf('Invalid legacy octal codepoint \"\\%s\" (out of range) at position %d.', $node->code, $node->startPos));\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitPosixClass(PosixClassNode $node): void\n    {\n        $class = strtolower($node->class);\n        $isNegated = false;\n\n        if (str_starts_with($class, '^')) {\n            $class = substr($class, 1);\n            $isNegated = true;\n        }\n\n        if (!isset(self::VALID_POSIX_CLASSES[$class])) {\n            throw new ParserException(\\sprintf('Invalid POSIX class: \"%s\" at position %d.', $node->class, $node->startPos));\n        }\n\n        if ($isNegated && 'word' === $class) {\n            // [[:^word:]] is not a valid construct.\n            throw new ParserException(\\sprintf('Negation of POSIX class \"word\" is not supported at position %d.', $node->startPos));\n        }\n    }\n\n    public function visitComment(CommentNode $node): void\n    {\n        // Comments are ignored in validation\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitConditional(ConditionalNode $node): void\n    {\n        // Check if the condition is a valid *type* of condition first\n        // (e.g., a backreference, a subroutine call, or a lookaround)\n        if ($node->condition instanceof BackrefNode) {\n            // This is (?(1)...) or (?(<name>)...) or (?(name)...)\n            // For bare names, check if the group exists before calling accept\n            $ref = $node->condition->ref;\n            if (preg_match('/^\\w+$/', $ref) && !isset($this->namedGroups[$ref])) {\n                // Bare name that doesn't exist - this is an invalid conditional\n                throw new ParserException(\\sprintf('Invalid conditional construct at position %d. Condition must be a group reference, lookaround, or (DEFINE).', $node->condition->getStartPosition()));\n            }\n            // Now validate the backreference itself\n            $node->condition->accept($this);\n        } elseif ($node->condition instanceof SubroutineNode) {\n            // This is (?(R)...) or (?(R1)...)\n            $node->condition->accept($this);\n        } elseif ($node->condition instanceof GroupNode && \\in_array($node->condition->type, [\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE,\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE,\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE,\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE,\n        ], true)) {\n            // This is (?(?=...)...) etc. This is valid.\n            $node->condition->accept($this);\n        } elseif ($node->condition instanceof AssertionNode && 'DEFINE' === $node->condition->value) {\n            // (?(DEFINE)...) This is valid.\n            $node->condition->accept($this);\n        } else {\n            // Any other atom is not a valid condition\n            throw new ParserException(\\sprintf('Invalid conditional construct at position %d. Condition must be a group reference, lookaround, or (DEFINE).', $node->condition->getStartPosition()));\n        }\n\n        $node->yes->accept($this);\n        $node->no->accept($this);\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitSubroutine(SubroutineNode $node): void\n    {\n        $ref = $node->reference;\n\n        if ('R' === $ref || '0' === $ref) {\n            return; // (?R) or (?0) is always valid.\n        }\n\n        // Numeric reference: (?1), (?-1)\n        if (ctype_digit($ref) || (str_starts_with($ref, '-') && ctype_digit(substr($ref, 1)))) {\n            $num = (int) $ref;\n            if (0 === $num) {\n                return; // (?0) is an alias for (?R)\n            }\n            if ($num > 0 && $num > $this->groupCount) {\n                throw new ParserException(\\sprintf('Subroutine call to non-existent group: %d at position %d.', $num, $node->startPos));\n            }\n            if ($num < 0 && abs($num) > $this->groupCount) {\n                throw new ParserException(\\sprintf('Relative subroutine call (%d) at position %d exceeds total group count (%d).', $num, $node->startPos, $this->groupCount));\n            }\n\n            return;\n        }\n\n        // Named reference: (?&name), (?P>name), \\g<name>\n        if (!isset($this->namedGroups[$ref])) {\n            throw new ParserException(\\sprintf('Subroutine call to non-existent named group: \"%s\" at position %d.', $ref, $node->startPos));\n        }\n    }\n\n    /**\n     * @throws ParserException\n     */\n    public function visitPcreVerb(PcreVerbNode $node): void\n    {\n        $verbName = explode(':', $node->verb, 2)[0];\n\n        if (!isset(self::VALID_PCRE_VERBS[$verbName])) {\n            throw new ParserException(\\sprintf('Invalid or unsupported PCRE verb: \"%s\" at position %d.', $verbName, $node->startPos));\n        }\n    }\n\n    public function visitDefine(DefineNode $node): void\n    {\n        $node->content->accept($this);\n    }\n\n    /**\n     * Helper to check if a node represents a valid single character for a range.\n     */\n    private function isSingleCharNode(NodeInterface $node): bool\n    {\n        return $node instanceof LiteralNode\n            || $node instanceof UnicodeNode\n            || $node instanceof OctalNode\n            || $node instanceof OctalLegacyNode;\n        // CharTypeNode (e.g., \\d) is technically invalid in a standard PCRE range start/end,\n        // but we exclude it here to remain spec-compliant unless lenient mode is desired.\n    }\n\n    /**\n     * Parses a quantifier string (e.g., \"{2,5}\") into min/max bounds.\n     *\n     * @return array{0: int, 1: int} [min, max] where max = -1 means unbounded\n     */\n    private function parseQuantifierBounds(string $q): array\n    {\n        return match ($q) {\n            '*' => [0, -1],\n            '+' => [1, -1],\n            '?' => [0, 1],\n            default => preg_match('/^\\{(\\d+)(?:,(\\d*))?\\}$/', $q, $m) ?\n                (isset($m[2]) ?\n                    ('' === $m[2] ? [(int) $m[1], -1] : [(int) $m[1], (int) $m[2]]) : // {n,} or {n,m}\n                    [(int) $m[1], (int) $m[1]] // {n}\n                ) :\n                [1, 1], // Should be impossible if Lexer is correct\n        };\n    }\n\n    /**\n     * Calculates the fixed length of a node.\n     * Returns the length if fixed, null if variable.\n     */\n    private function calculateFixedLength(NodeInterface $node): ?int\n    {\n        return match (true) {\n            $node instanceof LiteralNode => mb_strlen($node->value),\n            $node instanceof CharTypeNode, $node instanceof DotNode => 1,\n            $node instanceof AnchorNode, $node instanceof AssertionNode => 0,\n            $node instanceof SequenceNode => $this->calculateSequenceLength($node),\n            $node instanceof GroupNode => $this->calculateFixedLength($node->child),\n            $node instanceof QuantifierNode => $this->calculateQuantifierLength($node),\n            $node instanceof CharClassNode => 1,\n            $node instanceof AlternationNode => null, // Handled separately\n            default => null, // Unknown or variable\n        };\n    }\n\n    private function calculateSequenceLength(SequenceNode $node): ?int\n    {\n        $total = 0;\n        foreach ($node->children as $child) {\n            $length = $this->calculateFixedLength($child);\n            if (null === $length) {\n                return null; // Variable length\n            }\n            $total += $length;\n        }\n\n        return $total;\n    }\n\n    private function calculateQuantifierLength(QuantifierNode $node): ?int\n    {\n        [$min, $max] = $this->parseQuantifierBounds($node->quantifier);\n\n        // Only fixed if min == max (and both are not -1)\n        if ($min !== $max || -1 === $max) {\n            return null; // Variable length\n        }\n\n        $childLength = $this->calculateFixedLength($node->node);\n        if (null === $childLength) {\n            return null;\n        }\n\n        return $min * $childLength;\n    }\n}\n",
    "NodeVisitor/ArrayExplorerVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * Transforms the AST into a structured array tree suitable for UI visualization.\n *\n * This visitor acts as a Serializer, converting the Domain Model (AST)\n * into a View Model (Array) for the frontend.\n *\n * @implements NodeVisitorInterface<array<string, mixed>>\n */\nfinal class ArrayExplorerVisitor implements NodeVisitorInterface\n{\n    public function visitRegex(RegexNode $node): array\n    {\n        return [\n            'type' => 'Regex',\n            'label' => 'Pattern',\n            'detail' => $node->flags ? \"Flags: {$node->flags}\" : 'Global',\n            'icon' => 'fa-solid fa-globe',\n            'color' => 'text-indigo-600',\n            'bg' => 'bg-indigo-50',\n            'children' => [$node->pattern->accept($this)],\n        ];\n    }\n\n    public function visitGroup(GroupNode $node): array\n    {\n        [$label, $icon, $color, $bg] = match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => ['Capturing Group', 'fa-solid fa-brackets-round', 'text-green-600', 'bg-green-50'],\n            GroupType::T_GROUP_NAMED => [\"Named Group: <span class='font-mono'>{$node->name}</span>\", 'fa-solid fa-tag', 'text-emerald-600', 'bg-emerald-50'],\n            GroupType::T_GROUP_NON_CAPTURING => ['Non-Capturing Group', 'fa-solid fa-ban', 'text-slate-500', 'bg-slate-50'],\n            GroupType::T_GROUP_ATOMIC => ['Atomic Group (?>...)', 'fa-solid fa-lock', 'text-red-500', 'bg-red-50'],\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => ['Positive Lookahead (?=...)', 'fa-solid fa-eye', 'text-blue-600', 'bg-blue-50'],\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => ['Negative Lookahead (?!...)', 'fa-solid fa-eye-slash', 'text-red-600', 'bg-red-50'],\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => ['Positive Lookbehind (?<=...)', 'fa-solid fa-chevron-left', 'text-blue-600', 'bg-blue-50'],\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => ['Negative Lookbehind (?<!...)', 'fa-solid fa-chevron-left', 'text-red-600', 'bg-red-50'],\n            default => [ucfirst(str_replace('_', ' ', $node->type->value)), 'fa-solid fa-layer-group', 'text-blue-500', 'bg-blue-50'],\n        };\n\n        return [\n            'type' => 'Group',\n            'label' => $label,\n            'icon' => $icon,\n            'color' => $color,\n            'bg' => $bg,\n            'children' => [$node->child->accept($this)],\n        ];\n    }\n\n    public function visitQuantifier(QuantifierNode $node): array\n    {\n        return [\n            'type' => 'Quantifier',\n            'label' => 'Quantifier',\n            'detail' => \"{$node->quantifier} (\" . ucfirst($node->type->value) . ')',\n            'icon' => 'fa-solid fa-rotate-right',\n            'color' => 'text-orange-600',\n            'bg' => 'bg-orange-50',\n            'children' => [$node->node->accept($this)],\n        ];\n    }\n\n    public function visitSequence(SequenceNode $node): array\n    {\n        return [\n            'type' => 'Sequence',\n            'label' => 'Sequence',\n            'icon' => 'fa-solid fa-arrow-right-long',\n            'color' => 'text-slate-400',\n            'children' => array_map(fn ($child) => $child->accept($this), $node->children),\n        ];\n    }\n\n    public function visitAlternation(AlternationNode $node): array\n    {\n        return [\n            'type' => 'Alternation',\n            'label' => 'Alternation (OR)',\n            'icon' => 'fa-solid fa-code-branch',\n            'color' => 'text-purple-600',\n            'bg' => 'bg-purple-50',\n            'children' => array_map(fn ($child) => $child->accept($this), $node->alternatives),\n        ];\n    }\n\n    public function visitLiteral(LiteralNode $node): array\n    {\n        return [\n            'type' => 'Literal',\n            'label' => 'Literal',\n            'detail' => $this->formatValue($node->value),\n            'icon' => 'fa-solid fa-font',\n            'color' => 'text-slate-700',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitCharClass(CharClassNode $node): array\n    {\n        $label = $node->isNegated ? 'Negative Character Set [^...]' : 'Character Set [...]';\n\n        return [\n            'type' => 'CharClass',\n            'label' => $label,\n            'icon' => 'fa-solid fa-border-all',\n            'color' => $node->isNegated ? 'text-red-600' : 'text-teal-600',\n            'bg' => $node->isNegated ? 'bg-red-50' : 'bg-teal-50',\n            'children' => array_map(fn ($child) => $child->accept($this), $node->parts),\n        ];\n    }\n\n    public function visitRange(RangeNode $node): array\n    {\n        return [\n            'type' => 'Range',\n            'label' => 'Range',\n            'icon' => 'fa-solid fa-arrows-left-right',\n            'color' => 'text-teal-600',\n            'children' => [\n                $node->start->accept($this),\n                $node->end->accept($this),\n            ],\n        ];\n    }\n\n    public function visitCharType(CharTypeNode $node): array\n    {\n        $map = [\n            'd' => 'Digit (0-9)', 'D' => 'Not Digit',\n            'w' => 'Word Char', 'W' => 'Not Word Char',\n            's' => 'Whitespace', 'S' => 'Not Whitespace',\n        ];\n\n        return [\n            'type' => 'CharType',\n            'label' => 'Character Type',\n            'detail' => '\\\\' . $node->value . ' (' . ($map[$node->value] ?? 'Custom') . ')',\n            'icon' => 'fa-solid fa-filter',\n            'color' => 'text-blue-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitDot(DotNode $node): array\n    {\n        return [\n            'type' => 'Dot',\n            'label' => 'Wildcard (Dot)',\n            'detail' => 'Any character',\n            'icon' => 'fa-solid fa-circle',\n            'color' => 'text-pink-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitAnchor(AnchorNode $node): array\n    {\n        $map = ['^' => 'Start of Line', '$' => 'End of Line', '\\A' => 'Start of String', '\\z' => 'End of String'];\n\n        return [\n            'type' => 'Anchor',\n            'label' => 'Anchor',\n            'detail' => $node->value . ' (' . ($map[$node->value] ?? 'Custom') . ')',\n            'icon' => 'fa-solid fa-anchor',\n            'color' => 'text-rose-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitAssertion(AssertionNode $node): array\n    {\n        return [\n            'type' => 'Assertion',\n            'label' => 'Assertion',\n            'detail' => '\\\\' . $node->value,\n            'icon' => 'fa-solid fa-check-double',\n            'color' => 'text-amber-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitBackref(BackrefNode $node): array\n    {\n        return [\n            'type' => 'Backref',\n            'label' => 'Backreference',\n            'detail' => 'To group: ' . $node->ref,\n            'icon' => 'fa-solid fa-clock-rotate-left',\n            'color' => 'text-cyan-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitUnicode(UnicodeNode $node): array\n    {\n        return [\n            'type' => 'Unicode',\n            'label' => 'Unicode Character',\n            'detail' => $node->code,\n            'icon' => 'fa-solid fa-language',\n            'color' => 'text-violet-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): array\n    {\n        return [\n            'type' => 'UnicodeProp',\n            'label' => 'Unicode Property',\n            'detail' => '\\p{' . $node->prop . '}',\n            'icon' => 'fa-solid fa-globe-europe',\n            'color' => 'text-violet-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitOctal(OctalNode $node): array\n    {\n        return $this->genericLeaf('Octal', $node->code);\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): array\n    {\n        return $this->genericLeaf('Legacy Octal', $node->code);\n    }\n\n    public function visitPosixClass(PosixClassNode $node): array\n    {\n        return [\n            'type' => 'PosixClass',\n            'label' => 'POSIX Class',\n            'detail' => '[:' . $node->class . ':]',\n            'icon' => 'fa-solid fa-box-archive',\n            'color' => 'text-slate-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitComment(CommentNode $node): array\n    {\n        return [\n            'type' => 'Comment',\n            'label' => 'Comment',\n            'detail' => $node->comment,\n            'icon' => 'fa-solid fa-comment-slash',\n            'color' => 'text-gray-400',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitConditional(ConditionalNode $node): array\n    {\n        return [\n            'type' => 'Conditional',\n            'label' => 'Conditional (If-Then-Else)',\n            'icon' => 'fa-solid fa-code-fork',\n            'color' => 'text-fuchsia-600',\n            'bg' => 'bg-fuchsia-50',\n            'children' => [\n                ['label' => 'Condition', 'children' => [$node->condition->accept($this)]],\n                ['label' => 'If True', 'children' => [$node->yes->accept($this)]],\n                ['label' => 'If False', 'children' => [$node->no->accept($this)]],\n            ],\n        ];\n    }\n\n    public function visitSubroutine(SubroutineNode $node): array\n    {\n        return [\n            'type' => 'Subroutine',\n            'label' => 'Subroutine',\n            'detail' => 'Call: ' . $node->reference,\n            'icon' => 'fa-solid fa-recycle',\n            'color' => 'text-cyan-600',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): array\n    {\n        return [\n            'type' => 'PcreVerb',\n            'label' => 'Control Verb',\n            'detail' => '(*' . $node->verb . ')',\n            'icon' => 'fa-solid fa-gamepad',\n            'color' => 'text-pink-500',\n            'isLeaf' => true,\n        ];\n    }\n\n    public function visitDefine(DefineNode $node): array\n    {\n        return [\n            'type' => 'Define',\n            'label' => '(DEFINE) Block',\n            'icon' => 'fa-solid fa-book',\n            'color' => 'text-slate-500',\n            'children' => [$node->content->accept($this)],\n        ];\n    }\n\n    public function visitKeep(KeepNode $node): array\n    {\n        return [\n            'type' => 'Keep',\n            'label' => 'Keep (\\K)',\n            'detail' => 'Reset match start',\n            'icon' => 'fa-solid fa-scissors',\n            'color' => 'text-orange-500',\n            'isLeaf' => true,\n        ];\n    }\n\n    private function genericLeaf(string $label, string $detail): array\n    {\n        return [\n            'type' => 'Generic',\n            'label' => $label,\n            'detail' => $detail,\n            'icon' => 'fa-solid fa-cube',\n            'color' => 'text-gray-500',\n            'isLeaf' => true,\n        ];\n    }\n\n    private function formatValue(string $value): string\n    {\n        $map = [\"\\n\" => '\\n', \"\\r\" => '\\r', \"\\t\" => '\\t'];\n        return '\"' . strtr($value, $map) . '\"';\n    }\n}\n",
    "NodeVisitor/ReDoSProfileVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\nuse RegexParser\\ReDoSSeverity;\n\n/**\n * Analyzes the AST to detect ReDoS vulnerabilities.\n * Returns the maximum detected severity level for the visited node tree.\n *\n * @implements NodeVisitorInterface<ReDoSSeverity>\n */\nfinal class ReDoSProfileVisitor implements NodeVisitorInterface\n{\n    private int $unboundedQuantifierDepth = 0;\n\n    /**\n     * Tracks total nesting of quantifiers (bounded or not) to detect LOW risks.\n     */\n    private int $totalQuantifierDepth = 0;\n\n    /**\n     * @var array<array{severity: ReDoSSeverity, message: string, pattern: string}>\n     */\n    private array $vulnerabilities = [];\n\n    private bool $inAtomicGroup = false;\n\n    /**\n     * @return array{severity: ReDoSSeverity, recommendations: array<string>, vulnerablePattern: ?string}\n     */\n    public function getResult(): array\n    {\n        $maxSeverity = ReDoSSeverity::SAFE;\n        $recommendations = [];\n        $pattern = null;\n\n        foreach ($this->vulnerabilities as $vuln) {\n            if ($this->severityGreaterThan($vuln['severity'], $maxSeverity)) {\n                $maxSeverity = $vuln['severity'];\n                $pattern = $vuln['pattern'];\n            }\n            $recommendations[] = $vuln['message'];\n        }\n\n        return [\n            'severity' => $maxSeverity,\n            'recommendations' => array_unique($recommendations),\n            'vulnerablePattern' => $pattern,\n        ];\n    }\n\n    public function visitRegex(RegexNode $node): ReDoSSeverity\n    {\n        $this->unboundedQuantifierDepth = 0;\n        $this->totalQuantifierDepth = 0;\n        $this->vulnerabilities = [];\n        $this->inAtomicGroup = false;\n\n        return $node->pattern->accept($this);\n    }\n\n    public function visitQuantifier(QuantifierNode $node): ReDoSSeverity\n    {\n        // Save the current atomic state to restore it later\n        $wasAtomic = $this->inAtomicGroup;\n\n        // If the quantifier is possessive (*+, ++), its content is implicitly atomic.\n        // This means it does not backtrack, preventing ReDoS in nested structures.\n        if (QuantifierType::T_POSSESSIVE === $node->type) {\n            $this->inAtomicGroup = true;\n        }\n\n        // If we are inside an atomic group (explicit or via possessive quantifier),\n        // we visit the child without ReDoS checks (as backtracking is disabled),\n        // then restore the state and return immediately.\n        if ($this->inAtomicGroup) {\n            $result = $node->node->accept($this);\n            $this->inAtomicGroup = $wasAtomic; // Restore state is crucial here!\n\n            return $result;\n        }\n\n        // --- Standard ReDoS logic for non-atomic quantifiers ---\n\n        $this->totalQuantifierDepth++;\n        $isUnbounded = $this->isUnbounded($node->quantifier);\n\n        // Check if the immediate target is an atomic group (e.g., (? >...)+)\n        $isTargetAtomic = $node->node instanceof GroupNode && GroupType::T_GROUP_ATOMIC === $node->node->type;\n\n        $severity = ReDoSSeverity::SAFE;\n\n        if ($isUnbounded && !$isTargetAtomic) {\n            $this->unboundedQuantifierDepth++;\n\n            if ($this->unboundedQuantifierDepth > 1) {\n                $severity = ReDoSSeverity::HIGH;\n                $this->addVulnerability(\n                    ReDoSSeverity::HIGH,\n                    'Nested unbounded quantifiers detected. This allows exponential backtracking.',\n                    $node->quantifier,\n                );\n            } else {\n                $severity = ReDoSSeverity::MEDIUM;\n                $this->addVulnerability(\n                    ReDoSSeverity::MEDIUM,\n                    'Unbounded quantifier detected. May cause backtracking on non-matching input.',\n                    $node->quantifier,\n                );\n            }\n        } else {\n            if ($this->isLargeBounded($node->quantifier)) {\n                $severity = ReDoSSeverity::LOW;\n                $this->addVulnerability(\n                    ReDoSSeverity::LOW,\n                    'Large bounded quantifier detected (>1000). May cause slow matching.',\n                    $node->quantifier,\n                );\n            } elseif ($this->totalQuantifierDepth > 1) {\n                $severity = ReDoSSeverity::LOW;\n                $this->addVulnerability(\n                    ReDoSSeverity::LOW,\n                    'Nested bounded quantifiers detected. May cause polynomial backtracking.',\n                    $node->quantifier,\n                );\n            }\n        }\n\n        $childSeverity = $node->node->accept($this);\n\n        if ($isUnbounded && !$isTargetAtomic && ReDoSSeverity::HIGH === $childSeverity) {\n            $severity = ReDoSSeverity::CRITICAL;\n            $this->addVulnerability(\n                ReDoSSeverity::CRITICAL,\n                'Critical nesting of quantifiers detected (Star Height > 1).',\n                $node->quantifier,\n            );\n        }\n\n        if ($isUnbounded && !$isTargetAtomic) {\n            $this->unboundedQuantifierDepth--;\n        }\n        $this->totalQuantifierDepth--;\n\n        // Restore state (just in case, though the early return handles the true case)\n        $this->inAtomicGroup = $wasAtomic;\n\n        return $this->maxSeverity($severity, $childSeverity);\n    }\n\n    public function visitAlternation(AlternationNode $node): ReDoSSeverity\n    {\n        $max = ReDoSSeverity::SAFE;\n\n        if ($this->unboundedQuantifierDepth > 0 && $this->hasOverlappingAlternatives($node)) {\n            $this->addVulnerability(\n                ReDoSSeverity::CRITICAL,\n                'Overlapping alternation branches inside a quantifier. e.g. (a|a)*',\n                '|',\n            );\n            $max = ReDoSSeverity::CRITICAL;\n        }\n\n        foreach ($node->alternatives as $alt) {\n            $max = $this->maxSeverity($max, $alt->accept($this));\n        }\n\n        return $max;\n    }\n\n    public function visitGroup(GroupNode $node): ReDoSSeverity\n    {\n        $wasAtomic = $this->inAtomicGroup;\n\n        if (GroupType::T_GROUP_ATOMIC === $node->type) {\n            $this->inAtomicGroup = true;\n        }\n\n        $severity = $node->child->accept($this);\n\n        $this->inAtomicGroup = $wasAtomic;\n\n        return $severity;\n    }\n\n    public function visitSequence(SequenceNode $node): ReDoSSeverity\n    {\n        $max = ReDoSSeverity::SAFE;\n        foreach ($node->children as $child) {\n            $max = $this->maxSeverity($max, $child->accept($this));\n        }\n\n        return $max;\n    }\n\n    public function visitLiteral(LiteralNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitCharType(CharTypeNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitDot(DotNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitAnchor(AnchorNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitAssertion(AssertionNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitKeep(KeepNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitCharClass(CharClassNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitRange(RangeNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitBackref(BackrefNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitUnicode(UnicodeNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitOctal(OctalNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitPosixClass(PosixClassNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitComment(CommentNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::SAFE;\n    }\n\n    public function visitConditional(ConditionalNode $node): ReDoSSeverity\n    {\n        return $this->maxSeverity(\n            $node->yes->accept($this),\n            $node->no->accept($this),\n        );\n    }\n\n    public function visitSubroutine(SubroutineNode $node): ReDoSSeverity\n    {\n        return ReDoSSeverity::MEDIUM;\n    }\n\n    public function visitDefine(DefineNode $node): ReDoSSeverity\n    {\n        // Analyze the content of the DEFINE block for ReDoS vulnerabilities\n        return $node->content->accept($this);\n    }\n\n    private function isUnbounded(string $quantifier): bool\n    {\n        if (str_contains($quantifier, '*') || str_contains($quantifier, '+')) {\n            return true;\n        }\n\n        if (str_contains($quantifier, ',')) {\n            return !preg_match('/,\\d+\\}$/', $quantifier);\n        }\n\n        return false;\n    }\n\n    private function isLargeBounded(string $quantifier): bool\n    {\n        if (preg_match('/\\{(\\d+)(?:,(\\d+))?\\}/', $quantifier, $m)) {\n            $max = isset($m[2]) ? (int) $m[2] : (int) $m[1];\n\n            return $max > 1000;\n        }\n\n        return false;\n    }\n\n    private function hasOverlappingAlternatives(AlternationNode $node): bool\n    {\n        $prefixes = [];\n        $hasDot = false;\n        $hasCharClass = false;\n\n        foreach ($node->alternatives as $alt) {\n            $prefix = $this->getPrefixSignature($alt);\n\n            if ('DOT' === $prefix) {\n                if ($hasDot || !empty($prefixes) || $hasCharClass) {\n                    return true;\n                }\n                $hasDot = true;\n\n                continue;\n            }\n\n            if ('CLASS' === $prefix) {\n                if ($hasDot || $hasCharClass || !empty($prefixes)) {\n                    return true;\n                }\n                $hasCharClass = true;\n\n                continue;\n            }\n\n            if ($hasDot || $hasCharClass) {\n                return true;\n            }\n\n            if ($prefix && isset($prefixes[$prefix])) {\n                return true;\n            }\n            $prefixes[$prefix] = true;\n        }\n\n        return false;\n    }\n\n    private function getPrefixSignature(NodeInterface $node): string\n    {\n        if ($node instanceof LiteralNode) {\n            return 'L:'.$node->value;\n        }\n        if ($node instanceof CharTypeNode) {\n            return 'T:'.$node->value;\n        }\n        if ($node instanceof DotNode) {\n            return 'DOT';\n        }\n        if ($node instanceof CharClassNode) {\n            return 'CLASS';\n        }\n        if ($node instanceof SequenceNode && !empty($node->children)) {\n            return $this->getPrefixSignature($node->children[0]);\n        }\n        if ($node instanceof GroupNode) {\n            return $this->getPrefixSignature($node->child);\n        }\n\n        return uniqid();\n    }\n\n    private function addVulnerability(ReDoSSeverity $severity, string $message, string $pattern): void\n    {\n        $this->vulnerabilities[] = [\n            'severity' => $severity,\n            'message' => $message,\n            'pattern' => $pattern,\n        ];\n    }\n\n    private function severityGreaterThan(ReDoSSeverity $a, ReDoSSeverity $b): bool\n    {\n        $levels = [\n            ReDoSSeverity::SAFE->value => 0,\n            ReDoSSeverity::LOW->value => 1,\n            ReDoSSeverity::MEDIUM->value => 2,\n            ReDoSSeverity::HIGH->value => 3,\n            ReDoSSeverity::CRITICAL->value => 4,\n        ];\n\n        return $levels[$a->value] > $levels[$b->value];\n    }\n\n    private function maxSeverity(ReDoSSeverity $a, ReDoSSeverity $b): ReDoSSeverity\n    {\n        return $this->severityGreaterThan($a, $b) ? $a : $b;\n    }\n}\n",
    "NodeVisitor/ExplainVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that explains the AST in a human-readable string.\n *\n * @implements NodeVisitorInterface<string>\n */\nclass ExplainVisitor implements NodeVisitorInterface\n{\n    private const array CHAR_TYPE_MAP = [\n        'd' => 'any digit (0-9)',\n        'D' => 'any non-digit',\n        's' => 'any whitespace character',\n        'S' => 'any non-whitespace character',\n        'w' => 'any \"word\" character (alphanumeric or _)',\n        'W' => 'any \"non-word\" character',\n        'h' => 'any horizontal whitespace',\n        'H' => 'any non-horizontal whitespace',\n        'v' => 'any vertical whitespace',\n        'V' => 'any non-vertical whitespace',\n        'R' => 'a generic newline (\\\\r\\\\n, \\\\r, or \\\\n)',\n    ];\n\n    private const array ANCHOR_MAP = [\n        '^' => 'the start of the string (or line, with /m flag)',\n        '$' => 'the end of the string (or line, with /m flag)',\n    ];\n\n    private const array ASSERTION_MAP = [\n        'A' => 'the absolute start of the string',\n        'z' => 'the absolute end of the string',\n        'Z' => 'the end of the string (before final newline)',\n        'G' => 'the position of the last successful match',\n        'b' => 'a word boundary',\n        'B' => 'a non-word boundary',\n    ];\n\n    private int $indentLevel = 0;\n\n    public function visitRegex(RegexNode $node): string\n    {\n        $this->indentLevel = 0;\n        $patternExplain = $node->pattern->accept($this);\n        $flags = $node->flags ? ' (with flags: '.$node->flags.')' : '';\n\n        return \\sprintf(\"Regex matches%s:\\n%s\", $flags, $patternExplain);\n    }\n\n    public function visitAlternation(AlternationNode $node): string\n    {\n        $this->indentLevel++;\n        $alts = array_map(\n            fn (NodeInterface $alt) => $alt->accept($this),\n            $node->alternatives,\n        );\n        $this->indentLevel--;\n\n        $indent = $this->indent();\n\n        return \\sprintf(\n            \"EITHER:\\n%s%s\",\n            $indent,\n            implode(\\sprintf(\"\\n%sOR:\\n%s\", $indent, $indent), $alts),\n        );\n    }\n\n    public function visitSequence(SequenceNode $node): string\n    {\n        $parts = array_map(fn ($child) => $child->accept($this), $node->children);\n\n        // Filter out empty strings (e.g., from empty nodes)\n        $parts = array_filter($parts, fn ($part) => '' !== $part);\n\n        return implode(\\sprintf(\"\\n%s\", $this->indent()), $parts);\n    }\n\n    public function visitGroup(GroupNode $node): string\n    {\n        $this->indentLevel++;\n        $childExplain = $node->child->accept($this);\n        $this->indentLevel--;\n\n        $indent = $this->indent();\n        $type = match ($node->type) {\n            GroupType::T_GROUP_CAPTURING => 'Start Capturing Group',\n            GroupType::T_GROUP_NON_CAPTURING => 'Start Non-Capturing Group',\n            GroupType::T_GROUP_NAMED => \\sprintf(\"Start Capturing Group (named: '%s')\", $node->name),\n            GroupType::T_GROUP_LOOKAHEAD_POSITIVE => 'Start Positive Lookahead',\n            GroupType::T_GROUP_LOOKAHEAD_NEGATIVE => 'Start Negative Lookahead',\n            GroupType::T_GROUP_LOOKBEHIND_POSITIVE => 'Start Positive Lookbehind',\n            GroupType::T_GROUP_LOOKBEHIND_NEGATIVE => 'Start Negative Lookbehind',\n            GroupType::T_GROUP_ATOMIC => 'Start Atomic Group',\n            GroupType::T_GROUP_BRANCH_RESET => 'Start Branch Reset Group',\n            GroupType::T_GROUP_INLINE_FLAGS => \\sprintf(\"Start Group (with flags: '%s')\", $node->flags),\n        };\n\n        return \\sprintf(\"%s:\\n%s%s\\n%sEnd Group\", $type, $indent, $childExplain, $this->indent(false));\n    }\n\n    public function visitQuantifier(QuantifierNode $node): string\n    {\n        $childExplain = $node->node->accept($this);\n        $quantExplain = $this->explainQuantifierValue($node->quantifier, $node->type->value);\n\n        // If the child is simple (one line), put it on one line.\n        if (!str_contains($childExplain, \"\\n\")) {\n            return \\sprintf('%s (%s)', $childExplain, $quantExplain);\n        }\n\n        // If the child is complex, indent it.\n        $this->indentLevel++;\n        $childExplain = $node->node->accept($this);\n        $this->indentLevel--;\n\n        return \\sprintf(\n            \"Start Quantified Group (%s):\\n%s%s\\n%sEnd Quantified Group\",\n            $quantExplain,\n            $this->indent(),\n            $childExplain,\n            $this->indent(false),\n        );\n    }\n\n    public function visitLiteral(LiteralNode $node): string\n    {\n        return 'Literal: '.$this->explainLiteral($node->value);\n    }\n\n    public function visitCharType(CharTypeNode $node): string\n    {\n        return 'Character Type: '.(self::CHAR_TYPE_MAP[$node->value] ?? 'unknown (\\\\'.$node->value.')');\n    }\n\n    public function visitDot(DotNode $node): string\n    {\n        return 'Wildcard: any character (except newline, unless /s flag is used)';\n    }\n\n    public function visitAnchor(AnchorNode $node): string\n    {\n        return 'Anchor: '.(self::ANCHOR_MAP[$node->value] ?? $node->value);\n    }\n\n    public function visitAssertion(AssertionNode $node): string\n    {\n        return 'Assertion: '.(self::ASSERTION_MAP[$node->value] ?? '\\\\'.$node->value);\n    }\n\n    public function visitKeep(KeepNode $node): string\n    {\n        return 'Assertion: \\K (reset match start)';\n    }\n\n    public function visitCharClass(CharClassNode $node): string\n    {\n        $neg = $node->isNegated ? 'NOT ' : '';\n        $parts = array_map(fn (NodeInterface $part) => $part->accept($this), $node->parts);\n\n        return \\sprintf('Character Class: any character %sin [ %s ]', $neg, implode(', ', $parts));\n    }\n\n    public function visitRange(RangeNode $node): string\n    {\n        $start = ($node->start instanceof LiteralNode)\n            ? $this->explainLiteral($node->start->value)\n            : $node->start->accept($this); // Fallback\n\n        $end = ($node->end instanceof LiteralNode)\n            ? $this->explainLiteral($node->end->value)\n            : $node->end->accept($this); // Fallback\n\n        return \\sprintf('Range: from %s to %s', $start, $end);\n    }\n\n    public function visitBackref(BackrefNode $node): string\n    {\n        return \\sprintf('Backreference: matches text from group \"%s\"', $node->ref);\n    }\n\n    public function visitUnicode(UnicodeNode $node): string\n    {\n        return \\sprintf('Unicode: %s', $node->code);\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): string\n    {\n        $type = str_starts_with($node->prop, '^') ? 'non-matching' : 'matching';\n        $prop = ltrim($node->prop, '^');\n\n        return \\sprintf('Unicode Property: any character %s \"%s\"', $type, $prop);\n    }\n\n    public function visitOctal(OctalNode $node): string\n    {\n        return 'Octal: '.$node->code;\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): string\n    {\n        return 'Legacy Octal: \\\\'.$node->code;\n    }\n\n    public function visitPosixClass(PosixClassNode $node): string\n    {\n        return 'POSIX Class: '.$node->class;\n    }\n\n    public function visitComment(CommentNode $node): string\n    {\n        return \\sprintf(\"Comment: '%s'\", $node->comment);\n    }\n\n    public function visitConditional(ConditionalNode $node): string\n    {\n        $this->indentLevel++;\n        $cond = $node->condition->accept($this);\n        $yes = $node->yes->accept($this);\n\n        // Check if the 'no' branch is an empty literal node\n        $hasElseBranch = !($node->no instanceof LiteralNode && '' === $node->no->value);\n        $no = $hasElseBranch ? $node->no->accept($this) : '';\n\n        $this->indentLevel--;\n\n        $indent = $this->indent();\n\n        if ('' === $no) {\n            return \\sprintf(\"Conditional: IF (%s) THEN:\\n%s%s\", $cond, $indent, $yes);\n        }\n\n        return \\sprintf(\"Conditional: IF (%s) THEN:\\n%s%s\\n%sELSE:\\n%s%s\", $cond, $indent, $yes, $this->indent(false), $indent, $no);\n    }\n\n    public function visitSubroutine(SubroutineNode $node): string\n    {\n        $ref = match ($node->reference) {\n            'R' => 'the entire pattern',\n            '0' => 'the entire pattern',\n            default => 'group '.$node->reference,\n        };\n\n        return \\sprintf('Subroutine Call: recurses to %s', $ref);\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): string\n    {\n        return 'PCRE Verb: (*'.$node->verb.')';\n    }\n\n    public function visitDefine(DefineNode $node): string\n    {\n        $this->indentLevel++;\n        $content = $node->content->accept($this);\n        $this->indentLevel--;\n\n        $indent = $this->indent();\n\n        return \\sprintf(\"DEFINE Block (defines subpatterns without matching):\\n%s%s\\n%sEnd DEFINE Block\", $indent, $content, $this->indent(false));\n    }\n\n    private function explainQuantifierValue(string $q, string $type): string\n    {\n        $desc = match ($q) {\n            '*' => 'zero or more times',\n            '+' => 'one or more times',\n            '?' => 'zero or one time',\n            default => preg_match('/^\\{(\\d+)(?:,(\\d*))?\\}$/', $q, $m) ?\n                (isset($m[2]) ? ('' === $m[2] ?\n                    \\sprintf('at least %d times', $m[1]) :\n                    \\sprintf('between %d and %d times', $m[1], $m[2])\n                ) :\n                    \\sprintf('exactly %d times', $m[1])\n                ) :\n                'with quantifier '.$q, // Fallback\n        };\n\n        $desc .= match ($type) {\n            'lazy' => ' (as few as possible)',\n            'possessive' => ' (and do not backtrack)',\n            default => '',\n        };\n\n        return $desc;\n    }\n\n    private function indent(bool $withExtra = true): string\n    {\n        return str_repeat(' ', $this->indentLevel * 2).($withExtra ? '  ' : '');\n    }\n\n    private function explainLiteral(string $value): string\n    {\n        return match ($value) {\n            ' ' => \"' ' (space)\",\n            \"\\t\" => \"'\\\\t' (tab)\",\n            \"\\n\" => \"'\\\\n' (newline)\",\n            \"\\r\" => \"'\\\\r' (carriage return)\",\n            default => ctype_print($value) ? \"'\".$value.\"'\" : '(non-printable char)',\n        };\n    }\n}\n",
    "NodeVisitor/MermaidVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * Generates a Mermaid.js flowchart visualization of a regex AST.\n *\n * Provides visual debugging and documentation capabilities.\n *\n * @implements NodeVisitorInterface<string>\n */\nclass MermaidVisitor implements NodeVisitorInterface\n{\n    private int $nodeCounter = 0;\n\n    /**\n     * @var list<string>\n     */\n    private array $lines = [];\n\n    public function visitRegex(RegexNode $node): string\n    {\n        $this->nodeCounter = 0;\n        $this->lines = [];\n        $this->lines[] = 'graph TD;';\n\n        $nodeId = $this->nextNodeId();\n        $flags = $node->flags ?: 'none';\n        $this->lines[] = \\sprintf('    %s[\"Regex: %s\"]', $nodeId, $this->escape($flags));\n\n        $childId = $node->pattern->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n\n        return implode(\"\\n\", $this->lines);\n    }\n\n    public function visitAlternation(AlternationNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s{\"Alternation\"}', $nodeId);\n\n        foreach ($node->alternatives as $child) {\n            $childId = $child->accept($this);\n            $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n        }\n\n        return $nodeId;\n    }\n\n    public function visitSequence(SequenceNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Sequence\"]', $nodeId);\n\n        foreach ($node->children as $child) {\n            $childId = $child->accept($this);\n            $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n        }\n\n        return $nodeId;\n    }\n\n    public function visitGroup(GroupNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $label = \\sprintf('Group: %s', $node->type->value);\n        $name = $node->name ? ' ('.$node->name.')' : '';\n        $this->lines[] = \\sprintf('    %s(\"%s%s\")', $nodeId, $this->escape($label), $this->escape($name));\n\n        $childId = $node->child->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n\n        return $nodeId;\n    }\n\n    public function visitQuantifier(QuantifierNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $label = \\sprintf('Quantifier: %s', $node->quantifier);\n        $this->lines[] = \\sprintf('    %s[\"%s\"]', $nodeId, $this->escape($label));\n\n        $childId = $node->node->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n\n        return $nodeId;\n    }\n\n    public function visitLiteral(LiteralNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $value = '' === $node->value ? '(empty)' : $node->value;\n        $this->lines[] = \\sprintf('    %s[\"Literal: %s\"]', $nodeId, $this->escape($value));\n\n        return $nodeId;\n    }\n\n    public function visitCharType(CharTypeNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"CharType: \\\\%s\"]', $nodeId, $this->escape($node->value));\n\n        return $nodeId;\n    }\n\n    public function visitDot(DotNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Dot: any char\"]', $nodeId);\n\n        return $nodeId;\n    }\n\n    public function visitAnchor(AnchorNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s((\"Anchor: %s\"))', $nodeId, $this->escape($node->value));\n\n        return $nodeId;\n    }\n\n    public function visitAssertion(AssertionNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Assertion: %s\"]', $nodeId, $this->escape($node->value));\n\n        return $nodeId;\n    }\n\n    public function visitKeep(KeepNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Keep: \\\\K\"]', $nodeId);\n\n        return $nodeId;\n    }\n\n    public function visitCharClass(CharClassNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $label = 'CharClass'.($node->isNegated ? ' [NOT]' : '');\n        $this->lines[] = \\sprintf('    %s[\"%s\"]', $nodeId, $label);\n\n        foreach ($node->parts as $child) {\n            $childId = $child->accept($this);\n            $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $childId);\n        }\n\n        return $nodeId;\n    }\n\n    public function visitRange(RangeNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Range\"]', $nodeId);\n\n        $startId = $node->start->accept($this);\n        $endId = $node->end->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|from| %s', $nodeId, $startId);\n        $this->lines[] = \\sprintf('    %s -->|to| %s', $nodeId, $endId);\n\n        return $nodeId;\n    }\n\n    public function visitBackref(BackrefNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Backref: %s\"]', $nodeId, $this->escape($node->ref));\n\n        return $nodeId;\n    }\n\n    public function visitUnicode(UnicodeNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Unicode: %s\"]', $nodeId, $this->escape($node->code));\n\n        return $nodeId;\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"UnicodeProp: %s\"]', $nodeId, $this->escape($node->prop));\n\n        return $nodeId;\n    }\n\n    public function visitOctal(OctalNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Octal: %s\"]', $nodeId, $this->escape($node->code));\n\n        return $nodeId;\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"OctalLegacy: %s\"]', $nodeId, $this->escape($node->code));\n\n        return $nodeId;\n    }\n\n    public function visitPosixClass(PosixClassNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"PosixClass: %s\"]', $nodeId, $this->escape($node->class));\n\n        return $nodeId;\n    }\n\n    public function visitComment(CommentNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $comment = substr($node->comment, 0, 20);\n        $this->lines[] = \\sprintf('    %s[\"Comment: %s\"]', $nodeId, $this->escape($comment));\n\n        return $nodeId;\n    }\n\n    public function visitConditional(ConditionalNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s{{\"Conditional\"}}', $nodeId);\n\n        $condId = $node->condition->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|condition| %s', $nodeId, $condId);\n\n        $yesId = $node->yes->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|yes| %s', $nodeId, $yesId);\n\n        $noId = $node->no->accept($this);\n        $this->lines[] = \\sprintf('    %s -->|no| %s', $nodeId, $noId);\n\n        return $nodeId;\n    }\n\n    public function visitSubroutine(SubroutineNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"Subroutine: %s\"]', $nodeId, $this->escape($node->reference));\n\n        return $nodeId;\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"PcreVerb: %s\"]', $nodeId, $this->escape($node->verb));\n\n        return $nodeId;\n    }\n\n    public function visitDefine(DefineNode $node): string\n    {\n        $nodeId = $this->nextNodeId();\n        $this->lines[] = \\sprintf('    %s[\"DEFINE Block\"]', $nodeId);\n\n        $contentId = $node->content->accept($this);\n        $this->lines[] = \\sprintf('    %s --> %s', $nodeId, $contentId);\n\n        return $nodeId;\n    }\n\n    private function nextNodeId(): string\n    {\n        return 'node'.($this->nodeCounter++);\n    }\n\n    private function escape(string $value): string\n    {\n        return htmlspecialchars($value, \\ENT_QUOTES | \\ENT_HTML5, 'UTF-8');\n    }\n}\n",
    "NodeVisitor/NodeVisitorInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * Defines the Visitor interface for traversing the AST.\n * Uses the Visitor design pattern.\n *\n * @template-covariant TReturn The return type of the visitor (e.g., 'string' for Compiler, 'void' for Validator)\n */\ninterface NodeVisitorInterface\n{\n    /**\n     * @return TReturn\n     */\n    public function visitRegex(RegexNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitAlternation(AlternationNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitSequence(SequenceNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitGroup(GroupNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitQuantifier(QuantifierNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitLiteral(LiteralNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitCharType(CharTypeNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitDot(DotNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitAnchor(AnchorNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitAssertion(AssertionNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitKeep(KeepNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitCharClass(CharClassNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitRange(RangeNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitBackref(BackrefNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitUnicode(UnicodeNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitUnicodeProp(UnicodePropNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitOctal(OctalNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitOctalLegacy(OctalLegacyNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitPosixClass(PosixClassNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitComment(CommentNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitConditional(ConditionalNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitSubroutine(SubroutineNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitPcreVerb(PcreVerbNode $node);\n\n    /**\n     * @return TReturn\n     */\n    public function visitDefine(DefineNode $node);\n}\n",
    "NodeVisitor/OptimizerNodeVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\NodeVisitor;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\n\n/**\n * A visitor that transforms the AST to apply optimizations.\n * It returns a new (or identical) NodeInterface for each node visited.\n * This allows for true AST-to-AST transformation.\n *\n * Optimizations include:\n * - Merging adjacent LiteralNodes\n * - Flattening nested SequenceNodes and AlternationNodes\n * - Converting simple alternations to CharacterClasses (e.g., a|b|c -> [abc])\n * - Simplifying character classes (e.g., [0-9] -> \\d)\n * - Removing redundant non-capturing groups\n *\n * @implements NodeVisitorInterface<NodeInterface>\n */\nclass OptimizerNodeVisitor implements NodeVisitorInterface\n{\n    /**\n     * Characters that are meta-characters inside a character class.\n     */\n    private const array CHAR_CLASS_META = [']' => true, '\\\\' => true, '^' => true, '-' => true];\n\n    private string $flags = '';\n\n    public function visitRegex(RegexNode $node): NodeInterface\n    {\n        $this->flags = $node->flags;\n        $optimizedPattern = $node->pattern->accept($this);\n\n        if ($optimizedPattern === $node->pattern) {\n            return $node; // No changes\n        }\n\n        return new RegexNode($optimizedPattern, $node->flags, $node->delimiter, $node->startPos, $node->endPos);\n    }\n\n    public function visitAlternation(AlternationNode $node): NodeInterface\n    {\n        $optimizedAlts = [];\n        $hasChanged = false;\n\n        foreach ($node->alternatives as $alt) {\n            $optimizedAlt = $alt->accept($this);\n\n            // Optimization: Flatten nested alternations (e.g., a|(b|c))\n            if ($optimizedAlt instanceof AlternationNode) {\n                array_push($optimizedAlts, ...$optimizedAlt->alternatives);\n                $hasChanged = true;\n            } else {\n                $optimizedAlts[] = $optimizedAlt;\n            }\n\n            if ($optimizedAlt !== $alt) {\n                $hasChanged = true;\n            }\n        }\n\n        // Optimization: a|b|c -> [abc]\n        if ($this->canAlternationBeCharClass($optimizedAlts)) {\n            /* @var list<LiteralNode> $optimizedAlts */\n            return new CharClassNode($optimizedAlts, false, $node->startPos, $node->endPos);\n        }\n\n        if (!$hasChanged) {\n            return $node;\n        }\n\n        return new AlternationNode($optimizedAlts, $node->startPos, $node->endPos);\n    }\n\n    public function visitSequence(SequenceNode $node): NodeInterface\n    {\n        $optimizedChildren = [];\n        $hasChanged = false;\n\n        foreach ($node->children as $child) {\n            $optimizedChild = $child->accept($this);\n\n            // Optimization: Merge adjacent literals (e.g., \"a\" . \"b\" -> \"ab\")\n            if ($optimizedChild instanceof LiteralNode && \\count($optimizedChildren) > 0) {\n                $prevNode = $optimizedChildren[\\count($optimizedChildren) - 1];\n                if ($prevNode instanceof LiteralNode) {\n                    // Merge with previous node\n                    $optimizedChildren[\\count($optimizedChildren) - 1] = new LiteralNode(\n                        $prevNode->value.$optimizedChild->value,\n                        $prevNode->startPos,\n                        $optimizedChild->endPos,\n                    );\n                    $hasChanged = true;\n\n                    continue;\n                }\n            }\n\n            // Optimization: Flatten nested sequences (e.g., a(bc)d)\n            if ($optimizedChild instanceof SequenceNode) {\n                // This is safe because adjacent literals *within* the child\n                // sequence have already been merged by its own visitSequence call.\n                array_push($optimizedChildren, ...$optimizedChild->children);\n                $hasChanged = true;\n\n                continue;\n            }\n\n            // Optimization: Remove empty literals (e.g. from an empty group)\n            if ($optimizedChild instanceof LiteralNode && '' === $optimizedChild->value) {\n                $hasChanged = true;\n\n                continue;\n            }\n\n            if ($optimizedChild !== $child) {\n                $hasChanged = true;\n            }\n\n            $optimizedChildren[] = $optimizedChild;\n        }\n\n        if (!$hasChanged) {\n            return $node;\n        }\n\n        // A sequence with one child is just that child\n        if (1 === \\count($optimizedChildren)) {\n            return $optimizedChildren[0];\n        }\n\n        // A sequence with no children is an empty literal\n        if (0 === \\count($optimizedChildren)) {\n            return new LiteralNode('', $node->startPos, $node->endPos);\n        }\n\n        return new SequenceNode($optimizedChildren, $node->startPos, $node->endPos);\n    }\n\n    public function visitGroup(GroupNode $node): NodeInterface\n    {\n        $optimizedChild = $node->child->accept($this);\n\n        // Optimization: (?:a) -> a\n        // A non-capturing group with a single, simple child can be unwrapped.\n        if (\n            GroupType::T_GROUP_NON_CAPTURING === $node->type\n            && ($optimizedChild instanceof LiteralNode\n                || $optimizedChild instanceof CharTypeNode\n                || $optimizedChild instanceof DotNode)\n        ) {\n            return $optimizedChild; // Return the child directly\n        }\n\n        // Optimization: (?:[abc]) -> [abc]\n        // A non-capturing group with only a CharClassNode can be unwrapped.\n        if (\n            GroupType::T_GROUP_NON_CAPTURING === $node->type\n            && $optimizedChild instanceof CharClassNode\n        ) {\n            return $optimizedChild;\n        }\n\n        // Re-build group if child changed\n        if ($optimizedChild !== $node->child) {\n            return new GroupNode($optimizedChild, $node->type, $node->name, $node->flags, $node->startPos, $node->endPos);\n        }\n\n        return $node; // No changes\n    }\n\n    public function visitQuantifier(QuantifierNode $node): NodeInterface\n    {\n        $optimizedNode = $node->node->accept($this);\n\n        // Optimization: (?:a)* -> a*\n        // If the quantified node was a non-capturing group that got\n        // optimized away (e.g. (?:a)), $optimizedNode is now just Literal(a).\n        // The QuantifierNode constructor doesn't need to change, but\n        // the CompilerNodeVisitor must be smart about adding (?:...) back\n        // *only* if the quantified node is a Sequence or Alternation.\n        // Your CompilerNodeVisitor already does this, so we are good.\n\n        // TODO: Add (a*)* -> (a*)\n        // TODO: Add a?a? -> a{0,2}\n\n        if ($optimizedNode !== $node->node) {\n            return new QuantifierNode($optimizedNode, $node->quantifier, $node->type, $node->startPos, $node->endPos);\n        }\n\n        return $node;\n    }\n\n    public function visitCharClass(CharClassNode $node): NodeInterface\n    {\n        // This is where the logic from your Rector visitor belongs.\n        $isUnicode = str_contains($this->flags, 'u');\n\n        // Optimization: [0-9] -> \\d (only if NOT unicode)\n        if (!$isUnicode && !$node->isNegated && 1 === \\count($node->parts)) {\n            $part = $node->parts[0];\n            if ($part instanceof RangeNode && $part->start instanceof LiteralNode && $part->end instanceof LiteralNode) {\n                if ('0' === $part->start->value && '9' === $part->end->value) {\n                    return new CharTypeNode('d', $node->startPos, $node->endPos);\n                }\n            }\n        }\n\n        // Optimization: [a-zA-Z0-9_] -> \\w (only if NOT unicode)\n        if (!$isUnicode && !$node->isNegated && 4 === \\count($node->parts)) {\n            if ($this->isFullWordClass($node)) {\n                return new CharTypeNode('w', $node->startPos, $node->endPos);\n            }\n        }\n\n        // TODO: Optimization: [a-cdefg] -> [a-g] (merge ranges)\n        // TODO: Optimization: [aa] -> [a] (deduplicate literals)\n\n        // Recurse into parts (though not much to optimize in class parts)\n        $optimizedParts = [];\n        $hasChanged = false;\n        foreach ($node->parts as $part) {\n            $optimizedPart = $part->accept($this);\n            $optimizedParts[] = $optimizedPart;\n            if ($optimizedPart !== $part) {\n                $hasChanged = true;\n            }\n        }\n\n        if ($hasChanged) {\n            return new CharClassNode($optimizedParts, $node->isNegated, $node->startPos, $node->endPos);\n        }\n\n        return $node;\n    }\n\n    public function visitRange(RangeNode $node): NodeInterface\n    {\n        // Start and End are simple nodes, no need to visit\n        return $node;\n    }\n\n    public function visitConditional(ConditionalNode $node): NodeInterface\n    {\n        $optimizedCond = $node->condition->accept($this);\n        $optimizedYes = $node->yes->accept($this);\n        $optimizedNo = $node->no->accept($this);\n\n        if ($optimizedCond !== $node->condition || $optimizedYes !== $node->yes || $optimizedNo !== $node->no) {\n            return new ConditionalNode($optimizedCond, $optimizedYes, $optimizedNo, $node->startPos, $node->endPos);\n        }\n\n        return $node;\n    }\n\n    // --- Simple nodes are leaves; they cannot be optimized further ---\n\n    public function visitLiteral(LiteralNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitCharType(CharTypeNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitDot(DotNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitAnchor(AnchorNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitAssertion(AssertionNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitKeep(KeepNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitBackref(BackrefNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitUnicode(UnicodeNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitUnicodeProp(UnicodePropNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitOctal(OctalNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitOctalLegacy(OctalLegacyNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitPosixClass(PosixClassNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitComment(CommentNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitSubroutine(SubroutineNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitPcreVerb(PcreVerbNode $node): NodeInterface\n    {\n        return $node;\n    }\n\n    public function visitDefine(DefineNode $node): NodeInterface\n    {\n        return new DefineNode(\n            $node->content->accept($this),\n            $node->startPos,\n            $node->endPos,\n        );\n    }\n\n    /**\n     * Checks if an AlternationNode contains only single, non-meta literal characters.\n     *\n     * @param array<NodeInterface> $alternatives\n     */\n    private function canAlternationBeCharClass(array $alternatives): bool\n    {\n        if (empty($alternatives)) {\n            return false;\n        }\n\n        foreach ($alternatives as $alt) {\n            if (!$alt instanceof LiteralNode) {\n                return false;\n            }\n            if (mb_strlen($alt->value) > 1) {\n                return false; // Not a single char\n            }\n            if (isset(self::CHAR_CLASS_META[$alt->value])) {\n                return false; // Meta char, safer to leave as alternation\n            }\n        }\n\n        return true;\n    }\n\n    private function isFullWordClass(CharClassNode $node): bool\n    {\n        $partsFound = ['a-z' => false, 'A-Z' => false, '0-9' => false, '_' => false];\n        foreach ($node->parts as $part) {\n            if ($part instanceof RangeNode && $part->start instanceof LiteralNode && $part->end instanceof LiteralNode) {\n                $range = $part->start->value.'-'.$part->end->value;\n                if (isset($partsFound[$range])) {\n                    $partsFound[$range] = true;\n                }\n            } elseif ($part instanceof LiteralNode && '_' === $part->value) {\n                $partsFound['_'] = true;\n            }\n        }\n\n        return !\\in_array(false, $partsFound, true);\n    }\n}\n",
    "Parser.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nuse Psr\\SimpleCache\\CacheInterface;\nuse Psr\\SimpleCache\\InvalidArgumentException;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\Exception\\RecursionLimitException;\nuse RegexParser\\Exception\\ResourceLimitException;\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\BackrefNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\CommentNode;\nuse RegexParser\\Node\\ConditionalNode;\nuse RegexParser\\Node\\DefineNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\KeepNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\OctalLegacyNode;\nuse RegexParser\\Node\\OctalNode;\nuse RegexParser\\Node\\PcreVerbNode;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\Node\\RangeNode;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\Node\\SubroutineNode;\nuse RegexParser\\Node\\UnicodeNode;\nuse RegexParser\\Node\\UnicodePropNode;\nuse RegexParser\\Stream\\TokenStream;\n\nuse function count;\n\n/**\n * The Parser.\n *\n * It transforms a stream of Tokens (from the Lexer) into an Abstract Syntax Tree (AST).\n * It implements a Recursive Descent Parser based on PCRE grammar.\n */\nfinal class Parser\n{\n    /**\n     * Default hard limit on the regex string length to prevent excessive processing/memory usage.\n     */\n    public const int DEFAULT_MAX_PATTERN_LENGTH = 100_000;\n\n    /**\n     * Default maximum recursion depth (prevents stack overflow on deeply nested patterns).\n     */\n    public const int DEFAULT_MAX_RECURSION_DEPTH = 200;\n\n    /**\n     * Default maximum number of AST nodes (prevents DoS through node exhaustion).\n     */\n    public const int DEFAULT_MAX_NODES = 10000;\n\n    private readonly int $maxPatternLength;\n\n    private readonly int $maxRecursionDepth;\n\n    private readonly int $maxNodes;\n\n    /**\n     * Current recursion depth (tracks during parsing).\n     */\n    private int $recursionDepth = 0;\n\n    /**\n     * Current node count (tracks during parsing).\n     */\n    private int $nodeCount = 0;\n\n    /**\n     * Token stream (replaces array of tokens for memory efficiency).\n     */\n    private TokenStream $stream;\n\n    /**\n     * Runtime cache for parsed ASTs (Layer 1).\n     * Maps cache keys to RegexNode instances for fast repeated access within same request.\n     *\n     * @var array<string, RegexNode>\n     */\n    private array $runtimeCache = [];\n\n    private ?CacheInterface $cache = null;\n\n    /**\n     * @param array{\n     *     max_pattern_length?: int,\n     *     max_recursion_depth?: int,\n     *     max_nodes?: int,\n     *     cache?: CacheInterface|null,\n     * } $options Configuration options\n     * @param Lexer|null $lexer Optional Lexer instance for dependency injection\n     */\n    public function __construct(\n        array $options = [],\n        private ?Lexer $lexer = null,\n    ) {\n        $this->maxPatternLength = (int) ($options['max_pattern_length'] ?? self::DEFAULT_MAX_PATTERN_LENGTH);\n        $this->maxRecursionDepth = (int) ($options['max_recursion_depth'] ?? self::DEFAULT_MAX_RECURSION_DEPTH);\n        $this->maxNodes = (int) ($options['max_nodes'] ?? self::DEFAULT_MAX_NODES);\n        $this->cache = $options['cache'] ?? null;\n    }\n\n    /**\n     * Parses a full regex string (including delimiters and flags) into an AST.\n     *\n     * Implements a two-layer caching strategy:\n     * 1. Runtime Cache (Layer 1): Fast in-memory cache for repeated calls within same request\n     * 2. PSR-16 Persistent Cache (Layer 2): Optional external cache for cross-request optimization\n     *\n     * @throws ParserException         if the regex syntax is invalid\n     * @throws RecursionLimitException if recursion depth exceeds limit\n     * @throws ResourceLimitException  if node count exceeds limit\n     */\n    public function parse(string $regex): RegexNode\n    {\n        if (\\strlen($regex) > $this->maxPatternLength) {\n            throw new ParserException(\\sprintf('Regex pattern exceeds maximum length of %d characters.', $this->maxPatternLength));\n        }\n\n        // Generate cache key\n        $cacheKey = 'regex_parser_'.md5($regex);\n\n        // Layer 1: Check runtime cache\n        if (isset($this->runtimeCache[$cacheKey])) {\n            return $this->runtimeCache[$cacheKey];\n        }\n\n        // Layer 2: Check persistent cache (if available)\n        if (null !== $this->cache) {\n            try {\n                $cached = $this->cache->get($cacheKey);\n                if ($cached instanceof RegexNode) {\n                    // Found in persistent cache - save to runtime for next call\n                    $this->runtimeCache[$cacheKey] = $cached;\n\n                    return $cached;\n                }\n            } catch (InvalidArgumentException) {\n                // Cache key is invalid - proceed with parsing\n                // (should not happen with our key format, but catch for safety)\n            }\n        }\n\n        // Cache miss - proceed with actual parsing\n        [$pattern, $flags, $delimiter] = $this->extractPatternAndFlags($regex);\n\n        // Reset state for new parse\n        $this->recursionDepth = 0;\n        $this->nodeCount = 0;\n\n        // Initialize Token Stream (Generator-based)\n        $lexer = $this->getLexer($pattern);\n        $this->stream = new TokenStream($lexer->tokenize());\n\n        // Parse the pattern content\n        $patternNode = $this->parseAlternation();\n\n        // Ensure we reached the end of the pattern\n        $this->consume(TokenType::T_EOF, 'Unexpected content at end of pattern');\n\n        $ast = new RegexNode($patternNode, $flags, $delimiter, 0, \\strlen($pattern));\n\n        // Save to runtime cache (Layer 1)\n        $this->runtimeCache[$cacheKey] = $ast;\n\n        // Save to persistent cache (Layer 2) if available\n        if (null !== $this->cache) {\n            try {\n                $this->cache->set($cacheKey, $ast);\n            } catch (InvalidArgumentException) {\n                // Cache write failed - log would be nice but not critical\n                // Continue without caching\n            }\n        }\n\n        return $ast;\n    }\n\n    /**\n     * Parses a TokenStream into a complete RegexNode AST.\n     *\n     * This is the low-level parsing method that operates purely on tokens.\n     * It has no knowledge of raw strings, delimiters, or caching.\n     *\n     * For most use cases, use RegexCompiler::parse() which handles string\n     * processing, tokenization, and caching automatically.\n     *\n     * @param TokenStream $stream        The token stream to parse\n     * @param string      $flags         Regex flags (e.g., 'i', 'ms')\n     * @param string      $delimiter     The delimiter used (e.g., '/')\n     * @param int         $patternLength Length of the original pattern\n     *\n     * @throws ParserException         if the regex syntax is invalid\n     * @throws RecursionLimitException if recursion depth exceeds limit\n     * @throws ResourceLimitException  if node count exceeds limit\n     */\n    public function parseTokenStream(\n        TokenStream $stream,\n        string $flags = '',\n        string $delimiter = '/',\n        int $patternLength = 0\n    ): RegexNode {\n        // Reset state for new parse\n        $this->recursionDepth = 0;\n        $this->nodeCount = 0;\n        $this->stream = $stream;\n\n        // Parse the pattern content\n        $patternNode = $this->parseAlternation();\n\n        // Ensure we reached the end of the pattern\n        $this->consume(TokenType::T_EOF, 'Unexpected content at end of pattern');\n\n        return new RegexNode($patternNode, $flags, $delimiter, 0, $patternLength);\n    }\n\n    private function getLexer(string $pattern): Lexer\n    {\n        if (null === $this->lexer) {\n            $this->lexer = new Lexer($pattern);\n        } else {\n            $this->lexer->reset($pattern);\n        }\n\n        return $this->lexer;\n    }\n\n    /**\n     * Extracts pattern, flags, and delimiter.\n     * Handles escaped delimiters correctly (e.g., \"/abc\\/def/i\").\n     *\n     * @return array{0: string, 1: string, 2: string} [pattern, flags, delimiter]\n     */\n    private function extractPatternAndFlags(string $regex): array\n    {\n        $len = \\strlen($regex);\n        if ($len < 2) {\n            throw new ParserException('Regex is too short. It must include delimiters.');\n        }\n\n        $delimiter = $regex[0];\n        // Handle bracket delimiters style: (pattern), [pattern], {pattern}, <pattern>\n        $closingDelimiter = match ($delimiter) {\n            '(' => ')',\n            '[' => ']',\n            '{' => '}',\n            '<' => '>',\n            default => $delimiter,\n        };\n\n        // Find the last occurrence of the closing delimiter that is NOT escaped\n        // We scan from the end to optimize for flags\n        for ($i = $len - 1; $i > 0; $i--) {\n            if ($regex[$i] === $closingDelimiter) {\n                // Check if escaped (count odd number of backslashes before it)\n                $escapes = 0;\n                for ($j = $i - 1; $j > 0 && '\\\\' === $regex[$j]; $j--) {\n                    $escapes++;\n                }\n\n                if (0 === $escapes % 2) {\n                    // Found the end delimiter\n                    $pattern = substr($regex, 1, $i - 1);\n                    $flags = substr($regex, $i + 1);\n\n                    // Validate flags (only allow standard PCRE flags)\n                    // n = NO_AUTO_CAPTURE, r = PCRE2_EXTRA_CASELESS_RESTRICT (unicode restricted)\n                    if (!preg_match('/^[imsxADSUXJunr]*$/', $flags)) {\n                        // Find the invalid flag for a better error message\n                        $invalid = preg_replace('/[imsxADSUXJunr]/', '', $flags);\n\n                        throw new ParserException(\\sprintf('Unknown regex flag(s) found: \"%s\"', $invalid ?? $flags));\n                    }\n\n                    return [$pattern, $flags, $delimiter];\n                }\n            }\n        }\n\n        throw new ParserException(\\sprintf('No closing delimiter \"%s\" found.', $closingDelimiter));\n    }\n\n    // ========================================================================\n    // GRAMMAR IMPLEMENTATION (Recursive Descent)\n    // ========================================================================\n\n    /**\n     * alternation -> sequence ( \"|\" sequence )*\n     */\n    private function parseAlternation(): NodeInterface\n    {\n        $startPos = $this->current()->position;\n        $nodes = [$this->parseSequence()];\n\n        while ($this->match(TokenType::T_ALTERNATION)) {\n            $nodes[] = $this->parseSequence();\n        }\n\n        if (1 === \\count($nodes)) {\n            return $nodes[0];\n        }\n\n        // Calculate end position based on the last node\n        $endPos = end($nodes)->getEndPosition();\n\n        return new AlternationNode($nodes, $startPos, $endPos);\n    }\n\n    /**\n     * sequence -> quantifiedAtom*\n     */\n    private function parseSequence(): NodeInterface\n    {\n        $nodes = [];\n        $startPos = $this->current()->position;\n\n        while (!$this->isAtEnd()\n            && !$this->check(TokenType::T_GROUP_CLOSE)\n            && !$this->check(TokenType::T_ALTERNATION)\n        ) {\n            // Handle silent tokens (Quote Mode)\n            if ($this->match(TokenType::T_QUOTE_MODE_START) || $this->match(TokenType::T_QUOTE_MODE_END)) {\n                continue;\n            }\n\n            $nodes[] = $this->parseQuantifiedAtom();\n        }\n\n        if (empty($nodes)) {\n            // \"Empty\" node at the current position\n            return new LiteralNode('', $startPos, $startPos);\n        }\n\n        if (1 === \\count($nodes)) {\n            return $nodes[0];\n        }\n\n        $endPos = end($nodes)->getEndPosition();\n\n        return new SequenceNode($nodes, $startPos, $endPos);\n    }\n\n    /**\n     * quantifiedAtom -> atom ( QUANTIFIER )?\n     */\n    private function parseQuantifiedAtom(): NodeInterface\n    {\n        $node = $this->parseAtom();\n\n        if ($this->match(TokenType::T_QUANTIFIER)) {\n            $token = $this->previous();\n\n            // Validation: Quantifier on empty literal\n            if ($node instanceof LiteralNode && '' === $node->value) {\n                throw new ParserException(\\sprintf('Quantifier without target at position %d', $token->position));\n            }\n\n            // Validation: Quantifier on empty group sequence\n            if ($node instanceof GroupNode) {\n                $child = $node->child;\n                if (($child instanceof LiteralNode && '' === $child->value)\n                    || ($child instanceof SequenceNode && empty($child->children))) {\n                    throw new ParserException(\\sprintf('Quantifier without target at position %d', $token->position));\n                }\n            }\n\n            // Validation: Assertions, anchors, and verbs cannot be quantified\n            if ($node instanceof AnchorNode || $node instanceof AssertionNode || $node instanceof PcreVerbNode || $node instanceof KeepNode) {\n                $nodeName = match (true) {\n                    $node instanceof AnchorNode => $node->value,\n                    $node instanceof AssertionNode => '\\\\'.$node->value,\n                    $node instanceof PcreVerbNode => '(*'.$node->verb.')',\n                    default => '\\K',\n                };\n\n                throw new ParserException(\n                    \\sprintf('Quantifier \"%s\" cannot be applied to assertion or verb \"%s\" at position %d', $token->value, $nodeName, $node->getStartPosition()));\n            }\n\n            [$quantifier, $type] = $this->parseQuantifierValue($token->value);\n\n            $startPos = $node->getStartPosition();\n            $endPos = $token->position + mb_strlen($token->value);\n\n            return new QuantifierNode($node, $quantifier, $type, $startPos, $endPos);\n        }\n\n        return $node;\n    }\n\n    /**\n     * @return array{0: string, 1: QuantifierType}\n     */\n    private function parseQuantifierValue(string $value): array\n    {\n        $lastChar = substr($value, -1);\n        $baseValue = substr($value, 0, -1);\n\n        if ('?' === $lastChar && \\strlen($value) > 1) {\n            return [$baseValue, QuantifierType::T_LAZY];\n        }\n\n        if ('+' === $lastChar && \\strlen($value) > 1) {\n            return [$baseValue, QuantifierType::T_POSSESSIVE];\n        }\n\n        return [$value, QuantifierType::T_GREEDY];\n    }\n\n    /**\n     * atom -> T_LITERAL | T_CHAR_TYPE | ...\n     */\n    private function parseAtom(): NodeInterface\n    {\n        $token = $this->current();\n        $startPos = $token->position;\n\n        // --- Handle Full Fidelity Tokens ---\n\n        // Comments (emitted by Lexer) must be parsed into CommentNode\n        if ($this->match(TokenType::T_COMMENT_OPEN)) {\n            return $this->parseComment();\n        }\n\n        // Quote Mode markers might leak here if sequence parsing logic didn't catch them all.\n        // We consume them silently and recurse to get the next real atom.\n        if ($this->match(TokenType::T_QUOTE_MODE_START) || $this->match(TokenType::T_QUOTE_MODE_END)) {\n            return $this->parseAtom();\n        }\n\n        // --- Standard Atoms ---\n\n        if ($this->match(TokenType::T_LITERAL)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value);\n\n            return new LiteralNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_LITERAL_ESCAPED)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value) + 1; // +1 for the backslash\n\n            return new LiteralNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_CHAR_TYPE)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value) + 1; // +1 for the backslash\n\n            return new CharTypeNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_DOT)) {\n            return new DotNode($startPos, $startPos + 1);\n        }\n\n        if ($this->match(TokenType::T_ANCHOR)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value);\n\n            return new AnchorNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_ASSERTION)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value) + 1;\n\n            return new AssertionNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_BACKREF)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value);\n\n            return new BackrefNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_G_REFERENCE)) {\n            return $this->parseGReference($startPos);\n        }\n\n        if ($this->match(TokenType::T_UNICODE)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value);\n\n            return new UnicodeNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_OCTAL)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value);\n\n            return new OctalNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_OCTAL_LEGACY)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value) + 1;\n\n            return new OctalLegacyNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_UNICODE_PROP)) {\n            $token = $this->previous();\n            // Calculate end pos based on original syntax (\\p{L} vs \\pL)\n            $len = 2 + mb_strlen($token->value); // \\p or \\P + value\n            if (mb_strlen($token->value) > 1 || str_starts_with($token->value, '^')) {\n                $len += 2; // for {}\n            }\n            $endPos = $startPos + $len;\n\n            return new UnicodePropNode($token->value, $startPos, $endPos);\n        }\n\n        if ($this->match(TokenType::T_KEEP)) {\n            return new KeepNode($startPos, $startPos + 2); // \\K\n        }\n\n        if ($this->match(TokenType::T_GROUP_OPEN)) {\n            $startToken = $this->previous();\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n            $endPos = $endToken->position + 1;\n\n            return new GroupNode($expr, GroupType::T_GROUP_CAPTURING, null, null, $startToken->position, $endPos);\n        }\n\n        if ($this->match(TokenType::T_GROUP_MODIFIER_OPEN)) {\n            return $this->parseGroupModifier();\n        }\n\n        if ($this->match(TokenType::T_CHAR_CLASS_OPEN)) {\n            return $this->parseCharClass();\n        }\n\n        if ($this->match(TokenType::T_PCRE_VERB)) {\n            $token = $this->previous();\n            $endPos = $startPos + mb_strlen($token->value) + 3; // +3 for \"(*)\"\n\n            return new PcreVerbNode($token->value, $startPos, $endPos);\n        }\n\n        // Special case: quantifier without target\n        if ($this->check(TokenType::T_QUANTIFIER)) {\n            throw new ParserException(\\sprintf('Quantifier without target at position %d', $this->current()->position));\n        }\n\n        // @codeCoverageIgnoreStart\n        $val = $this->current()->value;\n        $type = $this->current()->type->value;\n\n        throw new ParserException(\\sprintf('Unexpected token \"%s\" (%s) at position %d.', $val, $type, $startPos));\n        // @codeCoverageIgnoreEnd\n    }\n\n    private function parseGReference(int $startPos): NodeInterface\n    {\n        $token = $this->previous();\n        $value = $token->value;\n        $endPos = $startPos + mb_strlen($value);\n\n        // \\g{N} or \\gN (numeric, incl. relative) -> Backreference\n        if (preg_match('/^\\\\\\\\g\\{?([0-9+-]+)\\}?$/', $value, $m)) {\n            return new BackrefNode($value, $startPos, $endPos);\n        }\n\n        // \\g<name> or \\g{name} (non-numeric) -> Subroutine\n        if (preg_match('/^\\\\\\\\g<(\\w+)>$/', $value, $m) || preg_match('/^\\\\\\\\g\\{(\\w+)\\}$/', $value, $m)) {\n            return new SubroutineNode($m[1], 'g', $startPos, $endPos);\n        }\n\n        throw new ParserException(\\sprintf('Invalid \\g reference syntax: %s at position %d', $value, $token->position));\n    }\n\n    private function parseComment(): CommentNode\n    {\n        $startToken = $this->previous(); // (?#\n        $startPos = $startToken->position;\n\n        $comment = '';\n        while (!$this->isAtEnd() && !$this->check(TokenType::T_GROUP_CLOSE)) {\n            $token = $this->current();\n            $comment .= $this->reconstructTokenValue($token);\n            $this->advance();\n        }\n\n        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close comment');\n        $endPos = $endToken->position + 1;\n\n        return new CommentNode($comment, $startPos, $endPos);\n    }\n\n    private function reconstructTokenValue(Token $token): string\n    {\n        return match ($token->type) {\n            // Simple literals\n            TokenType::T_LITERAL, TokenType::T_NEGATION, TokenType::T_RANGE, TokenType::T_DOT,\n            TokenType::T_GROUP_OPEN, TokenType::T_GROUP_CLOSE, TokenType::T_CHAR_CLASS_OPEN, TokenType::T_CHAR_CLASS_CLOSE,\n            TokenType::T_QUANTIFIER, TokenType::T_ALTERNATION, TokenType::T_ANCHOR => $token->value,\n\n            // Types that had a \\ stripped\n            TokenType::T_CHAR_TYPE, TokenType::T_ASSERTION, TokenType::T_KEEP, TokenType::T_OCTAL_LEGACY,\n            TokenType::T_LITERAL_ESCAPED => '\\\\'.$token->value,\n\n            // Types that kept their \\\n            TokenType::T_BACKREF, TokenType::T_G_REFERENCE, TokenType::T_UNICODE, TokenType::T_OCTAL => $token->value,\n\n            // Complex re-assembly\n            TokenType::T_UNICODE_PROP => str_starts_with($token->value, '{') ? '\\p'.$token->value : ((mb_strlen($token->value) > 1 || str_starts_with($token->value, '^')) ? '\\p{'.$token->value.'}' : '\\p'.$token->value),\n            TokenType::T_POSIX_CLASS => '[[:'.$token->value.':]]',\n            TokenType::T_PCRE_VERB => '(*'.$token->value.')',\n            TokenType::T_GROUP_MODIFIER_OPEN => '(?',\n            TokenType::T_COMMENT_OPEN => '(?#',\n            TokenType::T_QUOTE_MODE_START => '\\Q',\n            TokenType::T_QUOTE_MODE_END => '\\E',\n\n            // Should not be encountered here\n            TokenType::T_EOF => '',\n        };\n    }\n\n    private function parseGroupModifier(): NodeInterface\n    {\n        $startToken = $this->previous(); // (?\n        $startPos = $startToken->position;\n\n        // 1. Check for Python-style 'P' groups\n        $pPos = $this->current()->position;\n        if ($this->matchLiteral('P')) {\n            return $this->parsePythonGroup($startPos, $pPos);\n        }\n\n        // 2. Check for standard lookarounds and named groups\n        if ($this->matchLiteral('<')) {\n            return $this->parseStandardGroup($startPos);\n        }\n\n        // 3. Check for conditional (?(...)\n        $isConditionalWithModifier = null;\n        if ($this->match(TokenType::T_GROUP_MODIFIER_OPEN)) {\n            $isConditionalWithModifier = true;\n        } elseif ($this->match(TokenType::T_GROUP_OPEN)) {\n            $isConditionalWithModifier = false;\n        }\n\n        if (null !== $isConditionalWithModifier) {\n            return $this->parseConditional($startPos, $isConditionalWithModifier);\n        }\n\n        // 4. Check for Subroutines\n        if ($this->matchLiteral('&')) { // (?&name)\n            $name = $this->parseSubroutineName();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close subroutine call');\n\n            return new SubroutineNode($name, '&', $startPos, $endToken->position + 1);\n        }\n\n        if ($this->matchLiteral('R')) { // (?R)\n            if ($this->check(TokenType::T_GROUP_CLOSE)) {\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return new SubroutineNode('R', '', $startPos, $endToken->position + 1);\n            }\n            $this->stream->rewind(1); // Rewind 'R'\n        }\n\n        // Check for (?1), (?-1), (?0)\n        if ($subroutine = $this->parseNumericSubroutine($startPos)) {\n            return $subroutine;\n        }\n\n        // 5. Check for simple non-capturing, lookaheads, atomic, branch reset\n        if ($this->matchLiteral(':')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_NON_CAPTURING, null, null, $startPos, $endToken->position + 1);\n        }\n        if ($this->matchLiteral('=')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_LOOKAHEAD_POSITIVE, null, null, $startPos, $endToken->position + 1);\n        }\n        if ($this->matchLiteral('!')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_LOOKAHEAD_NEGATIVE, null, null, $startPos, $endToken->position + 1);\n        }\n        if ($this->matchLiteral('>')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_ATOMIC, null, null, $startPos, $endToken->position + 1);\n        }\n        if ($this->match(TokenType::T_ALTERNATION)) {\n            // Branch reset group (?|...)\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_BRANCH_RESET, null, null, $startPos, $endToken->position + 1);\n        }\n\n        // 6. Inline flags\n        return $this->parseInlineFlags($startPos);\n    }\n\n    // --- Helper methods for parseGroupModifier decomposition ---\n\n    private function parsePythonGroup(int $startPos, int $pPos): NodeInterface\n    {\n        // Check for (?P'name'...) or (?P\"name\"...)\n        if ($this->checkLiteral(\"'\") || $this->checkLiteral('\"')) {\n            $quote = $this->current()->value;\n            $this->advance();\n\n            // Consume T_LITERAL tokens to build the name character by character\n            $name = '';\n            while (!$this->isAtEnd() && !$this->checkLiteral($quote)) {\n                if ($this->check(TokenType::T_LITERAL)) {\n                    $name .= $this->current()->value;\n                    $this->advance();\n                } else {\n                    throw new ParserException(\n                        \\sprintf('Unexpected token in group name at position %d', $this->current()->position));\n                }\n            }\n\n            if ('' === $name) {\n                throw new ParserException(\\sprintf('Expected group name at position %d', $this->current()->position));\n            }\n\n            if (!$this->checkLiteral($quote)) {\n                throw new ParserException(\n                    \\sprintf('Expected closing quote %s at position %d', $quote, $this->current()->position));\n            }\n            $this->advance();\n\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_NAMED, $name, null, $startPos, $endToken->position + 1);\n        }\n\n        if ($this->matchLiteral('<')) { // (?P<name>...)\n            $name = $this->parseGroupName();\n            $this->consumeLiteral('>', 'Expected > after group name');\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_NAMED, $name, null, $startPos, $endToken->position + 1);\n        }\n\n        if ($this->matchLiteral('>')) { // (?P>name) subroutine\n            $name = $this->parseSubroutineName();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) to close subroutine call');\n\n            return new SubroutineNode($name, 'P>', $startPos, $endToken->position + 1);\n        }\n\n        if ($this->matchLiteral('=')) {\n            throw new ParserException('Backreferences (?P=name) are not supported yet.');\n        }\n\n        throw new ParserException(\\sprintf('Invalid syntax after (?P at position %d', $pPos));\n    }\n\n    private function parseStandardGroup(int $startPos): NodeInterface\n    {\n        if ($this->matchLiteral('=')) { // (?<=...)\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_LOOKBEHIND_POSITIVE, null, null, $startPos, $endToken->position + 1);\n        }\n        if ($this->matchLiteral('!')) { // (?<!...)\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_LOOKBEHIND_NEGATIVE, null, null, $startPos, $endToken->position + 1);\n        }\n        // (?<name>...)\n        $name = $this->parseGroupName();\n        $this->consumeLiteral('>', 'Expected > after group name');\n        $expr = $this->parseAlternation();\n        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n        return new GroupNode($expr, GroupType::T_GROUP_NAMED, $name, null, $startPos, $endToken->position + 1);\n    }\n\n    private function parseNumericSubroutine(int $startPos): ?SubroutineNode\n    {\n        $num = '';\n        if ($this->matchLiteral('-')) {\n            $num = '-';\n        }\n        if ($this->check(TokenType::T_LITERAL) && ctype_digit($this->current()->value)) {\n            $num .= $this->current()->value;\n            $this->advance();\n            $num .= $this->consumeWhile(fn (string $c) => ctype_digit($c));\n\n            if ($this->check(TokenType::T_GROUP_CLOSE)) {\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return new SubroutineNode($num, '', $startPos, $endToken->position + 1);\n            }\n            $this->stream->rewind(mb_strlen($num));\n        } elseif ('-' === $num) {\n            $this->stream->rewind(1);\n        }\n\n        return null;\n    }\n\n    private function parseInlineFlags(int $startPos): NodeInterface\n    {\n        // Support all PCRE2 flags including n (NO_AUTO_CAPTURE), r (unicode restricted), and ^ (unset)\n        // Handle ^ (T_ANCHOR) at the start - it means \"unset all flags\" in PCRE2\n        $flags = '';\n        if ($this->check(TokenType::T_ANCHOR) && '^' === $this->current()->value) {\n            $flags = '^';\n            $this->advance();\n        }\n        $flags .= $this->consumeWhile(fn (string $c) => (bool) preg_match('/^[imsxADSUXJnr-]+$/', $c));\n        if ('' !== $flags) {\n            $expr = null;\n            if ($this->matchLiteral(':')) {\n                $expr = $this->parseAlternation();\n            }\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            if (null === $expr) {\n                $currentPos = $this->previous()->position;\n                $expr = new LiteralNode('', $currentPos, $currentPos);\n            }\n\n            return new GroupNode($expr, GroupType::T_GROUP_INLINE_FLAGS, null, $flags, $startPos, $endToken->position + 1);\n        }\n\n        throw new ParserException(\\sprintf('Invalid group modifier syntax at position %d', $startPos));\n    }\n\n    private function parseConditional(int $startPos, bool $isModifier): ConditionalNode|DefineNode\n    {\n        if ($isModifier) {\n            // Inline Lookaround condition\n            $conditionStartPos = $this->previous()->position;\n            $condition = $this->parseLookaroundCondition($conditionStartPos);\n        } else {\n            $condition = $this->parseConditionalCondition();\n            $this->consume(TokenType::T_GROUP_CLOSE, 'Expected ) after condition');\n        }\n\n        $yes = $this->parseAlternation();\n\n        // Special case: (?(DEFINE)...) creates a DefineNode instead of ConditionalNode\n        if ($condition instanceof AssertionNode && 'DEFINE' === $condition->value) {\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n            $endPos = $endToken->position + 1;\n\n            return new DefineNode($yes, $startPos, $endPos);\n        }\n\n        // Note: The \"no\" branch (ELSE) is implicitly handled by parseAlternation returning an AlternationNode.\n        // If the \"yes\" branch is an alternation (a|b), then \"b\" is the ELSE branch.\n        // However, if parseAlternation returns a single SequenceNode, then the \"no\" branch is empty.\n\n        // The original code structure assumed 'no' is always empty unless handled by alternation logic,\n        // but ConditionalNode structure expects 3 arguments: condition, yes, no.\n\n        // Correct interpretation:\n        // (?(cond)yes|no) -> parseAlternation will return an AlternationNode if '|' exists.\n        // But wait! parseAlternation consumes EVERYTHING until ')' or EOF.\n        // So if we have (?(cond)A|B), 'yes' variable will hold Alternation(A, B).\n        // We need to split it manually?\n        // No, the standard Parser logic (inherited) assigns 'no' to an empty LiteralNode.\n        // If 'yes' is an AlternationNode, the visitor/compiler handles the split.\n        // Let's stick to the original logic to be safe:\n\n        $currentPos = $this->current()->position;\n        $no = new LiteralNode('', $currentPos, $currentPos);\n\n        $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n        $endPos = $endToken->position + 1;\n\n        return new ConditionalNode($condition, $yes, $no, $startPos, $endPos);\n    }\n\n    private function parseLookaroundCondition(int $startPos): NodeInterface\n    {\n        if ($this->matchLiteral('=')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_LOOKAHEAD_POSITIVE, null, null, $startPos, $endToken->position);\n        }\n        if ($this->matchLiteral('!')) {\n            $expr = $this->parseAlternation();\n            $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n            return new GroupNode($expr, GroupType::T_GROUP_LOOKAHEAD_NEGATIVE, null, null, $startPos, $endToken->position);\n        }\n        if ($this->matchLiteral('<')) {\n            // @phpstan-ignore-next-line if.alwaysFalse (false positive: position advanced after matching '<')\n            if ($this->matchLiteral('=')) {\n                $expr = $this->parseAlternation();\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return new GroupNode($expr, GroupType::T_GROUP_LOOKBEHIND_POSITIVE, null, null, $startPos, $endToken->position);\n            }\n            // @phpstan-ignore-next-line if.alwaysFalse (false positive: position advanced after matching '<')\n            if ($this->matchLiteral('!')) {\n                $expr = $this->parseAlternation();\n                $endToken = $this->consume(TokenType::T_GROUP_CLOSE, 'Expected )');\n\n                return new GroupNode($expr, GroupType::T_GROUP_LOOKBEHIND_NEGATIVE, null, null, $startPos, $endToken->position);\n            }\n        }\n\n        throw new ParserException('Invalid conditional condition at position '.$startPos);\n    }\n\n    private function parseConditionalCondition(): NodeInterface\n    {\n        $startPos = $this->current()->position;\n\n        // This handles the PCRE feature where (?(DEFINE)...) allows defining subroutines\n        // without matching them immediately.\n        // We need to check for 'DEFINE' by peeking at multiple tokens since the lexer\n        // tokenizes each character separately.\n        if ($this->check(TokenType::T_LITERAL) && 'D' === $this->current()->value) {\n            $savedPos = $this->stream->getPosition();\n            $word = '';\n            while ($this->check(TokenType::T_LITERAL) && ctype_alpha($this->current()->value)) {\n                $word .= $this->current()->value;\n                $this->advance();\n            }\n            if ('DEFINE' === $word && $this->check(TokenType::T_GROUP_CLOSE)) {\n                return new AssertionNode('DEFINE', $startPos, $this->current()->position);\n            }\n            // Not DEFINE, restore position\n            $this->stream->setPosition($savedPos);\n        }\n\n        if ($this->check(TokenType::T_LITERAL) && ctype_digit($this->current()->value)) {\n            $this->advance();\n            $num = (string) ($this->previous()->value.$this->consumeWhile(fn (string $c) => ctype_digit($c)));\n\n            return new BackrefNode($num, $startPos, $this->current()->position);\n        }\n\n        if ($this->matchLiteral('<') || $this->matchLiteral('{')) {\n            $open = $this->previous()->value;\n            $name = $this->parseGroupName();\n            $close = '<' === $open ? '>' : '}';\n            $this->consumeLiteral($close, \"Expected $close after condition name\");\n\n            return new BackrefNode($name, $startPos, $this->current()->position);\n        }\n\n        if ($this->matchLiteral('R')) {\n            return new SubroutineNode('R', '', $startPos, $this->current()->position);\n        }\n\n        if ($this->matchLiteral('?')) {\n            // Lookaround condition inside (?(...))\n            return $this->parseLookaroundCondition($startPos);\n        }\n\n        // Bare name check (for conditions like (?(name)...))\n        if ($this->check(TokenType::T_LITERAL)) {\n            $savedPos = $this->stream->getPosition();\n            $name = '';\n            while ($this->check(TokenType::T_LITERAL) && !$this->checkLiteral(')') && !$this->isAtEnd()) {\n                $name .= $this->current()->value;\n                $this->advance();\n            }\n            if ('' !== $name && $this->check(TokenType::T_GROUP_CLOSE)) {\n                return new BackrefNode($name, $startPos, $this->current()->position);\n            }\n            $this->stream->setPosition($savedPos);\n        }\n\n        $condition = $this->parseAtom();\n\n        if (!($condition instanceof BackrefNode || $condition instanceof GroupNode\n              || $condition instanceof AssertionNode || $condition instanceof SubroutineNode)) {\n            throw new ParserException(\n                \\sprintf('Invalid conditional construct at position %d. Condition must be a group reference, lookaround, or (DEFINE).', $startPos));\n        }\n\n        return $condition;\n    }\n\n    private function parseGroupName(): string\n    {\n        $token = $this->current();\n\n        if (TokenType::T_LITERAL === $token->type && (\"'\" === $token->value || '\"' === $token->value)) {\n            $quote = $token->value;\n            $this->advance();\n            $nameToken = $this->consume(TokenType::T_LITERAL, 'Expected group name');\n            if ($this->current()->value !== $quote) {\n                throw new ParserException(\n                    \\sprintf('Expected closing quote %s at position %d', $quote, $this->current()->position));\n            }\n            $this->advance();\n\n            return $nameToken->value;\n        }\n\n        $name = '';\n        while (!$this->checkLiteral('>') && !$this->checkLiteral('}') && !$this->isAtEnd()) {\n            if ($this->check(TokenType::T_LITERAL) || $this->check(TokenType::T_LITERAL_ESCAPED)) {\n                $name .= $this->current()->value;\n                $this->advance();\n            } else {\n                throw new ParserException(\\sprintf('Unexpected token \"%s\" in group name', $this->current()->value));\n            }\n        }\n\n        if ('' === $name) {\n            throw new ParserException(\\sprintf('Expected group name at position %d', $this->current()->position));\n        }\n\n        return $name;\n    }\n\n    private function parseCharClass(): CharClassNode\n    {\n        $startToken = $this->previous();\n        $startPos = $startToken->position;\n        $isNegated = $this->match(TokenType::T_NEGATION);\n        $parts = [];\n\n        while (!$this->check(TokenType::T_CHAR_CLASS_CLOSE) && !$this->isAtEnd()) {\n            // Silent tokens inside char class\n            if ($this->match(TokenType::T_QUOTE_MODE_START) || $this->match(TokenType::T_QUOTE_MODE_END)) {\n                continue;\n            }\n            $parts[] = $this->parseCharClassPart();\n        }\n\n        $endToken = $this->consume(TokenType::T_CHAR_CLASS_CLOSE, 'Expected \"]\" to close character class');\n\n        return new CharClassNode($parts, $isNegated, $startPos, $endToken->position + 1);\n    }\n\n    private function parseCharClassPart(): NodeInterface\n    {\n        $startToken = $this->current();\n        $startPos = $startToken->position;\n        $startNode = null;\n\n        // Simplified matching logic for char class parts\n        if ($this->match(TokenType::T_LITERAL) || $this->match(TokenType::T_LITERAL_ESCAPED)) {\n            $token = $this->previous();\n            // Check for range validity\n            // +1 if escaped\n            $endPos = $startPos + mb_strlen($token->value) + (TokenType::T_LITERAL_ESCAPED === $token->type ? 1 : 0);\n            $startNode = new LiteralNode($token->value, $startPos, $endPos);\n        } elseif ($this->match(TokenType::T_CHAR_TYPE)) {\n            $token = $this->previous();\n            $startNode = new CharTypeNode($token->value, $startPos, $startPos + mb_strlen($token->value) + 1);\n        } elseif ($this->match(TokenType::T_UNICODE_PROP)) {\n            $token = $this->previous();\n            // Basic length calc - Parser logic from original\n            $len = 2 + mb_strlen($token->value) + ((mb_strlen($token->value) > 1 || str_starts_with($token->value, '^')) ? 2 : 0);\n            $startNode = new UnicodePropNode($token->value, $startPos, $startPos + $len);\n        } elseif ($this->match(TokenType::T_UNICODE)) {\n            $token = $this->previous();\n            $startNode = new UnicodeNode($token->value, $startPos, $startPos + mb_strlen($token->value));\n        } elseif ($this->match(TokenType::T_OCTAL)) {\n            $token = $this->previous();\n            $startNode = new OctalNode($token->value, $startPos, $startPos + mb_strlen($token->value));\n        } elseif ($this->match(TokenType::T_OCTAL_LEGACY)) {\n            $token = $this->previous();\n            $startNode = new OctalLegacyNode($token->value, $startPos, $startPos + mb_strlen($token->value) + 1);\n        } elseif ($this->match(TokenType::T_RANGE)) {\n            // Literal hyphen at start\n            return new LiteralNode($this->previous()->value, $startPos, $startPos + 1);\n        } elseif ($this->match(TokenType::T_POSIX_CLASS)) {\n            $token = $this->previous();\n            $startNode = new PosixClassNode($token->value, $startPos, $startPos + mb_strlen($token->value) + 4);\n        } else {\n            throw new ParserException(\n                \\sprintf('Unexpected token \"%s\" in character class at position %d.', $this->current()->value, $this->current()->position));\n        }\n\n        // Check for Range\n        if ($this->match(TokenType::T_RANGE)) {\n            if ($this->check(TokenType::T_CHAR_CLASS_CLOSE)) {\n                // Trailing hyphen\n                $this->stream->rewind(1);\n\n                return $startNode;\n            }\n\n            // For simplicity, we call parseCharClassPart recursively for the end node,\n            // but we need to ensure it returns a simple node, not a range.\n            // In this grammar, ranges don't chain (a-b-c is invalid or literals).\n            // We manually parse the end node to avoid recursion loop.\n\n            $endToken = $this->current();\n            $endNodeStartPos = $endToken->position;\n\n            // Re-using the logic above is tricky without recursion.\n            // Let's assume simple structure: a-z.\n            // We call parseCharClassPart again.\n            $endNode = $this->parseCharClassPart();\n\n            // Note: Original code handled this inline.\n            return new RangeNode($startNode, $endNode, $startPos, $endNode->getEndPosition());\n        }\n\n        return $startNode;\n    }\n\n    private function parseSubroutineName(): string\n    {\n        $name = '';\n        while (!$this->check(TokenType::T_GROUP_CLOSE) && !$this->isAtEnd()) {\n            if ($this->check(TokenType::T_LITERAL) || $this->check(TokenType::T_LITERAL_ESCAPED)) {\n                $char = $this->current()->value;\n                if (!preg_match('/^[a-zA-Z0-9_]$/', $char)) {\n                    throw new ParserException('Unexpected token in subroutine name: '.$char);\n                }\n                $name .= $char;\n                $this->advance();\n            } else {\n                throw new ParserException('Unexpected token in subroutine name: '.$this->current()->value);\n            }\n        }\n        if ('' === $name) {\n            throw new ParserException('Expected subroutine name at position '.$this->current()->position);\n        }\n\n        return $name;\n    }\n\n    // ... (Navigation helpers match, matchLiteral, check, etc. are standard)\n\n    private function match(TokenType $type): bool\n    {\n        if ($this->check($type)) {\n            $this->advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private function matchLiteral(string $value): bool\n    {\n        if ($this->checkLiteral($value)) {\n            $this->advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private function checkLiteral(string $value): bool\n    {\n        if ($this->isAtEnd()) {\n            return false;\n        }\n        $token = $this->current();\n\n        return TokenType::T_LITERAL === $token->type && $token->value === $value;\n    }\n\n    private function consume(TokenType $type, string $error): Token\n    {\n        if ($this->check($type)) {\n            $token = $this->current();\n            $this->advance();\n\n            return $token;\n        }\n        $at = $this->isAtEnd() ? 'end of input' : 'position '.$this->current()->position;\n\n        throw new ParserException($error.' at '.$at.' (found '.$this->current()->type->value.')');\n    }\n\n    private function consumeLiteral(string $value, string $error): Token\n    {\n        if ($this->checkLiteral($value)) {\n            $token = $this->current();\n            $this->advance();\n\n            return $token;\n        }\n        $at = $this->isAtEnd() ? 'end of input' : 'position '.$this->current()->position;\n\n        throw new ParserException($error.' at '.$at.' (found '.$this->current()->type->value.' with value '.$this->current()->value.')');\n    }\n\n    private function check(TokenType $type): bool\n    {\n        if ($this->isAtEnd()) {\n            return TokenType::T_EOF === $type;\n        }\n\n        return $this->current()->type === $type;\n    }\n\n    private function advance(): void\n    {\n        if (!$this->isAtEnd()) {\n            $this->stream->next();\n        }\n    }\n\n    private function isAtEnd(): bool\n    {\n        return TokenType::T_EOF === $this->current()->type;\n    }\n\n    private function current(): Token\n    {\n        return $this->stream->current();\n    }\n\n    private function previous(): Token\n    {\n        return $this->stream->peek(-1);\n    }\n\n    /**\n     * Check and enforce recursion limit.\n     * Must be called at the start of each recursive parsing method.\n     *\n     * @throws RecursionLimitException if recursion depth exceeds limit\n     *\n     * @phpstan-ignore method.unused (reserved for future resource limiting integration)\n     */\n    private function checkRecursionLimit(): void\n    {\n        $this->recursionDepth++;\n\n        if ($this->recursionDepth > $this->maxRecursionDepth) {\n            throw new RecursionLimitException(\n                \\sprintf(\n                    'Recursion limit of %d exceeded (current: %d). Pattern is too deeply nested.',\n                    $this->maxRecursionDepth,\n                    $this->recursionDepth,\n                ));\n        }\n    }\n\n    /**\n     * End a recursion scope.\n     *\n     * @phpstan-ignore method.unused (reserved for future resource limiting integration)\n     */\n    private function exitRecursionScope(): void\n    {\n        $this->recursionDepth--;\n    }\n\n    /**\n     * Check and enforce node count limit.\n     * Must be called before creating a new node.\n     *\n     * @throws ResourceLimitException if node count exceeds limit\n     *\n     * @phpstan-ignore method.unused (reserved for future resource limiting integration)\n     */\n    private function checkNodeLimit(): void\n    {\n        $this->nodeCount++;\n\n        if ($this->nodeCount > $this->maxNodes) {\n            throw new ResourceLimitException(\n                \\sprintf(\n                    'Node count limit of %d exceeded. Pattern is too complex.',\n                    $this->maxNodes,\n                ));\n        }\n    }\n\n    private function consumeWhile(callable $predicate): string\n    {\n        $value = '';\n        while (!$this->isAtEnd() && $this->check(TokenType::T_LITERAL) && $predicate($this->current()->value)) {\n            $value .= $this->current()->value;\n            $this->advance();\n        }\n\n        return $value;\n    }\n}\n",
    "ValidationResult.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\n/**\n * A DTO representing the result of a validation pass.\n */\nclass ValidationResult\n{\n    public function __construct(\n        public readonly bool $isValid,\n        public readonly ?string $error = null,\n        public readonly int $complexityScore = 0,\n    ) {}\n}\n",
    "ReDoSAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nuse RegexParser\\NodeVisitor\\ReDoSProfileVisitor;\n\nfinal readonly class ReDoSAnalyzer\n{\n    public function __construct(private ?RegexCompiler $compiler = new RegexCompiler()) {}\n\n    /**\n     * Analyzes a regex pattern for ReDoS vulnerabilities and returns a detailed report.\n     */\n    public function analyze(string $pattern): ReDoSAnalysis\n    {\n        try {\n            \\assert(null !== $this->compiler);\n            $ast = $this->compiler->parse($pattern);\n            $visitor = new ReDoSProfileVisitor();\n            $ast->accept($visitor);\n\n            $result = $visitor->getResult();\n\n            return new ReDoSAnalysis(\n                $result['severity'],\n                $this->calculateScore($result['severity']),\n                $result['vulnerablePattern'],\n                $result['recommendations'],\n            );\n        } catch (\\Throwable $e) {\n            // Fallback for parsing errors, treat as unknown/safe or rethrow\n            return new ReDoSAnalysis(ReDoSSeverity::SAFE, 0, null, ['Error parsing regex: '.$e->getMessage()]);\n        }\n    }\n\n    private function calculateScore(ReDoSSeverity $severity): int\n    {\n        return match ($severity) {\n            ReDoSSeverity::SAFE => 0,\n            ReDoSSeverity::LOW => 2,\n            ReDoSSeverity::MEDIUM => 5,\n            ReDoSSeverity::HIGH => 8,\n            ReDoSSeverity::CRITICAL => 10,\n        };\n    }\n}\n",
    "Bridge/PHPStan/PregValidationRule.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\PHPStan;\n\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Expr\\FuncCall;\nuse PhpParser\\Node\\Name;\nuse PHPStan\\Analyser\\Scope;\nuse PHPStan\\Rules\\Rule;\nuse PHPStan\\Rules\\RuleErrorBuilder;\nuse RegexParser\\Exception\\ParserException;\nuse RegexParser\\NodeVisitor\\ValidatorNodeVisitor;\nuse RegexParser\\Parser;\nuse RegexParser\\ReDoSAnalyzer;\nuse RegexParser\\ReDoSSeverity;\n\n/**\n * Validates regex patterns in preg_* functions.\n *\n * This rule performs two types of checks:\n * 1. Syntax Validation: Ensures the regex is valid PCRE (identifier: regex.syntax).\n * 2. ReDoS Analysis: Checks for catastrophic backtracking vulnerabilities (identifier: regex.redos).\n *\n * @implements Rule<FuncCall>\n */\nfinal class PregValidationRule implements Rule\n{\n    private const array PREG_FUNCTION_MAP = [\n        'preg_match' => 0,\n        'preg_match_all' => 0,\n        'preg_replace' => 0,\n        'preg_replace_callback' => 0,\n        'preg_split' => 0,\n        'preg_grep' => 0,\n        'preg_filter' => 0,\n    ];\n\n    private const string VALID_DELIMITERS = '/~#%@!();<>';\n\n    /**\n     * Map of severity strings to integer levels for comparison.\n     */\n    private const array SEVERITY_LEVELS = [\n        'safe' => 0,\n        'low' => 1,\n        'medium' => 2,\n        'high' => 3,\n        'critical' => 4,\n    ];\n\n    private ?Parser $parser = null;\n\n    private ?ValidatorNodeVisitor $validator = null;\n\n    private ?ReDoSAnalyzer $redosAnalyzer = null;\n\n    /**\n     * @param string $redosThreshold The minimum severity level to report ('low', 'medium', 'high', 'critical')\n     */\n    public function __construct(\n        private readonly bool $ignoreParseErrors = true,\n        private readonly bool $reportRedos = true,\n        private readonly string $redosThreshold = 'high',\n    ) {}\n\n    public function getNodeType(): string\n    {\n        return FuncCall::class;\n    }\n\n    public function processNode(Node $node, Scope $scope): array\n    {\n        if (!$node->name instanceof Name) {\n            return [];\n        }\n\n        // Optimization: Fast return for non-preg functions\n        $functionName = $node->name->toLowerString();\n        if (!isset(self::PREG_FUNCTION_MAP[$functionName])) {\n            return [];\n        }\n\n        $patternArgPosition = self::PREG_FUNCTION_MAP[$functionName];\n        $args = $node->getArgs();\n\n        if (!isset($args[$patternArgPosition])) {\n            // Malformed call (missing arguments), handled by native PHPStan rules\n            return [];\n        }\n\n        $patternArg = $args[$patternArgPosition]->value;\n        $patternType = $scope->getType($patternArg);\n        $constantStrings = $patternType->getConstantStrings();\n\n        // If we can't determine the string value statically, skip validation\n        if (0 === \\count($constantStrings)) {\n            return [];\n        }\n\n        $errors = [];\n        foreach ($constantStrings as $constantString) {\n            $pattern = $constantString->getValue();\n\n            if (!$this->looksLikeCompleteRegex($pattern)) {\n                continue;\n            }\n\n            // 1. Syntax Validation\n            try {\n                $ast = $this->getParser()->parse($pattern);\n                // ValidatorNodeVisitor checks for semantic errors (e.g., duplicate group names)\n                $ast->accept($this->getValidator());\n            } catch (ParserException $e) {\n                // Skip validation for likely partial/incomplete patterns if configured\n                if ($this->ignoreParseErrors && $this->isLikelyPartialRegexError($e->getMessage())) {\n                    continue;\n                }\n\n                $errors[] = RuleErrorBuilder::message(\\sprintf('Regex syntax error: %s', $e->getMessage()))\n                    ->line($node->getLine())\n                    ->identifier('regex.syntax')\n                    ->build();\n\n                // If syntax is invalid, ReDoS analysis is impossible/irrelevant\n                continue;\n            } catch (\\Throwable) {\n                // Fail silently on internal errors to avoid crashing PHPStan\n                continue;\n            }\n\n            // 2. ReDoS Validation\n            if ($this->reportRedos) {\n                $analysis = $this->getRedosAnalyzer()->analyze($pattern);\n\n                if (!$analysis->isSafe() && $this->exceedsThreshold($analysis->severity)) {\n                    $errors[] = RuleErrorBuilder::message(\\sprintf(\n                        'ReDoS vulnerability detected (%s): %s',\n                        strtoupper($analysis->severity->value),\n                        $this->truncatePattern($pattern),\n                    ))\n                        ->line($node->getLine())\n                        ->tip(implode(\"\\n\", $analysis->recommendations))\n                        ->identifier('regex.redos')\n                        ->build();\n                }\n            }\n        }\n\n        return $errors;\n    }\n\n    private function exceedsThreshold(ReDoSSeverity $severity): bool\n    {\n        $currentLevel = self::SEVERITY_LEVELS[$severity->value] ?? 0;\n        $thresholdLevel = self::SEVERITY_LEVELS[$this->redosThreshold] ?? 3; // Default to 'high'\n\n        return $currentLevel >= $thresholdLevel;\n    }\n\n    /**\n     * Checks if the pattern looks like a complete regex with valid delimiters.\n     */\n    private function looksLikeCompleteRegex(string $pattern): bool\n    {\n        if (\\strlen($pattern) < 2) {\n            return false;\n        }\n\n        $firstChar = $pattern[0];\n\n        if (!str_contains(self::VALID_DELIMITERS, $firstChar)) {\n            return false;\n        }\n\n        // Simple check: pattern ends with same delimiter or has flags\n        // We trust the Parser to do the heavy lifting validation later\n        return true;\n    }\n\n    private function isLikelyPartialRegexError(string $errorMessage): bool\n    {\n        $indicators = [\n            'No closing delimiter',\n            'Regex too short',\n            'Unknown modifier',\n            'Invalid delimiter',\n            'Unexpected end',\n        ];\n\n        return array_any($indicators, fn ($indicator) => false !== stripos($errorMessage, (string) $indicator));\n    }\n\n    private function truncatePattern(string $pattern, int $length = 50): string\n    {\n        return \\strlen($pattern) > $length ? substr($pattern, 0, $length).'...' : $pattern;\n    }\n\n    private function getParser(): Parser\n    {\n        return $this->parser ??= new Parser();\n    }\n\n    private function getValidator(): ValidatorNodeVisitor\n    {\n        return $this->validator ??= new ValidatorNodeVisitor();\n    }\n\n    private function getRedosAnalyzer(): ReDoSAnalyzer\n    {\n        // Using default compiler instance for analyzer\n        return $this->redosAnalyzer ??= new ReDoSAnalyzer();\n    }\n}\n",
    "Bridge/Rector/RegexOptimizationRector.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Rector;\n\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Expr\\FuncCall;\nuse PhpParser\\Node\\Scalar\\String_;\nuse PhpParser\\Node\\Stmt\\ClassConst;\nuse Rector\\Contract\\Rector\\ConfigurableRectorInterface;\nuse Rector\\Rector\\AbstractRector;\nuse RegexParser\\NodeVisitor\\CompilerNodeVisitor;\nuse RegexParser\\NodeVisitor\\OptimizerNodeVisitor;\nuse RegexParser\\Parser;\nuse Symplify\\RuleDocGenerator\\ValueObject\\CodeSample\\ConfiguredCodeSample;\nuse Symplify\\RuleDocGenerator\\ValueObject\\RuleDefinition;\n\n/**\n * Optimizes PCRE regex patterns found in function calls and class constants.\n *\n * This rule parses the regex string, applies AST optimizations (like flattening groups\n * or merging character classes), and recompiles it back to a cleaner string.\n */\nfinal class RegexOptimizationRector extends AbstractRector implements ConfigurableRectorInterface\n{\n    public const string EXTRA_FUNCTIONS = 'extra_functions';\n\n    public const string EXTRA_CONSTANTS = 'extra_constants';\n\n    private const array DEFAULT_FUNCTIONS = [\n        'preg_match',\n        'preg_match_all',\n        'preg_replace',\n        'preg_replace_callback',\n        'preg_split',\n        'preg_grep',\n        'preg_filter',\n    ];\n\n    private const array DEFAULT_CONSTANTS = [\n        'REGEX',\n        'PATTERN',\n    ];\n\n    /**\n     * @var array<string, bool>\n     */\n    private array $targetFunctions = [];\n\n    /**\n     * @var array<string, bool>\n     */\n    private array $targetConstants = [];\n\n    private ?Parser $parser = null;\n\n    private ?CompilerNodeVisitor $compiler = null;\n\n    public function __construct(\n        private readonly OptimizerNodeVisitor $optimizerVisitor,\n    ) {\n        // Initialize defaults\n        foreach (self::DEFAULT_FUNCTIONS as $func) {\n            $this->targetFunctions[$func] = true;\n        }\n        foreach (self::DEFAULT_CONSTANTS as $const) {\n            $this->targetConstants[$const] = true;\n        }\n    }\n\n    public function getRuleDefinition(): RuleDefinition\n    {\n        return new RuleDefinition(\n            'Optimizes regex patterns using RegexParser\\'s AST transformation.',\n            [\n                new ConfiguredCodeSample(\n                    <<<'CODE_SAMPLE'\n                        class SomeClass\n                        {\n                            public function run($str)\n                            {\n                                preg_match('/[a-zA-Z0-9_]+/', $str);\n                            }\n                        }\n                        CODE_SAMPLE,\n                    <<<'CODE_SAMPLE'\n                        class SomeClass\n                        {\n                            public function run($str)\n                            {\n                                preg_match('/\\\\w+/', $str);\n                            }\n                        }\n                        CODE_SAMPLE,\n                    [\n                        self::EXTRA_FUNCTIONS => ['my_custom_preg_wrapper'],\n                    ],\n                ),\n            ],\n        );\n    }\n\n    /**\n     * @param array<string, mixed> $configuration\n     */\n    public function configure(array $configuration): void\n    {\n        if (isset($configuration[self::EXTRA_FUNCTIONS])) {\n            foreach ((array) $configuration[self::EXTRA_FUNCTIONS] as $func) {\n                $this->targetFunctions[(string) $func] = true;\n            }\n        }\n\n        if (isset($configuration[self::EXTRA_CONSTANTS])) {\n            foreach ((array) $configuration[self::EXTRA_CONSTANTS] as $const) {\n                $this->targetConstants[(string) $const] = true;\n            }\n        }\n    }\n\n    public function getNodeTypes(): array\n    {\n        return [FuncCall::class, ClassConst::class];\n    }\n\n    public function refactor(Node $node): ?Node\n    {\n        $stringNode = $this->resolveRegexStringNode($node);\n\n        if (!$stringNode instanceof String_) {\n            return null;\n        }\n\n        $originalPattern = $stringNode->value;\n\n        // Quick check: if it doesn't look like a regex, skip to save performance\n        if (\\strlen($originalPattern) < 2) {\n            return null;\n        }\n\n        try {\n            $parser = $this->getParser();\n            $ast = $parser->parse($originalPattern);\n\n            // 1. Optimization Phase (AST -> AST)\n            // We clone the visitor to ensure a fresh state for each run\n            $optimizer = clone $this->optimizerVisitor;\n            $optimizedAst = $ast->accept($optimizer);\n\n            // 2. Compilation Phase (AST -> String)\n            $compiler = $this->getCompiler();\n            $newPattern = $optimizedAst->accept($compiler);\n\n            // Only modify the AST if the optimization resulted in a change\n            if ($newPattern !== $originalPattern) {\n                $stringNode->value = $newPattern;\n\n                return $node;\n            }\n        } catch (\\Throwable) {\n            // Silently ignore invalid regexes or parsing errors.\n            // Rector's job is to refactor valid code, not to act as a linter.\n        }\n\n        return null;\n    }\n\n    private function resolveRegexStringNode(Node $node): ?String_\n    {\n        if ($node instanceof FuncCall) {\n            return $this->resolveFuncCallArgument($node);\n        }\n\n        if ($node instanceof ClassConst) {\n            return $this->resolveClassConstantValue($node);\n        }\n\n        return null;\n    }\n\n    private function resolveFuncCallArgument(FuncCall $node): ?String_\n    {\n        if (!$node->name instanceof Node\\Name) {\n            return null;\n        }\n\n        $name = $this->getName($node->name);\n        if (null === $name || !isset($this->targetFunctions[$name])) {\n            return null;\n        }\n\n        // In standard preg_ functions, the pattern is always the first argument (index 0)\n        // If custom functions use a different index, we might need more advanced config later.\n        $args = $node->getArgs();\n        if (!isset($args[0])) {\n            return null;\n        }\n\n        $patternArg = $args[0]->value;\n\n        return $patternArg instanceof String_ ? $patternArg : null;\n    }\n\n    private function resolveClassConstantValue(ClassConst $node): ?String_\n    {\n        // Check if any of the constant names match our target list\n        foreach ($node->consts as $const) {\n            if (isset($this->targetConstants[$const->name->toString()])) {\n                return $const->value instanceof String_ ? $const->value : null;\n            }\n        }\n\n        return null;\n    }\n\n    private function getParser(): Parser\n    {\n        // Lazy initialization\n        return $this->parser ??= new Parser();\n    }\n\n    private function getCompiler(): CompilerNodeVisitor\n    {\n        // Lazy initialization\n        return $this->compiler ??= new CompilerNodeVisitor();\n    }\n}\n",
    "Bridge/Symfony/RegexParserBundle.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\n/**\n * Symfony Bundle for the RegexParser library.\n *\n * Provides integration with the Symfony Web Profiler for analyzing\n * regex patterns used in your application (via Router and Validator).\n *\n * Configuration is handled by RegexParserExtension. No logic should\n * be placed in this class.\n *\n * @see \\RegexParser\\Bridge\\Symfony\\DependencyInjection\\RegexParserExtension\n * @see \\RegexParser\\Bridge\\Symfony\\DependencyInjection\\Configuration\n */\nfinal class RegexParserBundle extends Bundle\n{\n    #[\\Override]\n    public function getPath(): string\n    {\n        return __DIR__.'/../../Bridge/Symfony';\n    }\n}\n",
    "Bridge/Symfony/Resources/config/services.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\nuse Psr\\Log\\LoggerInterface;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\CacheWarmer\\RegexParserCacheWarmer;\nuse RegexParser\\Bridge\\Symfony\\Command\\RegexParserValidateCommand;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n/*\n * Base services for the RegexParser library.\n *\n * These services are always loaded when the bundle is enabled.\n */\nreturn static function (ContainerConfigurator $container): void {\n    $services = $container->services()\n        ->defaults()\n            ->private();\n\n    $services->set('regex_parser.regex', Regex::class)\n        ->factory([Regex::class, 'create'])\n        ->arg('$options', [\n            'max_pattern_length' => param('regex_parser.max_pattern_length'),\n            'cache' => param('regex_parser.cache'),\n        ])\n        ->public();\n\n    // Aliases for autowiring\n    $services->alias(Regex::class, 'regex_parser.regex')\n        ->public();\n\n    $services->set(RouteRequirementAnalyzer::class, RouteRequirementAnalyzer::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->arg('$warningThreshold', param('regex_parser.analysis.warning_threshold'))\n        ->arg('$redosThreshold', param('regex_parser.analysis.redos_threshold'));\n\n    $services->set(ValidatorRegexAnalyzer::class, ValidatorRegexAnalyzer::class)\n        ->arg('$regex', service('regex_parser.regex'))\n        ->arg('$warningThreshold', param('regex_parser.analysis.warning_threshold'))\n        ->arg('$redosThreshold', param('regex_parser.analysis.redos_threshold'));\n\n    $services->set('regex_parser.cache_warmer', RegexParserCacheWarmer::class)\n        ->arg('$analyzer', service(RouteRequirementAnalyzer::class))\n        ->arg('$router', service(RouterInterface::class)->nullOnInvalid())\n        ->arg('$logger', service(LoggerInterface::class)->nullOnInvalid())\n        ->arg('$validatorAnalyzer', service(ValidatorRegexAnalyzer::class))\n        ->arg('$validator', service(ValidatorInterface::class)->nullOnInvalid())\n        ->arg('$validatorLoader', service(LoaderInterface::class)->nullOnInvalid())\n        ->tag('kernel.cache_warmer');\n\n    $services->set('regex_parser.command.validate', RegexParserValidateCommand::class)\n        ->arg('$analyzer', service(RouteRequirementAnalyzer::class))\n        ->arg('$router', service(RouterInterface::class)->nullOnInvalid())\n        ->arg('$validatorAnalyzer', service(ValidatorRegexAnalyzer::class))\n        ->arg('$validator', service(ValidatorInterface::class)->nullOnInvalid())\n        ->arg('$validatorLoader', service(LoaderInterface::class)->nullOnInvalid())\n        ->tag('console.command')\n        ->public();\n};\n",
    "Bridge/Symfony/DependencyInjection/Configuration.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\DependencyInjection;\n\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Config\\Definition\\Builder\\TreeBuilder;\nuse Symfony\\Component\\Config\\Definition\\ConfigurationInterface;\n\n/**\n * Defines the configuration schema for the RegexParser bundle.\n *\n * Purpose: This class is responsible for defining and validating the configuration\n * options that users can set in their `config/packages/regex_parser.yaml` file.\n * It uses Symfony's Config component to create a structured tree of options, set\n * default values, and provide documentation for each setting. This ensures that\n * the bundle is configured in a predictable and reliable way.\n *\n * @see https://symfony.com/doc/current/bundles/configuration.html\n */\nclass Configuration implements ConfigurationInterface\n{\n    /**\n     * Creates a new instance of the bundle's configuration schema.\n     *\n     * Purpose: This constructor receives the kernel's debug status, which is used to\n     * set a sensible default for the profiler. The profiler is a debugging tool and\n     * should typically only be enabled in a debug environment to avoid performance\n     * overhead in production.\n     *\n     * @param bool $debug The value of the `kernel.debug` parameter.\n     */\n    public function __construct(\n        private readonly bool $debug = false,\n    ) {}\n\n    /**\n     * Generates the configuration tree builder.\n     *\n     * Purpose: This method defines the structure, default values, and documentation for\n     * all the configuration settings supported by the bundle. As a contributor, if you\n     * need to add a new configuration option, you would add it to the `TreeBuilder`\n     * in this method. This is the single source of truth for the bundle's configuration schema.\n     *\n     * @return TreeBuilder the tree builder instance\n     */\n    public function getConfigTreeBuilder(): TreeBuilder\n    {\n        $treeBuilder = new TreeBuilder('regex_parser');\n\n        $treeBuilder->getRootNode()\n            ->children()\n                ->booleanNode('enabled')\n                    ->defaultValue($this->debug)\n                    ->info('Enable or disable the RegexParser bundle entirely. Defaults to dev/test only.')\n                ->end()\n                ->integerNode('max_pattern_length')\n                    ->defaultValue(Regex::DEFAULT_MAX_PATTERN_LENGTH)\n                    ->info('The maximum allowed length for a regex pattern string to parse.')\n                ->end()\n                ->scalarNode('cache')\n                    ->defaultNull()\n                    ->info('Directory path for cached AST files. Set to null to disable caching.')\n                ->end()\n                ->arrayNode('analysis')\n                    ->addDefaultsIfNotSet()\n                    ->children()\n                        ->integerNode('warning_threshold')\n                            ->defaultValue(50)\n                            ->min(0)\n                            ->info('Complexity score above which a warning is emitted.')\n                        ->end()\n                        ->integerNode('redos_threshold')\n                            ->defaultValue(100)\n                            ->min(0)\n                            ->info('Complexity score above which a pattern is flagged as ReDoS risk.')\n                        ->end()\n                    ->end()\n                ->end()\n            ->end();\n\n        return $treeBuilder;\n    }\n}\n",
    "Bridge/Symfony/DependencyInjection/RegexParserExtension.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\DependencyInjection;\n\nuse Symfony\\Component\\Config\\FileLocator;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader;\nuse Symfony\\Component\\HttpKernel\\DependencyInjection\\Extension;\n\n/**\n * Loads and manages configuration for the RegexParser bundle.\n *\n * Purpose: This class is the main entry point for the bundle's integration with\n * Symfony's Dependency Injection (DI) container. Its `load` method is called by\n * the Symfony kernel during the container build process. It is responsible for:\n * 1. Processing the user-defined configuration from `config/packages/regex_parser.yaml`.\n * 2. Loading the necessary service definitions from the `Resources/config` directory.\n * 3. Setting parameters in the DI container based on the processed configuration.\n * 4. Conditionally loading debug-only services (like the Web Profiler collector)\n *    based on the application's environment and configuration.\n */\nclass RegexParserExtension extends Extension\n{\n    /**\n     * Loads the bundle's services and processes its configuration.\n     *\n     * Purpose: This method orchestrates the entire setup of the bundle within the\n     * Symfony DI container. It reads the bundle's configuration, sets container\n     * parameters, and loads the appropriate service definition files. As a contributor,\n     * this is where you would manage the registration of new services or handle new\n     * configuration options.\n     *\n     * @param array<array<string, mixed>> $configs   an array of configuration values from the application's config files\n     * @param ContainerBuilder            $container the DI container builder instance\n     *\n     * @throws \\Exception if the service definition files cannot be loaded\n     */\n    #[\\Override]\n    public function load(array $configs, ContainerBuilder $container): void\n    {\n        // Pass kernel.debug to Configuration for default values\n        $debug = (bool) $container->getParameter('kernel.debug');\n        $configuration = new Configuration($debug);\n\n        /**\n         * @var array{\n         *     enabled: bool,\n         *     max_pattern_length: int,\n         *     cache: string|null,\n         *     analysis: array{\n         *         warning_threshold: int,\n         *         redos_threshold: int,\n         *     },\n         * } $config\n         */\n        $config = $this->processConfiguration($configuration, $configs);\n\n        // If the bundle is disabled entirely, do nothing\n        if (!$config['enabled']) {\n            return;\n        }\n\n        // Set parameters\n        $container->setParameter('regex_parser.max_pattern_length', $config['max_pattern_length']);\n        $container->setParameter('regex_parser.cache', $config['cache']);\n        $container->setParameter('regex_parser.analysis.warning_threshold', $config['analysis']['warning_threshold']);\n        $container->setParameter('regex_parser.analysis.redos_threshold', $config['analysis']['redos_threshold']);\n\n        $loader = new PhpFileLoader($container, new FileLocator(__DIR__.'/../Resources/config'));\n\n        $loader->load('services.php');\n    }\n\n    /**\n     * Returns the alias of the extension.\n     *\n     * Purpose: This alias is used as the root key for the bundle's configuration\n     * in YAML files (e.g., `regex_parser:`). It provides a unique namespace for the\n     * bundle's settings.\n     *\n     * @return string the configuration alias\n     */\n    #[\\Override]\n    public function getAlias(): string\n    {\n        return 'regex_parser';\n    }\n}\n",
    "Stream/TokenStream.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Stream;\n\nuse RegexParser\\Token;\nuse RegexParser\\TokenType;\n\n/**\n * Token stream wrapper around a generator.\n * Provides lookahead capabilities while maintaining memory efficiency.\n * Uses a limited buffer for peeking ahead without loading entire token list.\n */\nfinal class TokenStream\n{\n    /**\n     * Buffer for lookahead tokens.\n     *\n     * @var array<int, Token>\n     */\n    private array $buffer = [];\n\n    /**\n     * History of consumed tokens for rewinding.\n     *\n     * @var array<int, Token>\n     */\n    private array $history = [];\n\n    /**\n     * Current position in the stream.\n     */\n    private int $position = 0;\n\n    /**\n     * Track if generator is exhausted.\n     */\n    private bool $exhausted = false;\n\n    /**\n     * @param \\Generator<int, Token> $generator\n     */\n    public function __construct(private readonly \\Generator $generator)\n    {\n        // Pre-fill buffer with first token\n        $this->fillBuffer(1);\n    }\n\n    /**\n     * Get the current token without advancing.\n     */\n    public function current(): Token\n    {\n        if (!isset($this->buffer[0])) {\n            throw new \\RuntimeException('Token stream is exhausted');\n        }\n\n        return $this->buffer[0];\n    }\n\n    /**\n     * Advance to the next token.\n     */\n    public function next(): void\n    {\n        if (empty($this->buffer)) {\n            throw new \\RuntimeException('Token stream is exhausted');\n        }\n\n        $consumed = array_shift($this->buffer);\n        $this->history[] = $consumed;\n        $this->position++;\n        $this->fillBuffer(1);\n\n        // Keep history limited to avoid memory issues\n        if (\\count($this->history) > 100) {\n            array_shift($this->history);\n        }\n    }\n\n    /**\n     * Rewind the stream by the specified number of tokens.\n     */\n    public function rewind(int $count = 1): void\n    {\n        if ($count < 1) {\n            return;\n        }\n\n        if ($count > \\count($this->history)) {\n            throw new \\RuntimeException(\\sprintf(\n                'Cannot rewind %d tokens, only %d in history',\n                $count,\n                \\count($this->history),\n            ));\n        }\n\n        for ($i = 0; $i < $count; $i++) {\n            $token = array_pop($this->history);\n            if (null !== $token) {\n                array_unshift($this->buffer, $token);\n                $this->position--;\n            }\n        }\n    }\n\n    /**\n     * Set position to an absolute position (for save/restore patterns).\n     */\n    public function setPosition(int $position): void\n    {\n        $diff = $this->position - $position;\n        if ($diff > 0) {\n            $this->rewind($diff);\n        } elseif ($diff < 0) {\n            // Move forward\n            for ($i = 0; $i < -$diff; $i++) {\n                $this->next();\n            }\n        }\n    }\n\n    /**\n     * Peek at a token relative to current position without advancing.\n     * Supports negative offsets to look back at previous tokens.\n     * Returns EOF token if beyond the end of stream or before history.\n     */\n    public function peek(int $offset = 1): Token\n    {\n        if ($offset < 0) {\n            // Look back into history\n            $historyIndex = \\count($this->history) + $offset;\n            if ($historyIndex >= 0 && isset($this->history[$historyIndex])) {\n                return $this->history[$historyIndex];\n            }\n\n            return new Token(TokenType::T_EOF, '', 0);\n        }\n\n        $this->fillBuffer($offset + 1);\n\n        return $this->buffer[$offset] ?? new Token(TokenType::T_EOF, '', $this->position + $offset);\n    }\n\n    /**\n     * Check if stream has more tokens.\n     */\n    public function hasMore(): bool\n    {\n        return !empty($this->buffer);\n    }\n\n    /**\n     * Get current position in stream.\n     */\n    public function getPosition(): int\n    {\n        return $this->position;\n    }\n\n    /**\n     * Fill the buffer with tokens from the generator.\n     */\n    private function fillBuffer(int $minSize): void\n    {\n        if ($this->exhausted || \\count($this->buffer) >= $minSize) {\n            return;\n        }\n\n        while (\\count($this->buffer) < $minSize && $this->generator->valid()) {\n            $this->buffer[] = $this->generator->current();\n            $this->generator->next();\n        }\n\n        if (!$this->generator->valid()) {\n            $this->exhausted = true;\n        }\n    }\n}\n",
    "LiteralSet.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\n/**\n * Represents a set of literal strings extracted from a regex pattern.\n * This object is immutable.\n */\nreadonly class LiteralSet\n{\n    /**\n     * @param array<string> $prefixes Possible starting strings\n     * @param array<string> $suffixes Possible ending strings\n     * @param bool          $complete Whether these literals cover the entire match\n     */\n    public function __construct(\n        public array $prefixes = [],\n        public array $suffixes = [],\n        public bool $complete = false,\n    ) {}\n\n    public static function empty(): self\n    {\n        return new self([], [], false);\n    }\n\n    public static function fromString(string $literal): self\n    {\n        return new self([$literal], [$literal], true);\n    }\n\n    /**\n     * Concatenates this set with another set (Sequence operation).\n     * Logic: A . B\n     */\n    public function concat(self $other): self\n    {\n        // If \"this\" matches nothing (void), result is void.\n        // Note: We don't check if \"other\" is void immediately because \"this\" prefix might still be valid\n        if ($this->isVoid() && empty($this->prefixes)) {\n            return self::empty();\n        }\n\n        // 1. Calculate new Prefixes\n        $newPrefixes = $this->prefixes;\n\n        if ($this->complete) {\n            if (!empty($other->prefixes)) {\n                // Cross product: A is complete, B starts with something known\n                $newPrefixes = $this->crossProduct($this->prefixes, $other->prefixes);\n            }\n            // If B has NO prefixes (unknown start), we KEEP A's prefixes as the start of the sequence\n            // e.g. \"user_\" . \"\\d\" -> prefix is \"user_\"\n        }\n\n        // 2. Calculate new Suffixes\n        $newSuffixes = $other->suffixes;\n\n        if ($other->complete) {\n            if (!empty($this->suffixes)) {\n                $newSuffixes = $this->crossProduct($this->suffixes, $other->suffixes);\n            }\n            // If A is unknown but B is complete, suffix is B (already set above)\n        }\n\n        // 3. Completeness\n        // A sequence is complete only if both parts are complete.\n        $newComplete = $this->complete && $other->complete;\n\n        // If the resulting combined set has no valid prefixes or suffixes, it's empty\n        if (empty($newPrefixes) && empty($newSuffixes)) {\n            return self::empty();\n        }\n\n        return new self($this->deduplicate($newPrefixes), $this->deduplicate($newSuffixes), $newComplete);\n    }\n\n    /**\n     * Unites this set with another set (Alternation operation).\n     * Logic: A | B\n     */\n    public function unite(self $other): self\n    {\n        // Union of prefixes and suffixes\n        $newPrefixes = array_merge($this->prefixes, $other->prefixes);\n        $newSuffixes = array_merge($this->suffixes, $other->suffixes);\n\n        // An alternation is complete only if ALL branches are complete\n        $newComplete = $this->complete && $other->complete;\n\n        return new self($this->deduplicate($newPrefixes), $this->deduplicate($newSuffixes), $newComplete);\n    }\n\n    public function getLongestPrefix(): ?string\n    {\n        return $this->getLongestString($this->prefixes);\n    }\n\n    public function getLongestSuffix(): ?string\n    {\n        return $this->getLongestString($this->suffixes);\n    }\n\n    public function isVoid(): bool\n    {\n        return empty($this->prefixes) && empty($this->suffixes);\n    }\n\n    /**\n     * @param array<string> $left\n     * @param array<string> $right\n     *\n     * @return array<string>\n     */\n    private function crossProduct(array $left, array $right): array\n    {\n        $result = [];\n        foreach ($left as $l) {\n            foreach ($right as $r) {\n                $result[] = $l.$r;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * @param array<string> $items\n     *\n     * @return array<string>\n     */\n    private function deduplicate(array $items): array\n    {\n        return array_values(array_unique($items));\n    }\n\n    /**\n     * @param array<string> $candidates\n     */\n    private function getLongestString(array $candidates): ?string\n    {\n        if (empty($candidates)) {\n            return null;\n        }\n\n        $longest = '';\n        foreach ($candidates as $s) {\n            if (\\strlen($s) > \\strlen($longest)) {\n                $longest = $s;\n            }\n        }\n\n        return '' === $longest && !\\in_array('', $candidates, true) ? null : $longest;\n    }\n}\n",
    "ReDoSSeverity.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nenum ReDoSSeverity: string\n{\n    /**\n     * No significant ReDoS risk detected.\n     * Pattern uses bounded quantifiers or no recursion.\n     */\n    case SAFE = 'safe';\n\n    /**\n     * Low risk. Nested quantifiers exist but are strictly bounded (e.g., (a{1,5}){1,5}).\n     * Linear to polynomial complexity with low constants.\n     */\n    case LOW = 'low';\n\n    /**\n     * Medium risk. Single unbounded quantifiers or very large bounded repetitions.\n     * Potential polynomial time O(n^2).\n     */\n    case MEDIUM = 'medium';\n\n    /**\n     * High risk. Nested unbounded quantifiers detected.\n     * Potential exponential time O(2^n).\n     */\n    case HIGH = 'high';\n\n    /**\n     * Critical risk. Definite catastrophic backtracking detected.\n     * Patterns like (a*)* or overlapping alternations inside loops.\n     */\n    case CRITICAL = 'critical';\n}\n",
    "Lexer.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nuse RegexParser\\Exception\\LexerException;\n\n/**\n * The Lexer (Tokenizer).\n *\n * This implementation uses a high-performance state machine based on PCRE.\n * It consumes tokens using `preg_match` with offsets to avoid memory allocation\n * overhead from substring operations.\n *\n * It preserves all tokens, including comments and quote mode markers, allowing\n * for a full reconstruction of the original pattern (Concrete Syntax Tree).\n */\nfinal class Lexer\n{\n    /**\n     * Regex to capture all possible tokens OUTSIDE of a character class.\n     *\n     * We use Nowdoc syntax (<<<'PCRE') to ensure readability and avoid\n     * the \"backslash hell\" of standard PHP strings.\n     */\n    private const string REGEX_OUTSIDE = <<<'PCRE'\n        /\n          (?<T_COMMENT_OPEN>          \\(\\?\\# )\n        | (?<T_PCRE_VERB>             \\(\\* [^)]+ \\) ) # Ex: (*FAIL), (*MARK:foo)\n        | (?<T_GROUP_MODIFIER_OPEN>   \\(\\? )\n        | (?<T_GROUP_OPEN>            \\( )\n        | (?<T_GROUP_CLOSE>           \\) )\n        | (?<T_CHAR_CLASS_OPEN>       \\[ )\n        | (?<T_QUANTIFIER>            (?: [\\*\\+\\?] | \\{\\d+(?:,\\d*)?\\} ) [\\?\\+]? )\n        | (?<T_ALTERNATION>           \\| )\n        | (?<T_DOT>                   \\. )\n        | (?<T_ANCHOR>                \\^ | \\$ )\n        \n        # Escaped sequences (must precede T_LITERAL)\n        | (?<T_ASSERTION>             \\\\ [AzZGbB] )\n        | (?<T_KEEP>                  \\\\ K )\n        | (?<T_CHAR_TYPE>             \\\\ [dswDSWhvR] )\n        | (?<T_G_REFERENCE>           \\\\ g (?: \\{[a-zA-Z0-9_+-]+\\} | <[a-zA-Z0-9_]+> | [0-9+-]+ )? )\n        | (?<T_BACKREF>               \\\\ (?: k(?:<[a-zA-Z0-9_]+> | \\{[a-zA-Z0-9_]+\\}) | (?<v_backref_num> [1-9]\\d*) ) )\n        | (?<T_OCTAL_LEGACY>          \\\\ 0[0-7]{0,2} )\n        | (?<T_OCTAL>                 \\\\ o\\{[0-7]+\\} )\n        | (?<T_UNICODE>               \\\\ x (?: [0-9a-fA-F]{2} | \\{[0-9a-fA-F]+\\} ) | \\\\ u\\{[0-9a-fA-F]+\\} )\n        | (?<T_UNICODE_PROP>          \\\\ [pP] (?: \\{ (?<v1_prop> \\^? [a-zA-Z0-9_]+) \\} | (?<v2_prop> [a-zA-Z]) ) )\n        | (?<T_QUOTE_MODE_START>      \\\\ Q )\n        | (?<T_QUOTE_MODE_END>        \\\\ E )\n        | (?<T_LITERAL_ESCAPED>       \\\\ . ) # Any other escaped char (e.g. \\., \\*)\n        \n        # Must be last: Match any single character that wasn't matched above.\n        | (?<T_LITERAL>               [^\\\\\\\\] )\n        /xsuA\n        PCRE;\n\n    /**\n     * Regex to capture tokens INSIDE a character class.\n     */\n    private const string REGEX_INSIDE = <<<'PCRE'\n        /\n          (?<T_CHAR_CLASS_CLOSE> \\] )\n        | (?<T_POSIX_CLASS>      \\[ \\: (?<v_posix> \\^? [a-zA-Z]+) \\: \\] )\n        \n        # Escaped sequences\n        | (?<T_CHAR_TYPE>        \\\\ [dswDSWhvR] )\n        | (?<T_OCTAL_LEGACY>     \\\\ 0[0-7]{0,2} )\n        | (?<T_OCTAL>            \\\\ o\\{[0-7]+\\} )\n        | (?<T_UNICODE>          \\\\ x (?: [0-9a-fA-F]{2} | \\{[0-9a-fA-F]+\\} ) | \\\\ u\\{[0-9a-fA-F]+\\} )\n        | (?<T_UNICODE_PROP>     \\\\ [pP] (?: \\{ (?<v1_prop> \\^? [a-zA-Z0-9_]+) \\} | (?<v2_prop> [a-zA-Z]) ) )\n        | (?<T_QUOTE_MODE_START> \\\\ Q )\n        | (?<T_LITERAL_ESCAPED>  \\\\ . ) # Includes escaped ], -, ^\n        \n        # Must be last: Match any single character that wasn't matched above.\n        | (?<T_LITERAL>          [^\\\\\\\\] )\n        /xsuA\n        PCRE;\n\n    /**\n     * Token priority list for the 'outside' state.\n     * Maps regex group names to token types.\n     */\n    private const array TOKENS_OUTSIDE = [\n        'T_COMMENT_OPEN',\n        'T_PCRE_VERB',\n        'T_GROUP_MODIFIER_OPEN',\n        'T_GROUP_OPEN',\n        'T_GROUP_CLOSE',\n        'T_CHAR_CLASS_OPEN',\n        'T_QUANTIFIER',\n        'T_ALTERNATION',\n        'T_DOT',\n        'T_ANCHOR',\n        'T_ASSERTION',\n        'T_KEEP',\n        'T_CHAR_TYPE',\n        'T_G_REFERENCE',\n        'T_BACKREF',\n        'T_OCTAL_LEGACY',\n        'T_OCTAL',\n        'T_UNICODE',\n        'T_UNICODE_PROP',\n        'T_QUOTE_MODE_START',\n        'T_QUOTE_MODE_END',\n        'T_LITERAL_ESCAPED',\n        'T_LITERAL',\n    ];\n\n    /**\n     * Token priority list for the 'inside' state.\n     */\n    private const array TOKENS_INSIDE = [\n        'T_CHAR_CLASS_CLOSE',\n        'T_POSIX_CLASS',\n        'T_CHAR_TYPE',\n        'T_OCTAL_LEGACY',\n        'T_OCTAL',\n        'T_UNICODE',\n        'T_UNICODE_PROP',\n        'T_QUOTE_MODE_START',\n        'T_LITERAL_ESCAPED',\n        'T_LITERAL',\n    ];\n\n    private string $pattern;\n\n    private int $position = 0;\n\n    private int $length = 0;\n\n    // State flags\n    private bool $inCharClass = false;\n\n    private bool $inQuoteMode = false;\n\n    private bool $inCommentMode = false;\n\n    /**\n     * @var int Marks the start of the current character class to handle special placement rules (e.g., ']' at start).\n     */\n    private int $charClassStartPosition = 0;\n\n    public function __construct(string $pattern)\n    {\n        $this->reset($pattern);\n    }\n\n    /**\n     * Resets the lexer with a new pattern string.\n     *\n     * @throws LexerException if the input is not valid UTF-8\n     */\n    public function reset(string $pattern): void\n    {\n        if (!mb_check_encoding($pattern, 'UTF-8')) {\n            throw new LexerException('Input string is not valid UTF-8.');\n        }\n\n        $this->pattern = $pattern;\n        // Use strlen (bytes) for preg_match cursor logic, as the 'u' modifier handles UTF-8 matching naturally.\n        $this->length = \\strlen($this->pattern);\n\n        // Reset state\n        $this->position = 0;\n        $this->inCharClass = false;\n        $this->inQuoteMode = false;\n        $this->inCommentMode = false;\n        $this->charClassStartPosition = 0;\n    }\n\n    /**\n     * Tokenizes the pattern and returns all tokens as an array.\n     * For memory efficiency with large patterns, use tokenize() generator.\n     *\n     * @throws LexerException\n     *\n     * @return list<Token>\n     */\n    public function tokenizeToArray(): array\n    {\n        return iterator_to_array($this->tokenize(), false);\n    }\n\n    /**\n     * Tokenizes the pattern using a generator for memory efficiency.\n     * Yields tokens one at a time instead of building a large array.\n     *\n     * @throws LexerException\n     *\n     * @return \\Generator<int, Token>\n     */\n    public function tokenize(): \\Generator\n    {\n        $tokens = [];\n\n        while ($this->position < $this->length) {\n            // 1. Handle \"Tunnel\" Modes (Quote & Comment)\n            if ($this->inQuoteMode) {\n                if ($token = $this->consumeQuoteMode()) {\n                    yield $token;\n                    $tokens[] = $token; // Keep for context\n                }\n\n                continue;\n            }\n\n            if ($this->inCommentMode) {\n                if ($token = $this->consumeCommentMode()) {\n                    yield $token;\n                    $tokens[] = $token; // Keep for context\n                }\n\n                continue;\n            }\n\n            // 2. Select Context-Aware Regex\n            $regex = $this->inCharClass ? self::REGEX_INSIDE : self::REGEX_OUTSIDE;\n            $tokenMap = $this->inCharClass ? self::TOKENS_INSIDE : self::TOKENS_OUTSIDE;\n\n            // 3. Execute Matching\n            $result = preg_match($regex, $this->pattern, $matches, \\PREG_UNMATCHED_AS_NULL, $this->position);\n\n            if (false === $result) {\n                throw new LexerException(\\sprintf('PCRE Error during tokenization: %s', preg_last_error_msg()));\n            }\n\n            if (0 === $result) {\n                $context = mb_substr($this->pattern, $this->position, 10);\n\n                throw new LexerException(\\sprintf('Unable to tokenize pattern at position %d. Context: \"%s...\"', $this->position, $context));\n            }\n\n            /** @var string $matchedValue */\n            $matchedValue = $matches[0];\n            $startPos = $this->position;\n            $this->position += \\strlen($matchedValue);\n\n            // 4. Create Token from Match and yield it\n            $token = $this->createTokenFromMatch($tokenMap, $matches, $matchedValue, $startPos, $tokens);\n            yield $token;\n            $tokens[] = $token;\n        }\n\n        // 5. Post-Processing Validation\n        if ($this->inCharClass) {\n            throw new LexerException('Unclosed character class \"]\" at end of input.');\n        }\n\n        if ($this->inCommentMode) {\n            throw new LexerException('Unclosed comment \")\" at end of input.');\n        }\n\n        // Yield EOF token to signal parsing completion\n        yield new Token(TokenType::T_EOF, '', $this->position);\n    }\n\n    /**\n     * Identifies which token type matched and creates the Token object.\n     * Handles complex state transitions (e.g., entering char classes).\n     *\n     * @param array<string>                  $tokenMap\n     * @param array<int|string, string|null> $matches\n     * @param list<Token>                    $currentTokens\n     */\n    private function createTokenFromMatch(array $tokenMap, array $matches, string $matchedValue, int $startPos, array $currentTokens): Token\n    {\n        foreach ($tokenMap as $tokenName) {\n            if (isset($matches[$tokenName])) {\n                $type = TokenType::from(strtolower(substr($tokenName, 2)));\n\n                // --- State Transition Logic ---\n\n                if (TokenType::T_CHAR_CLASS_OPEN === $type) {\n                    $this->inCharClass = true;\n                    $this->charClassStartPosition = $startPos;\n\n                    return new Token($type, '[', $startPos);\n                }\n\n                if (TokenType::T_CHAR_CLASS_CLOSE === $type) {\n                    // Edge Case: ']' immediately after '[' or '[^' is treated as a literal ']'\n                    $lastToken = end($currentTokens);\n                    $isAtStart = ($startPos === $this->charClassStartPosition + 1)\n                        || ($startPos === $this->charClassStartPosition + 2 && $lastToken && TokenType::T_NEGATION === $lastToken->type);\n\n                    if ($isAtStart) {\n                        return new Token(TokenType::T_LITERAL, ']', $startPos);\n                    }\n                    $this->inCharClass = false;\n\n                    return new Token($type, ']', $startPos);\n                }\n\n                if (TokenType::T_COMMENT_OPEN === $type) {\n                    $this->inCommentMode = true;\n\n                    return new Token($type, '(?#', $startPos);\n                }\n\n                if (TokenType::T_QUOTE_MODE_START === $type) {\n                    $this->inQuoteMode = true;\n\n                    // We emit the token so the Parser knows \\Q was here (Full Fidelity)\n                    return new Token($type, '\\Q', $startPos);\n                }\n\n                // --- Context-Sensitive Token Logic ---\n\n                if ($this->inCharClass) {\n                    $lastToken = end($currentTokens);\n                    $isAtStart = ($startPos === $this->charClassStartPosition + 1)\n                        || ($startPos === $this->charClassStartPosition + 2 && $lastToken && TokenType::T_NEGATION === $lastToken->type);\n\n                    // '^' is only T_NEGATION at the very start of the class\n                    if (TokenType::T_LITERAL === $type && '^' === $matchedValue && $isAtStart) {\n                        return new Token(TokenType::T_NEGATION, '^', $startPos);\n                    }\n                    // '-' is only T_RANGE if NOT at the start of the class\n                    if (TokenType::T_LITERAL === $type && '-' === $matchedValue && !$isAtStart) {\n                        return new Token(TokenType::T_RANGE, '-', $startPos);\n                    }\n                }\n\n                // --- Standard Value Extraction ---\n                $value = $this->extractTokenValue($type, $matchedValue, $matches);\n\n                return new Token($type, $value, $startPos);\n            }\n        }\n\n        // Should be unreachable\n        throw new LexerException(\\sprintf('Lexer internal error: No known token matched at position %d.', $startPos));\n    }\n\n    /**\n     * Consumes content inside \\Q...\\E.\n     * Returns T_LITERAL for content, or T_QUOTE_MODE_END for \\E.\n     */\n    private function consumeQuoteMode(): ?Token\n    {\n        // Search for \\E or End of String\n        if (!preg_match('/(.*?)((?:\\\\\\\\E)|$)/suA', $this->pattern, $matches, \\PREG_UNMATCHED_AS_NULL, $this->position)) {\n            // Fallback: if parsing fails completely (unlikely), verify strict safety by resetting.\n            $this->inQuoteMode = false;\n            $this->position = $this->length;\n\n            return null;\n        }\n\n        $literalText = $matches[1];\n        $endSequence = $matches[2];\n        $startPos = $this->position;\n\n        // 1. If there is content before \\E, return it as a Literal\n        if ('' !== $literalText) {\n            $this->position += \\strlen($literalText);\n\n            return new Token(TokenType::T_LITERAL, $literalText, $startPos);\n        }\n\n        // 2. If we hit \\E, return the end token and exit quote mode\n        if ('\\E' === $endSequence) {\n            $this->inQuoteMode = false;\n            $token = new Token(TokenType::T_QUOTE_MODE_END, '\\E', $this->position);\n            $this->position += 2; // Skip \\E\n\n            return $token;\n        }\n\n        // 3. End of string reached (PCRE allows unclosed \\Q, it extends to EOF)\n        $this->position = $this->length;\n\n        // Note: We stay inQuoteMode logically until EOF, effectively behaving as literals.\n        return null;\n    }\n\n    /**\n     * Consumes content inside (?#...).\n     * Returns T_LITERAL for content, or T_GROUP_CLOSE for ).\n     */\n    private function consumeCommentMode(): ?Token\n    {\n        // Search for ) or End of String\n        if (!preg_match('/(.*?)(\\)|$)/suA', $this->pattern, $matches, \\PREG_UNMATCHED_AS_NULL, $this->position)) {\n            $this->inCommentMode = false;\n            $this->position = $this->length;\n\n            return null;\n        }\n\n        $commentText = $matches[1];\n        $endSequence = $matches[2];\n        $startPos = $this->position;\n\n        // 1. If there is text, return it as Literal content\n        if ('' !== $commentText) {\n            $this->position += \\strlen($commentText);\n\n            return new Token(TokenType::T_LITERAL, $commentText, $startPos);\n        }\n\n        // 2. If we hit ), return close token and exit comment mode\n        if (')' === $endSequence) {\n            $this->inCommentMode = false;\n            $token = new Token(TokenType::T_GROUP_CLOSE, ')', $this->position);\n            $this->position++;\n\n            return $token;\n        }\n\n        // 3. End of string reached (Error will be thrown by main loop checks)\n        $this->position = $this->length;\n\n        return null;\n    }\n\n    /**\n     * Extracts and normalizes the value of a token.\n     * Handles escape sequences like \\n, \\t, \\xHH, etc.\n     *\n     * @param array<int|string, string|null> $matches\n     */\n    private function extractTokenValue(TokenType $type, string $matchedValue, array $matches): string\n    {\n        return match ($type) {\n            TokenType::T_LITERAL_ESCAPED => match (substr($matchedValue, 1)) {\n                't' => \"\\t\",\n                'n' => \"\\n\",\n                'r' => \"\\r\",\n                'f' => \"\\f\",\n                'v' => \"\\v\",\n                'e' => \"\\x1B\", // Escape char (0x1B)\n                'a' => \"\\x07\", // Bell/Alarm char (0x07)\n                default => substr($matchedValue, 1),\n            },\n            TokenType::T_PCRE_VERB => substr($matchedValue, 2, -1),\n            TokenType::T_ASSERTION,\n            TokenType::T_CHAR_TYPE,\n            TokenType::T_KEEP => substr($matchedValue, 1),\n            TokenType::T_BACKREF => $matches['v_backref_num'] ?? $matchedValue,\n            TokenType::T_OCTAL_LEGACY => substr($matchedValue, 1),\n            TokenType::T_POSIX_CLASS => $matches['v_posix'] ?? '',\n            TokenType::T_UNICODE_PROP => $this->normalizeUnicodeProp($matchedValue, $matches),\n            default => $matchedValue,\n        };\n    }\n\n    /**\n     * Normalizes Unicode property notation to standard PCRE format.\n     * Examples:\n     * - \\p{L}  -> L\n     * - \\P{L}  -> ^L (Negated)\n     * - \\P{^L} -> L  (Double negation)\n     *\n     * @param array<int|string, string|null> $matches\n     */\n    private function normalizeUnicodeProp(string $matchedValue, array $matches): string\n    {\n        $prop = $matches['v1_prop'] ?? $matches['v2_prop'] ?? '';\n        $isUppercaseP = str_starts_with($matchedValue, '\\\\P');\n\n        if ($isUppercaseP) {\n            // Handle double negation: \\P{^...} becomes ...\n            if (str_starts_with($prop, '^')) {\n                return substr($prop, 1);\n            }\n\n            // Handle single negation: \\P{...} becomes ^...\n            return '^'.$prop;\n        }\n\n        return $prop;\n    }\n}\n",
    "ReDoSAnalysis.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\nreadonly class ReDoSAnalysis\n{\n    /**\n     * @param array<string> $recommendations\n     */\n    public function __construct(\n        public ReDoSSeverity $severity,\n        public int $score,\n        public ?string $vulnerablePart = null,\n        public array $recommendations = [],\n    ) {}\n\n    public function isSafe(): bool\n    {\n        return ReDoSSeverity::SAFE === $this->severity || ReDoSSeverity::LOW === $this->severity;\n    }\n}\n",
    "ParserOptions.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser;\n\n/**\n * Configuration options for the Parser.\n * Provides resource limits and constraints to prevent DoS attacks.\n *\n * Immutable Data Transfer Object following the Rust `regex-syntax` standard\n * for resource management and security.\n */\nfinal readonly class ParserOptions\n{\n    /**\n     * Create parser options with default values.\n     *\n     * @param int $maxPatternLength  Maximum pattern length (default: 10,000)\n     * @param int $maxNodes          Maximum number of AST nodes (default: 10,000)\n     * @param int $maxRecursionDepth Maximum recursion depth (default: 250)\n     */\n    public function __construct(\n        public int $maxPatternLength = 10_000,\n        public int $maxNodes = 10_000,\n        public int $maxRecursionDepth = 250\n    ) {}\n\n    /**\n     * Create options from an array configuration.\n     *\n     * @param array{\n     *     max_pattern_length?: int,\n     *     max_nodes?: int,\n     *     max_recursion_depth?: int,\n     * } $config\n     */\n    public static function fromArray(array $config): self\n    {\n        return new self(\n            maxPatternLength: (int) ($config['max_pattern_length'] ?? 10_000),\n            maxNodes: (int) ($config['max_nodes'] ?? 10_000),\n            maxRecursionDepth: (int) ($config['max_recursion_depth'] ?? 250),\n        );\n    }\n}\n",
    "Node/ConditionalNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass ConditionalNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly NodeInterface $condition,\n        public readonly NodeInterface $yes,\n        public readonly NodeInterface $no,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitConditional($this);\n    }\n}\n",
    "Node/AnchorNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents an anchor (e.g., \"^\" or \"$\").\n */\nclass AnchorNode extends AbstractNode\n{\n    /**\n     * @param string $value    the anchor character (\"^\" or \"$\")\n     * @param int    $startPos The 0-based start offset\n     * @param int    $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $value,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitAnchor($this);\n    }\n}\n",
    "Node/UnicodePropNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass UnicodePropNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $prop,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitUnicodeProp($this);\n    }\n}\n",
    "Node/PosixClassNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass PosixClassNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $class,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitPosixClass($this);\n    }\n}\n",
    "Node/DefineNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass DefineNode implements NodeInterface\n{\n    /**\n     * @param NodeInterface $content // tout ce qui est  l'intrieur du (?(DEFINE) ... )\n     */\n    public function __construct(\n        public readonly NodeInterface $content,\n        public readonly int $startPos,\n        public readonly int $endPos,\n    ) {}\n\n    public function accept(NodeVisitorInterface $visitor): mixed\n    {\n        return $visitor->visitDefine($this);\n    }\n\n    public function getStartPosition(): int\n    {\n        return $this->startPos;\n    }\n\n    public function getEndPosition(): int\n    {\n        return $this->endPos;\n    }\n}\n",
    "Node/RangeNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a range inside a character class (e.g., \"a-z\").\n */\nclass RangeNode extends AbstractNode\n{\n    /**\n     * @param NodeInterface $start    the start of the range (LiteralNode or CharTypeNode)\n     * @param NodeInterface $end      the end of the range (LiteralNode or CharTypeNode)\n     * @param int           $startPos The 0-based start offset\n     * @param int           $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly NodeInterface $start,\n        public readonly NodeInterface $end,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitRange($this);\n    }\n}\n",
    "Node/CommentNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass CommentNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $comment,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitComment($this);\n    }\n}\n",
    "Node/CharTypeNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents an escaped character class type (e.g., \"\\d\", \"\\s\", \"\\W\").\n */\nclass CharTypeNode extends AbstractNode\n{\n    /**\n     * @param string $value    The character type (e.g., \"d\", \"s\", \"W\").\n     * @param int    $startPos The 0-based start offset\n     * @param int    $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $value,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitCharType($this);\n    }\n}\n",
    "Node/QuantifierType.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\n/**\n * Defines the \"greediness\" of a quantifier.\n */\nenum QuantifierType: string\n{\n    /** Greedy (e.g., \"*\", \"+\"). */\n    case T_GREEDY = 'greedy';\n\n    /** Lazy (non-greedy) (e.g., \"*?\", \"+?\"). */\n    case T_LAZY = 'lazy';\n\n    /** Possessive (e.g., \"*+\", \"++\"). */\n    case T_POSSESSIVE = 'possessive';\n}\n",
    "Node/SequenceNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a sequence (concatenation) of nodes.\n * Ex: \"abc\" is Sequence(Literal(a), Literal(b), Literal(c)).\n */\nclass SequenceNode extends AbstractNode\n{\n    /**\n     * @param array<NodeInterface> $children the nodes in the sequence\n     * @param int                  $startPos The 0-based start offset\n     * @param int                  $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly array $children,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitSequence($this);\n    }\n}\n",
    "Node/DotNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents the dot \".\" wildcard character.\n */\nclass DotNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitDot($this);\n    }\n}\n",
    "Node/OctalNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass OctalNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $code,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitOctal($this);\n    }\n}\n",
    "Node/GroupNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a group (e.g., \"(...)\", \"(?:...)\", \"(?<name>...)\").\n */\nclass GroupNode extends AbstractNode\n{\n    /**\n     * @param NodeInterface $child    the expression contained within the group\n     * @param GroupType     $type     The semantic type of the group\n     * @param ?string       $name     The name, if it's a named group\n     * @param ?string       $flags    Inline flags for (?i:...)\n     * @param int           $startPos The 0-based start offset\n     * @param int           $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly NodeInterface $child,\n        public readonly GroupType $type,\n        public readonly ?string $name = null,\n        public readonly ?string $flags = null,\n        int $startPos = 0,\n        int $endPos = 0,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitGroup($this);\n    }\n}\n",
    "Node/AbstractNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\n/**\n * Base class for all AST nodes.\n * Implements the NodeInterface and provides shared position logic.\n */\nabstract class AbstractNode implements NodeInterface\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly int $startPos,\n        public readonly int $endPos,\n    ) {}\n\n    public function getStartPosition(): int\n    {\n        return $this->startPos;\n    }\n\n    public function getEndPosition(): int\n    {\n        return $this->endPos;\n    }\n}\n",
    "Node/BackrefNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass BackrefNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $ref,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitBackref($this);\n    }\n}\n",
    "Node/CharClassNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a character class (e.g., \"[a-z]\", \"[^0-9]\").\n */\nclass CharClassNode extends AbstractNode\n{\n    /**\n     * @param array<NodeInterface> $parts     the parts of the class (LiteralNode, CharTypeNode, RangeNode)\n     * @param bool                 $isNegated Whether the class is negated (e.g., '[^...]')\n     * @param int                  $startPos  The 0-based start offset\n     * @param int                  $endPos    The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly array $parts,\n        public readonly bool $isNegated,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitCharClass($this);\n    }\n}\n",
    "Node/SubroutineNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a subroutine call (e.g., \"(?R)\", \"(?1)\", \"(?&name)\", \"(?P>name)\").\n */\nclass SubroutineNode extends AbstractNode\n{\n    /**\n     * @param string $reference The group reference (e.g., \"R\", \"0\", \"1\", \"name\").\n     * @param string $syntax    The original syntax (e.g., \"&\", \"P>\", \"g\", \"\").\n     * @param int    $startPos  The 0-based start offset\n     * @param int    $endPos    The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $reference,\n        public readonly string $syntax,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitSubroutine($this);\n    }\n}\n",
    "Node/AlternationNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents an alternation (e.g., \"a|b\").\n */\nclass AlternationNode extends AbstractNode\n{\n    /**\n     * @param array<NodeInterface> $alternatives the nodes in the alternation\n     * @param int                  $startPos     The 0-based start offset\n     * @param int                  $endPos       The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly array $alternatives,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitAlternation($this);\n    }\n}\n",
    "Node/LiteralNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a literal character (e.g., \"a\", \"1\", or an escaped \"\\*\").\n */\nclass LiteralNode extends AbstractNode\n{\n    /**\n     * @param string $value    the literal character\n     * @param int    $startPos The 0-based start offset\n     * @param int    $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $value,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitLiteral($this);\n    }\n}\n",
    "Node/PcreVerbNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a PCRE verb (e.g., \"(*FAIL)\", \"(*COMMIT)\").\n */\nclass PcreVerbNode extends AbstractNode\n{\n    /**\n     * @param string $verb     The verb name (e.g., \"FAIL\", \"COMMIT\")\n     * @param int    $startPos The 0-based start offset\n     * @param int    $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $verb,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitPcreVerb($this);\n    }\n}\n",
    "Node/QuantifierNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a quantifier (e.g., \"*\", \"+\", \"{1,3}\").\n */\nclass QuantifierNode extends AbstractNode\n{\n    /**\n     * @param NodeInterface  $node       the node to be quantified\n     * @param string         $quantifier The quantifier string (e.g., \"*\", \"{1,3}\").\n     * @param QuantifierType $type       The type of quantifier (greedy, lazy, possessive)\n     * @param int            $startPos   The 0-based start offset\n     * @param int            $endPos     The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly NodeInterface $node,\n        public readonly string $quantifier,\n        public readonly QuantifierType $type,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitQuantifier($this);\n    }\n}\n",
    "Node/RegexNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents the root of a parsed regex, containing the pattern and any flags.\n */\nclass RegexNode extends AbstractNode\n{\n    /**\n     * @param NodeInterface $pattern   The root node of the regex pattern (e.g., an AlternationNode or SequenceNode).\n     * @param string        $flags     A string of flags (e.g., \"imsU\").\n     * @param string        $delimiter The opening delimiter (e.g., \"/\", \"~\", \"(\").\n     * @param int           $startPos  The 0-based start offset\n     * @param int           $endPos    The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly NodeInterface $pattern,\n        public readonly string $flags,\n        public readonly string $delimiter,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitRegex($this);\n    }\n}\n",
    "Node/AssertionNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents an assertion (e.g., \\b, \\A).\n */\nclass AssertionNode extends AbstractNode\n{\n    /**\n     * @param string $value    the assertion character (\\b, \\A, etc.)\n     * @param int    $startPos The 0-based start offset\n     * @param int    $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $value,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitAssertion($this);\n    }\n}\n",
    "Node/KeepNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents the \\K \"keep\" assertion.\n */\nclass KeepNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    /**\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitKeep($this);\n    }\n}\n",
    "Node/OctalLegacyNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Represents a legacy octal escape (e.g., \\0, \\01, \\012).\n */\nclass OctalLegacyNode extends AbstractNode\n{\n    /**\n     * @param string $code     The octal code (e.g., \"0\", \"01\", \"012\")\n     * @param int    $startPos The 0-based start offset\n     * @param int    $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $code,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitOctalLegacy($this);\n    }\n}\n",
    "Node/NodeInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\n/**\n * Base interface for all AST nodes.\n */\ninterface NodeInterface\n{\n    /**\n     * Accepts a visitor.\n     *\n     * @template T\n     *\n     * @param NodeVisitorInterface<T> $visitor\n     *\n     * @return T\n     */\n    public function accept(NodeVisitorInterface $visitor);\n\n    /**\n     * Gets the 0-based start offset of the node in the original pattern string.\n     */\n    public function getStartPosition(): int;\n\n    /**\n     * Gets the 0-based end offset (exclusive) of the node in the original pattern string.\n     */\n    public function getEndPosition(): int;\n}\n",
    "Node/UnicodeNode.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\nuse RegexParser\\NodeVisitor\\NodeVisitorInterface;\n\nclass UnicodeNode extends AbstractNode\n{\n    /**\n     * @param int $startPos The 0-based start offset\n     * @param int $endPos   The 0-based end offset (exclusive)\n     */\n    public function __construct(\n        public readonly string $code,\n        int $startPos,\n        int $endPos,\n    ) {\n        parent::__construct($startPos, $endPos);\n    }\n\n    public function accept(NodeVisitorInterface $visitor)\n    {\n        return $visitor->visitUnicode($this);\n    }\n}\n",
    "Node/NodeRegistry.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\n/**\n * Registry of all AST Node types with metadata and PCRE feature mappings.\n *\n * This registry provides a central source of truth for:\n * - All available Node types in the library\n * - PCRE features each Node represents\n * - Node hierarchy and relationships\n * - Usage examples and documentation\n */\nfinal class NodeRegistry\n{\n    /**\n     * Complete list of all AST Node classes with metadata.\n     *\n     * @return array<string, array{\n     *     class: class-string,\n     *     pcre_feature: string,\n     *     description: string,\n     *     examples: array<string>,\n     *     parent: class-string|null,\n     *     children: array<string>\n     * }>\n     */\n    public static function getAllNodes(): array\n    {\n        return [\n            'regex' => [\n                'class' => RegexNode::class,\n                'pcre_feature' => 'Root Pattern',\n                'description' => 'Root node representing the entire regex pattern with flags',\n                'examples' => ['/test/i', '/\\d+/u', '/pattern/xms'],\n                'parent' => null,\n                'children' => ['pattern' => 'SequenceNode|AlternationNode|...'],\n            ],\n\n            'alternation' => [\n                'class' => AlternationNode::class,\n                'pcre_feature' => 'Alternation',\n                'description' => 'Represents alternation (OR) between multiple alternatives',\n                'examples' => ['foo|bar', 'test|testing', 'a|b|c'],\n                'parent' => AbstractNode::class,\n                'children' => ['alternatives' => 'array<NodeInterface>'],\n            ],\n\n            'sequence' => [\n                'class' => SequenceNode::class,\n                'pcre_feature' => 'Sequence/Concatenation',\n                'description' => 'Represents a sequence of nodes that match in order',\n                'examples' => ['abc', 'test123', '\\d+\\w+'],\n                'parent' => AbstractNode::class,\n                'children' => ['children' => 'array<NodeInterface>'],\n            ],\n\n            'group' => [\n                'class' => GroupNode::class,\n                'pcre_feature' => 'Groups (All Types)',\n                'description' => 'Represents grouping constructs - capturing, non-capturing, atomic, lookarounds, etc.',\n                'examples' => [\n                    '(test)' => 'Capturing',\n                    '(?:test)' => 'Non-capturing',\n                    '(?>test)' => 'Atomic',\n                    '(?=test)' => 'Lookahead',\n                    '(?<=test)' => 'Lookbehind',\n                    '(?<name>test)' => 'Named',\n                    '(?|a|b)' => 'Branch reset',\n                ],\n                'parent' => AbstractNode::class,\n                'children' => ['child' => 'NodeInterface', 'type' => 'GroupType'],\n            ],\n\n            'quantifier' => [\n                'class' => QuantifierNode::class,\n                'pcre_feature' => 'Quantifiers',\n                'description' => 'Represents repetition quantifiers - greedy, lazy, and possessive',\n                'examples' => [\n                    '*' => 'Greedy 0+',\n                    '+' => 'Greedy 1+',\n                    '?' => 'Greedy 0-1',\n                    '*?' => 'Lazy 0+',\n                    '++' => 'Possessive 1+',\n                    '{2,5}' => 'Range',\n                    '{3}+' => 'Possessive exact',\n                ],\n                'parent' => AbstractNode::class,\n                'children' => ['node' => 'NodeInterface', 'type' => 'QuantifierType'],\n            ],\n\n            'literal' => [\n                'class' => LiteralNode::class,\n                'pcre_feature' => 'Literal Characters',\n                'description' => 'Represents literal characters that match themselves',\n                'examples' => ['a', 'test', '123', '\\*', '\\.'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'char_class' => [\n                'class' => CharClassNode::class,\n                'pcre_feature' => 'Character Classes',\n                'description' => 'Represents character classes (positive or negated)',\n                'examples' => ['[abc]', '[^0-9]', '[a-zA-Z]', '[\\d\\w]'],\n                'parent' => AbstractNode::class,\n                'children' => ['ranges' => 'array<NodeInterface>'],\n            ],\n\n            'range' => [\n                'class' => RangeNode::class,\n                'pcre_feature' => 'Character Ranges',\n                'description' => 'Represents a range within a character class',\n                'examples' => ['a-z', '0-9', 'A-F'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'char_type' => [\n                'class' => CharTypeNode::class,\n                'pcre_feature' => 'Character Types/Escapes',\n                'description' => 'Represents escaped character classes',\n                'examples' => ['\\d', '\\D', '\\w', '\\W', '\\s', '\\S', '\\h', '\\H', '\\v', '\\V', '\\R'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'dot' => [\n                'class' => DotNode::class,\n                'pcre_feature' => 'Dot (Wildcard)',\n                'description' => 'Represents the dot metacharacter matching any character',\n                'examples' => ['.'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'anchor' => [\n                'class' => AnchorNode::class,\n                'pcre_feature' => 'Anchors',\n                'description' => 'Represents position anchors',\n                'examples' => ['^', '$', '\\A', '\\Z', '\\z'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'assertion' => [\n                'class' => AssertionNode::class,\n                'pcre_feature' => 'Assertions',\n                'description' => 'Represents zero-width assertions',\n                'examples' => ['\\b', '\\B', '\\G'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'backref' => [\n                'class' => BackrefNode::class,\n                'pcre_feature' => 'Backreferences',\n                'description' => 'Represents backreferences to captured groups',\n                'examples' => ['\\1', '\\2', '\\k<name>', '(?P=name)'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'subroutine' => [\n                'class' => SubroutineNode::class,\n                'pcre_feature' => 'Subroutines/Recursion',\n                'description' => 'Represents subroutine calls and recursion',\n                'examples' => ['(?R)', '(?1)', '(?&name)', '(?P>name)'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'conditional' => [\n                'class' => ConditionalNode::class,\n                'pcre_feature' => 'Conditional Patterns',\n                'description' => 'Represents conditional matching based on conditions',\n                'examples' => ['(?(1)yes|no)', '(?(?=test)a|b)', '(?(DEFINE)...)'],\n                'parent' => AbstractNode::class,\n                'children' => ['condition' => 'NodeInterface|string|int', 'yes' => 'NodeInterface', 'no' => 'NodeInterface|null'],\n            ],\n\n            'unicode' => [\n                'class' => UnicodeNode::class,\n                'pcre_feature' => 'Unicode Escapes',\n                'description' => 'Represents Unicode character escapes',\n                'examples' => ['\\x{1234}', '\\u{10FFFF}', '\\x41'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'unicode_prop' => [\n                'class' => UnicodePropNode::class,\n                'pcre_feature' => 'Unicode Properties',\n                'description' => 'Represents Unicode property escapes',\n                'examples' => ['\\p{L}', '\\p{Nd}', '\\P{Sc}', '\\p{Greek}', '\\p{Lu}'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'posix_class' => [\n                'class' => PosixClassNode::class,\n                'pcre_feature' => 'POSIX Character Classes',\n                'description' => 'Represents POSIX character classes',\n                'examples' => ['[:alpha:]', '[:digit:]', '[:alnum:]', '[:space:]'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'comment' => [\n                'class' => CommentNode::class,\n                'pcre_feature' => 'Comments',\n                'description' => 'Represents inline comments in patterns',\n                'examples' => ['(?#comment)', '(?#this is ignored)'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'pcre_verb' => [\n                'class' => PcreVerbNode::class,\n                'pcre_feature' => 'PCRE Verbs',\n                'description' => 'Represents PCRE control verbs',\n                'examples' => ['(*FAIL)', '(*ACCEPT)', '(*COMMIT)', '(*SKIP)', '(*PRUNE)', '(*THEN)', '(*MARK:label)', '(*UTF8)', '(*UCP)'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'keep' => [\n                'class' => KeepNode::class,\n                'pcre_feature' => 'Keep Assertion',\n                'description' => 'Represents the \\K keep assertion (reset match start)',\n                'examples' => ['\\K'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'octal' => [\n                'class' => OctalNode::class,\n                'pcre_feature' => 'Octal Escapes',\n                'description' => 'Represents octal character escapes',\n                'examples' => ['\\o{377}', '\\101'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n\n            'octal_legacy' => [\n                'class' => OctalLegacyNode::class,\n                'pcre_feature' => 'Legacy Octal Escapes',\n                'description' => 'Represents legacy octal escapes',\n                'examples' => ['\\0', '\\012', '\\177'],\n                'parent' => AbstractNode::class,\n                'children' => [],\n            ],\n        ];\n    }\n\n    /**\n     * Get all Node classes grouped by PCRE feature category.\n     *\n     * @return array<string, array<string>>\n     */\n    public static function getNodesByFeature(): array\n    {\n        return [\n            'Basic Matching' => [\n                LiteralNode::class,\n                DotNode::class,\n                CharTypeNode::class,\n            ],\n            'Character Classes' => [\n                CharClassNode::class,\n                RangeNode::class,\n                PosixClassNode::class,\n            ],\n            'Unicode Support' => [\n                UnicodeNode::class,\n                UnicodePropNode::class,\n            ],\n            'Quantifiers' => [\n                QuantifierNode::class,\n            ],\n            'Grouping' => [\n                GroupNode::class,\n            ],\n            'Structure' => [\n                SequenceNode::class,\n                AlternationNode::class,\n            ],\n            'Anchors & Assertions' => [\n                AnchorNode::class,\n                AssertionNode::class,\n                KeepNode::class,\n            ],\n            'References' => [\n                BackrefNode::class,\n                SubroutineNode::class,\n                ConditionalNode::class,\n            ],\n            'Advanced Features' => [\n                CommentNode::class,\n                PcreVerbNode::class,\n            ],\n            'Numeric Escapes' => [\n                OctalNode::class,\n                OctalLegacyNode::class,\n            ],\n            'Root' => [\n                RegexNode::class,\n            ],\n        ];\n    }\n\n    /**\n     * Get total count of Node types.\n     */\n    public static function getNodeCount(): int\n    {\n        return \\count(self::getAllNodes());\n    }\n\n    /**\n     * Get Node metadata by class name.\n     *\n     * @param class-string $className\n     *\n     * @return array{class: class-string, pcre_feature: string, description: string, examples: array<int|string, string>, parent: class-string|null, children: array<int|string, string>}|null\n     */\n    public static function getNodeMetadata(string $className): ?array\n    {\n        foreach (self::getAllNodes() as $metadata) {\n            if ($metadata['class'] === $className) {\n                return $metadata;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Get all PCRE features covered by the AST.\n     *\n     * @return array<string>\n     */\n    public static function getCoveredFeatures(): array\n    {\n        $features = [];\n        foreach (self::getAllNodes() as $metadata) {\n            $features[] = $metadata['pcre_feature'];\n        }\n\n        return array_unique($features);\n    }\n}\n",
    "Node/GroupType.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Node;\n\n/**\n * Defines the semantic type of a group.\n */\nenum GroupType: string\n{\n    /** A capturing group (...). */\n    case T_GROUP_CAPTURING = 'capturing';\n\n    /** A non-capturing group (?:...). */\n    case T_GROUP_NON_CAPTURING = 'non_capturing';\n\n    /** A named capturing group (?<name>...) or (?P<name>...). */\n    case T_GROUP_NAMED = 'named';\n\n    /** A positive lookahead (?=...). */\n    case T_GROUP_LOOKAHEAD_POSITIVE = 'lookahead_positive';\n\n    /** A negative lookahead (?!...). */\n    case T_GROUP_LOOKAHEAD_NEGATIVE = 'lookahead_negative';\n\n    /** A positive lookbehind (?<=...). */\n    case T_GROUP_LOOKBEHIND_POSITIVE = 'lookbehind_positive';\n\n    /** A negative lookbehind (?<!...). */\n    case T_GROUP_LOOKBEHIND_NEGATIVE = 'lookbehind_negative';\n\n    /** Inline flags (?i:...). */\n    case T_GROUP_INLINE_FLAGS = 'inline_flags';\n\n    /** An atomic group (?>...). */\n    case T_GROUP_ATOMIC = 'atomic';\n\n    /** A branch reset group (?|...). */\n    case T_GROUP_BRANCH_RESET = 'branch_reset';\n}\n",
    "Builder/CharClass.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Builder;\n\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\RangeNode;\n\n/**\n * A helper to build character class definitions (content inside [...]).\n * Immutable builder pattern.\n */\nfinal readonly class CharClass\n{\n    /**\n     * @param array<NodeInterface> $parts\n     */\n    private function __construct(\n        private array $parts = [],\n        private bool $negated = false\n    ) {}\n\n    public static function create(): self\n    {\n        return new self();\n    }\n\n    public static function any(): self\n    {\n        return self::create(); // Empty logic handled elsewhere or implicitly via usage\n    }\n\n    public static function digit(): self\n    {\n        return self::create()->add(new CharTypeNode('d', 0, 0));\n    }\n\n    public static function word(): self\n    {\n        return self::create()->add(new CharTypeNode('w', 0, 0));\n    }\n\n    public static function whitespace(): self\n    {\n        return self::create()->add(new CharTypeNode('s', 0, 0));\n    }\n\n    public static function range(string $from, string $to): self\n    {\n        return self::create()->add(new RangeNode(\n            new LiteralNode($from, 0, 0),\n            new LiteralNode($to, 0, 0),\n            0,\n            0,\n        ));\n    }\n\n    public static function literal(string ...$chars): self\n    {\n        $instance = self::create();\n        foreach ($chars as $charString) {\n            foreach (mb_str_split($charString) as $char) {\n                $instance = $instance->add(new LiteralNode($char, 0, 0));\n            }\n        }\n\n        return $instance;\n    }\n\n    public static function posix(string $class): self\n    {\n        return self::create()->add(new PosixClassNode($class, 0, 0));\n    }\n\n    public function union(self $other): self\n    {\n        return new self(array_merge($this->parts, $other->parts), $this->negated);\n    }\n\n    public function negate(): self\n    {\n        return new self($this->parts, true);\n    }\n\n    /**\n     * Internal method to append a node and return new instance.\n     */\n    public function add(NodeInterface $node): self\n    {\n        $newParts = $this->parts;\n        $newParts[] = $node;\n\n        return new self($newParts, $this->negated);\n    }\n\n    public function buildNode(): CharClassNode\n    {\n        return new CharClassNode($this->parts, $this->negated, 0, 0);\n    }\n}\n",
    "Builder/RegexBuilder.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Builder;\n\nuse RegexParser\\Node\\AlternationNode;\nuse RegexParser\\Node\\AnchorNode;\nuse RegexParser\\Node\\AssertionNode;\nuse RegexParser\\Node\\CharClassNode;\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\DotNode;\nuse RegexParser\\Node\\GroupNode;\nuse RegexParser\\Node\\GroupType;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\QuantifierNode;\nuse RegexParser\\Node\\QuantifierType;\nuse RegexParser\\Node\\RegexNode;\nuse RegexParser\\Node\\SequenceNode;\nuse RegexParser\\NodeVisitor\\CompilerNodeVisitor;\nuse RegexParser\\Regex;\nuse RegexParser\\RegexCompiler;\n\n/**\n * A fluent, type-safe builder for creating complex regex patterns.\n *\n * @property self $or Magic property for alternation\n */\nclass RegexBuilder\n{\n    /**\n     * @var array<NodeInterface> Current sequence of nodes\n     */\n    private array $currentNodes = [];\n\n    /**\n     * @var array<array<NodeInterface>> Completed alternatives branches\n     */\n    private array $branches = [];\n\n    /**\n     * @var array<string, bool> Active flags\n     */\n    private array $flags = [];\n\n    private string $delimiter = '/';\n\n    public function __construct() {}\n\n    public function __get(string $name): self\n    {\n        if ('or' === $name) {\n            return $this->or();\n        }\n\n        throw new \\BadMethodCallException(\\sprintf('Property \"%s\" does not exist.', $name));\n    }\n\n    public static function create(): self\n    {\n        return new self();\n    }\n\n    public function literal(string $text): self\n    {\n        if ('' === $text) {\n            return $this;\n        }\n        // Split into individual LiteralNodes (safe against special chars)\n        foreach (mb_str_split($text) as $char) {\n            $this->currentNodes[] = new LiteralNode($char, 0, 0);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds a raw, unescaped literal. (Alias for compatibility).\n     * The current builder treats all literals safely, but for 'raw', we just add a literal node directly.\n     * In the new structure, this is effectively the same as literal() but semantically intended for unescaped content.\n     */\n    public function raw(string $value): self\n    {\n        // Parse the raw regex fragment into an AST\n        // We use a safe delimiter (~) to avoid conflicts with common regex chars\n        // and escape any occurrences of the delimiter in the value.\n        $delimiter = '~';\n        $safeValue = str_replace($delimiter, '\\\\'.$delimiter, $value);\n        $pattern = $delimiter.$safeValue.$delimiter;\n\n        try {\n            // We use the static create() to get a fresh parser instance\n            $ast = Regex::create()->parse($pattern);\n            $this->currentNodes[] = $ast->pattern;\n        } catch (\\Throwable $e) {\n            // Fallback: if parsing fails (e.g. invalid partial regex),\n            // we might want to throw or fallback to LiteralNode?\n            // For now, let's throw to alert the user their \"raw\" regex is invalid.\n            throw new \\InvalidArgumentException('Invalid raw regex fragment: '.$e->getMessage(), 0, $e);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Parses and appends a raw regex string to the builder.\n     *\n     * This allows mixing fluent building with raw regex syntax.\n     * The incoming regex pattern is parsed and its AST is appended to the current builder state.\n     *\n     * @param string $regex Full regex pattern with delimiters (e.g. '/pattern/flags')\n     *\n     * @throws \\InvalidArgumentException if the regex cannot be parsed\n     */\n    public function addPart(string $regex): self\n    {\n        try {\n            $compiler = new RegexCompiler();\n            $ast = $compiler->parse($regex);\n            // Append the parsed pattern node to current nodes\n            $this->currentNodes[] = $ast->pattern;\n        } catch (\\Throwable $e) {\n            throw new \\InvalidArgumentException('Failed to parse regex in addPart: '.$e->getMessage(), 0, $e);\n        }\n\n        return $this;\n    }\n\n    public function anyChar(): self\n    {\n        $this->currentNodes[] = new DotNode(0, 0);\n\n        return $this;\n    }\n\n    /**\n     * Alias for anyChar() for BC\n     */\n    public function any(): self\n    {\n        return $this->anyChar();\n    }\n\n    public function digit(): self\n    {\n        $this->currentNodes[] = new CharTypeNode('d', 0, 0);\n\n        return $this;\n    }\n\n    public function notDigit(): self\n    {\n        $this->currentNodes[] = new CharTypeNode('D', 0, 0);\n\n        return $this;\n    }\n\n    public function word(): self\n    {\n        $this->currentNodes[] = new CharTypeNode('w', 0, 0);\n\n        return $this;\n    }\n\n    public function notWord(): self\n    {\n        $this->currentNodes[] = new CharTypeNode('W', 0, 0);\n\n        return $this;\n    }\n\n    public function whitespace(): self\n    {\n        $this->currentNodes[] = new CharTypeNode('s', 0, 0);\n\n        return $this;\n    }\n\n    public function notWhitespace(): self\n    {\n        $this->currentNodes[] = new CharTypeNode('S', 0, 0);\n\n        return $this;\n    }\n\n    /**\n     * Adds a custom character class.\n     * Usage: ->charClass(CharClass::digit()->union(CharClass::range('a', 'f')))\n     */\n    public function charClass(CharClass|callable $charClass): self\n    {\n        if (\\is_callable($charClass)) {\n            // Support old callback style: function(CharClassBuilder $c)\n            // We adapter it to use the new CharClass object manually\n            // Since CharClass is immutable and static factory based, passing it to a callback\n            // which expects a mutable builder might be tricky.\n            // We recreate the old CharClassBuilder logic temporarily for BC.\n            $builder = new CharClassBuilder();\n            $charClass($builder);\n            $parts = $builder->build();\n            $this->currentNodes[] = new CharClassNode($parts, false, 0, 0);\n\n            return $this;\n        }\n\n        $this->currentNodes[] = $charClass->buildNode();\n\n        return $this;\n    }\n\n    public function startOfLine(): self\n    {\n        $this->currentNodes[] = new AnchorNode('^', 0, 0);\n\n        return $this;\n    }\n\n    public function endOfLine(): self\n    {\n        $this->currentNodes[] = new AnchorNode('$', 0, 0);\n\n        return $this;\n    }\n\n    public function wordBoundary(): self\n    {\n        $this->currentNodes[] = new AssertionNode('b', 0, 0);\n\n        return $this;\n    }\n\n    /**\n     * Creates a capturing group: (...)\n     */\n    public function capture(callable $builder, ?string $name = null): self\n    {\n        return $this->addGroup($builder, $name ? GroupType::T_GROUP_NAMED : GroupType::T_GROUP_CAPTURING, $name);\n    }\n\n    /**\n     * Compatibility wrapper for capture() with name first (if needed) or general group.\n     * The old API was: namedGroup(string $name, Closure $callback)\n     */\n    public function namedGroup(string $name, callable $callback): self\n    {\n        return $this->capture($callback, $name);\n    }\n\n    /**\n     * Creates a non-capturing group: (?:...)\n     * Also handles the old signature: group(Closure $callback, bool $capture = true)\n     */\n    public function group(callable $builder, bool $capture = true): self\n    {\n        if ($capture) {\n            return $this->addGroup($builder, GroupType::T_GROUP_CAPTURING);\n        }\n\n        return $this->addGroup($builder, GroupType::T_GROUP_NON_CAPTURING);\n    }\n\n    /**\n     * Creates an atomic group: (?>...)\n     */\n    public function atomic(callable $builder): self\n    {\n        return $this->addGroup($builder, GroupType::T_GROUP_ATOMIC);\n    }\n\n    public function lookahead(callable $builder): self\n    {\n        return $this->addGroup($builder, GroupType::T_GROUP_LOOKAHEAD_POSITIVE);\n    }\n\n    public function negativeLookahead(callable $builder): self\n    {\n        return $this->addGroup($builder, GroupType::T_GROUP_LOOKAHEAD_NEGATIVE);\n    }\n\n    public function lookbehind(callable $builder): self\n    {\n        return $this->addGroup($builder, GroupType::T_GROUP_LOOKBEHIND_POSITIVE);\n    }\n\n    public function negativeLookbehind(callable $builder): self\n    {\n        return $this->addGroup($builder, GroupType::T_GROUP_LOOKBEHIND_NEGATIVE);\n    }\n\n    /**\n     * Marks the end of the current branch and starts a new one.\n     * Logic: (current) | (next)\n     */\n    public function or(): self\n    {\n        if (empty($this->currentNodes)) {\n            // Allows patterns like: |foo (empty start) or foo||bar (empty middle)\n            $this->currentNodes[] = new LiteralNode('', 0, 0);\n        }\n\n        $this->branches[] = $this->currentNodes;\n        $this->currentNodes = [];\n\n        return $this;\n    }\n\n    public function optional(bool $lazy = false): self\n    {\n        return $this->quantify('?', $lazy);\n    }\n\n    public function zeroOrMore(bool $lazy = false): self\n    {\n        return $this->quantify('*', $lazy);\n    }\n\n    public function oneOrMore(bool $lazy = false): self\n    {\n        return $this->quantify('+', $lazy);\n    }\n\n    public function exactly(int $n): self\n    {\n        return $this->quantify(\\sprintf('{%d}', $n), false);\n    }\n\n    public function atLeast(int $n, bool $lazy = false): self\n    {\n        return $this->quantify(\\sprintf('{%d,}', $n), $lazy);\n    }\n\n    public function between(int $min, int $max, bool $lazy = false): self\n    {\n        return $this->quantify(\\sprintf('{%d,%d}', $min, $max), $lazy);\n    }\n\n    public function withFlags(string $flags): self\n    {\n        foreach (str_split($flags) as $flag) {\n            $this->flags[$flag] = true;\n        }\n\n        return $this;\n    }\n\n    public function withDelimiter(string $delimiter): self\n    {\n        if (1 !== \\strlen($delimiter)) {\n            throw new \\InvalidArgumentException('Delimiter must be a single character.');\n        }\n        $this->delimiter = $delimiter;\n\n        return $this;\n    }\n\n    public function caseInsensitive(): self\n    {\n        $this->flags['i'] = true;\n\n        return $this;\n    }\n\n    public function multiline(): self\n    {\n        $this->flags['m'] = true;\n\n        return $this;\n    }\n\n    public function dotAll(): self\n    {\n        $this->flags['s'] = true;\n\n        return $this;\n    }\n\n    public function unicode(): self\n    {\n        $this->flags['u'] = true;\n\n        return $this;\n    }\n\n    public function build(): string\n    {\n        $node = $this->buildNode();\n\n        // Create a RegexNode to hold flags and delimiters for compilation\n        $flagsStr = implode('', array_keys($this->flags));\n        $regexNode = new RegexNode($node, $flagsStr, $this->delimiter, 0, 0);\n\n        return $regexNode->accept(new CompilerNodeVisitor());\n    }\n\n    /**\n     * Alias for build() to maintain backward compatibility.\n     */\n    public function compile(): string\n    {\n        return $this->build();\n    }\n\n    /**\n     * Alias for build() - returns the compiled pattern string.\n     */\n    public function getPattern(): string\n    {\n        return $this->build();\n    }\n\n    /**\n     * Returns a configured Regex object ready for use.\n     */\n    public function getRegex(): Regex\n    {\n        return Regex::create();\n    }\n\n    private function addGroup(callable $builderCallback, GroupType $type, ?string $name = null): self\n    {\n        $subBuilder = new self();\n        $builderCallback($subBuilder);\n\n        $childNode = $subBuilder->buildNode();\n\n        $this->currentNodes[] = new GroupNode(\n            $childNode,\n            $type,\n            $name,\n            null,\n            0,\n            0,\n        );\n\n        return $this;\n    }\n\n    private function quantify(string $symbol, bool $lazy): self\n    {\n        if (empty($this->currentNodes)) {\n            throw new \\LogicException('Cannot apply quantifier to an empty expression.');\n        }\n\n        $lastNode = array_pop($this->currentNodes);\n\n        $type = $lazy ? QuantifierType::T_LAZY : QuantifierType::T_GREEDY;\n\n        $this->currentNodes[] = new QuantifierNode($lastNode, $symbol, $type, 0, 0);\n\n        return $this;\n    }\n\n    private function buildNode(): NodeInterface\n    {\n        // Close the last branch\n        if (!empty($this->currentNodes)) {\n            $this->branches[] = $this->currentNodes;\n        } elseif (empty($this->branches)) {\n            // Nothing at all\n            return new LiteralNode('', 0, 0);\n        } else {\n            // Last branch was explicitly empty (e.g. ends with ->or())\n            $this->branches[] = [new LiteralNode('', 0, 0)];\n        }\n\n        // Convert branches to Sequences\n        $sequences = [];\n        foreach ($this->branches as $nodes) {\n            if (1 === \\count($nodes)) {\n                $sequences[] = $nodes[0];\n            } else {\n                $sequences[] = new SequenceNode($nodes, 0, 0);\n            }\n        }\n\n        // If only one branch, return it directly\n        if (1 === \\count($sequences)) {\n            return $sequences[0];\n        }\n\n        return new AlternationNode($sequences, 0, 0);\n    }\n}\n",
    "Builder/CharClassBuilder.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Builder;\n\nuse RegexParser\\Node\\CharTypeNode;\nuse RegexParser\\Node\\LiteralNode;\nuse RegexParser\\Node\\NodeInterface;\nuse RegexParser\\Node\\PosixClassNode;\nuse RegexParser\\Node\\RangeNode;\n\n/**\n * A specialized builder for constructing character classes [].\n * This is used internally by RegexBuilder.\n */\nclass CharClassBuilder\n{\n    /**\n     * @var array<NodeInterface>\n     */\n    private array $parts = [];\n\n    /**\n     * Adds a literal character or string to the class.\n     */\n    public function literal(string $value): self\n    {\n        foreach (mb_str_split($value) as $char) {\n            $this->parts[] = new LiteralNode($char, 0, 0);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds a character range (e.g., \"a-z\").\n     */\n    public function range(string $start, string $end): self\n    {\n        if (1 !== mb_strlen($start) || 1 !== mb_strlen($end)) {\n            throw new \\InvalidArgumentException('Range parts must be single characters.');\n        }\n        $this->parts[] = new RangeNode(new LiteralNode($start, 0, 0), new LiteralNode($end, 0, 0), 0, 0);\n\n        return $this;\n    }\n\n    public function digit(): self\n    {\n        $this->parts[] = new CharTypeNode('d', 0, 0);\n\n        return $this;\n    }\n\n    public function notDigit(): self\n    {\n        $this->parts[] = new CharTypeNode('D', 0, 0);\n\n        return $this;\n    }\n\n    public function whitespace(): self\n    {\n        $this->parts[] = new CharTypeNode('s', 0, 0);\n\n        return $this;\n    }\n\n    public function notWhitespace(): self\n    {\n        $this->parts[] = new CharTypeNode('S', 0, 0);\n\n        return $this;\n    }\n\n    public function word(): self\n    {\n        $this->parts[] = new CharTypeNode('w', 0, 0);\n\n        return $this;\n    }\n\n    public function notWord(): self\n    {\n        $this->parts[] = new CharTypeNode('W', 0, 0);\n\n        return $this;\n    }\n\n    public function posix(string $class): self\n    {\n        // Note: The Validator will check if the class name is valid\n        $this->parts[] = new PosixClassNode($class, 0, 0);\n\n        return $this;\n    }\n\n    /**\n     * @return array<NodeInterface>\n     */\n    public function build(): array\n    {\n        return $this->parts;\n    }\n}\n",
    "Exception/ParserException.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Exception;\n\nclass ParserException extends \\Exception {}\n",
    "Exception/LexerException.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Exception;\n\nclass LexerException extends \\Exception {}\n",
    "Exception/SyntaxErrorException.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Exception;\n\n/**\n * Thrown when a syntax error is encountered in the PCRE pattern.\n */\nclass SyntaxErrorException extends ParserException implements RegexParserExceptionInterface {}\n",
    "Exception/RecursionLimitException.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Exception;\n\n/**\n * Thrown when recursion depth exceeds the maximum allowed limit.\n * Prevents stack overflow attacks on deeply nested patterns.\n */\nclass RecursionLimitException extends ParserException implements RegexParserExceptionInterface {}\n",
    "Exception/RegexParserExceptionInterface.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Exception;\n\n/**\n * Base interface for all RegexParser exceptions.\n */\ninterface RegexParserExceptionInterface extends \\Throwable {}\n",
    "Exception/ResourceLimitException.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Exception;\n\n/**\n * Thrown when resource usage (e.g., node count) exceeds the maximum allowed limit.\n * Prevents Denial of Service attacks through resource exhaustion.\n */\nclass ResourceLimitException extends ParserException implements RegexParserExceptionInterface {}\n",
    "autoload.php": "<?php\n\ndeclare(strict_types=1);\n\nspl_autoload_register(function (string $class): void {\n    $prefix = 'RegexParser\\\\';\n    $baseDir = __DIR__.'/src/';\n\n    $len = strlen($prefix);\n    if (strncmp($prefix, $class, $len) !== 0) {\n        return;\n    }\n\n    $relativeClass = substr($class, $len);\n    $file = $baseDir.str_replace('\\\\', '/', $relativeClass).'.php';\n\n    if (file_exists($file)) {\n        require $file;\n    }\n});",
    "Bridge/Symfony/Analyzer/RouteRequirementAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\nuse RegexParser\\Regex;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RegexAnalysisIssue;\nuse Symfony\\Component\\Routing\\RouteCollection;\n\n/**\n * Analyses Symfony route requirements and reports regex issues.\n *\n * @internal\n */\nfinal readonly class RouteRequirementAnalyzer\n{\n    private const array PATTERN_DELIMITERS = ['/', '#', '~', '%'];\n\n    public function __construct(\n        private Regex $regex,\n        private int $warningThreshold,\n        private int $redosThreshold,\n    ) {}\n\n    /**\n     * @return list<RegexAnalysisIssue>\n     */\n    public function analyze(RouteCollection $routes): array\n    {\n        $issues = [];\n\n        foreach ($routes as $name => $route) {\n            foreach ($route->getRequirements() as $parameter => $requirement) {\n                if (!\\is_scalar($requirement)) {\n                    continue;\n                }\n\n                $pattern = trim((string) $requirement);\n                if ('' === $pattern) {\n                    continue;\n                }\n\n                $normalizedPattern = $this->normalizePattern($pattern);\n                $result = $this->regex->validate($normalizedPattern);\n\n                if (!$result->isValid) {\n                    $issues[] = new RegexAnalysisIssue(\n                        \\sprintf(\n                            'Route \"%s\" requirement \"%s\" is invalid: %s',\n                            (string) $name,\n                            $parameter,\n                            $result->error ?? 'unknown error',\n                        ),\n                        true,\n                    );\n\n                    continue;\n                }\n\n                if ($result->complexityScore >= $this->redosThreshold) {\n                    $issues[] = new RegexAnalysisIssue(\n                        \\sprintf(\n                            'Route \"%s\" requirement \"%s\" may be vulnerable to ReDoS (score: %d).',\n                            (string) $name,\n                            $parameter,\n                            $result->complexityScore,\n                        ),\n                        true,\n                    );\n\n                    continue;\n                }\n\n                if ($result->complexityScore >= $this->warningThreshold) {\n                    $issues[] = new RegexAnalysisIssue(\n                        \\sprintf(\n                            'Route \"%s\" requirement \"%s\" is complex (score: %d).',\n                            (string) $name,\n                            $parameter,\n                            $result->complexityScore,\n                        ),\n                        false,\n                    );\n                }\n            }\n        }\n\n        return $issues;\n    }\n\n    private function normalizePattern(string $pattern): string\n    {\n        $firstChar = $pattern[0] ?? '';\n\n        if (\\in_array($firstChar, self::PATTERN_DELIMITERS, true)) {\n            return $pattern;\n        }\n\n        $delimiter = '#';\n        $body = str_replace($delimiter, '\\\\'.$delimiter, $pattern);\n\n        return $delimiter.'^'.$body.'$'.$delimiter;\n    }\n}\n",
    "Bridge/Symfony/Analyzer/RouteIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\n/**\n * @internal\n */\nfinal readonly class RouteIssue\n{\n    public function __construct(\n        public string $message,\n        public bool $isError,\n    ) {}\n}\n",
    "Bridge/Symfony/CacheWarmer/RegexParserCacheWarmer.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\CacheWarmer;\n\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\LogLevel;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RegexAnalysisIssue;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse Symfony\\Component\\HttpKernel\\CacheWarmer\\CacheWarmerInterface;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n/**\n * Surfaces regex warnings during Symfony cache warmup.\n *\n * @internal\n */\nfinal readonly class RegexParserCacheWarmer implements CacheWarmerInterface\n{\n    public function __construct(\n        private RouteRequirementAnalyzer $analyzer,\n        private ?RouterInterface $router = null,\n        private ?LoggerInterface $logger = null,\n        private ?ValidatorRegexAnalyzer $validatorAnalyzer = null,\n        private ?ValidatorInterface $validator = null,\n        private ?LoaderInterface $validatorLoader = null,\n    ) {}\n\n    #[\\Override]\n    public function isOptional(): bool\n    {\n        return true;\n    }\n\n    #[\\Override]\n    public function warmUp(string $cacheDir, ?string $buildDir = null): array\n    {\n        $issues = [];\n\n        if (null !== $this->router) {\n            $issues = \\array_merge($issues, $this->analyzer->analyze($this->router->getRouteCollection()));\n        }\n\n        if (null !== $this->validatorAnalyzer) {\n            $issues = \\array_merge($issues, $this->validatorAnalyzer->analyze($this->validator, $this->validatorLoader));\n        }\n\n        foreach ($issues as $issue) {\n            $this->log($issue);\n        }\n\n        return [];\n    }\n\n    private function log(RegexAnalysisIssue $issue): void\n    {\n        if (null !== $this->logger) {\n            $this->logger->log(\n                $issue->isError ? LogLevel::ERROR : LogLevel::WARNING,\n                $issue->message,\n            );\n\n            return;\n        }\n\n        \\error_log($issue->message);\n    }\n}\n",
    "Bridge/Symfony/Command/RegexParserValidateCommand.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\Command;\n\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\nfinal class RegexParserValidateCommand extends Command\n{\n    protected static $defaultName = 'regex-parser:check';\n\n    protected static $defaultDescription = 'Validates regex usage found in the Symfony application.';\n\n    public function __construct(\n        private readonly RouteRequirementAnalyzer $analyzer,\n        private readonly ?RouterInterface $router = null,\n        private readonly ?ValidatorRegexAnalyzer $validatorAnalyzer = null,\n        private readonly ?ValidatorInterface $validator = null,\n        private readonly ?LoaderInterface $validatorLoader = null,\n    ) {\n        parent::__construct();\n    }\n\n    #[\\Override]\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n\n        $issues = [];\n\n        if (null !== $this->router) {\n            $issues = \\array_merge($issues, $this->analyzer->analyze($this->router->getRouteCollection()));\n        } else {\n            $io->warning('No router service was found; skipping route regex checks.');\n        }\n\n        if (null !== $this->validatorAnalyzer) {\n            $issues = \\array_merge($issues, $this->validatorAnalyzer->analyze($this->validator, $this->validatorLoader));\n        } else {\n            $io->warning('No validator service was found; skipping validator regex checks.');\n        }\n\n        if ([] === $issues) {\n            $io->success('No regex issues detected.');\n\n            return Command::SUCCESS;\n        }\n\n        $hasErrors = false;\n        foreach ($issues as $issue) {\n            $hasErrors = $hasErrors || $issue->isError;\n            $io->writeln(\\sprintf(\n                '%s %s',\n                $issue->isError ? '<error>[error]</error>' : '<comment>[warn]</comment>',\n                $issue->message,\n            ));\n        }\n\n        if (!$hasErrors) {\n            $io->success('RegexParser found warnings only.');\n        }\n\n        return $hasErrors ? Command::FAILURE : Command::SUCCESS;\n    }\n}\n",
    "tests/Bridge/Symfony/RegexParserBundleTest.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Tests\\Bridge\\Symfony;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Log\\LoggerInterface;\nuse RegexParser\\Bridge\\Symfony\\CacheWarmer\\RegexParserCacheWarmer;\nuse RegexParser\\Bridge\\Symfony\\Command\\RegexParserValidateCommand;\nuse RegexParser\\Bridge\\Symfony\\DependencyInjection\\RegexParserExtension;\nuse RegexParser\\Cache\\FilesystemCache;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\Routing\\RequestContext;\nuse Symfony\\Component\\Routing\\Route;\nuse Symfony\\Component\\Routing\\RouteCollection;\nuse Symfony\\Component\\Routing\\RouterInterface;\n\nfinal class RegexParserBundleTest extends TestCase\n{\n    public function test_regex_service_registered_with_filesystem_cache(): void\n    {\n        $cacheDir = sys_get_temp_dir().'/regex_parser_'.uniqid();\n        $container = $this->createContainer([\n            'enabled' => true,\n            'max_pattern_length' => 5000,\n            'cache' => $cacheDir,\n        ]);\n        $container->compile();\n\n        /** @var Regex $regex */\n        $regex = $container->get('regex_parser.regex');\n        $regex->parse('/abc/');\n\n        $cache = new FilesystemCache($cacheDir);\n        $cacheFile = $cache->generateKey('/abc/');\n\n        $this->assertFileExists($cacheFile);\n\n        $cache->clear();\n    }\n\n    public function test_cache_warmer_logs_route_issues(): void\n    {\n        $routes = new RouteCollection();\n        $routes->add('broken', new Route('/broken', [], ['slug' => '(']));\n\n        $logger = new InMemoryLogger();\n\n        $container = $this->createContainer([\n            'enabled' => true,\n            'analysis' => [\n                'warning_threshold' => 1,\n                'redos_threshold' => 1,\n            ],\n        ]);\n\n        $container->register(LoggerInterface::class, InMemoryLogger::class)->setPublic(true);\n        $container->setAlias('logger', LoggerInterface::class)->setPublic(true);\n        $container->register('router', RouteCollectionRouter::class)\n            ->setArguments([$routes])\n            ->setPublic(true);\n        $container->register(RouterInterface::class, RouteCollectionRouter::class)\n            ->setArguments([$routes])\n            ->setPublic(true);\n        $container->addCompilerPass(new class implements CompilerPassInterface {\n            public function process(ContainerBuilder $container): void\n            {\n                if ($container->hasDefinition('regex_parser.cache_warmer')) {\n                    $container->getDefinition('regex_parser.cache_warmer')->setPublic(true);\n                }\n            }\n        });\n        $container->compile();\n\n        /** @var RegexParserCacheWarmer $warmer */\n        $warmer = $container->get('regex_parser.cache_warmer');\n        /** @var InMemoryLogger $loggerService */\n        $loggerService = $container->get(LoggerInterface::class);\n        $warmer->warmUp(sys_get_temp_dir());\n\n        $this->assertNotEmpty($loggerService->records);\n        $this->assertSame('error', $loggerService->records[0]['level']);\n        $this->assertStringContainsString('broken', $loggerService->records[0]['message']);\n    }\n\n    public function test_command_is_registered_as_console_service(): void\n    {\n        $container = $this->createContainer(['enabled' => true]);\n        $container->compile();\n\n        $this->assertTrue($container->hasDefinition('regex_parser.command.validate'));\n        $definition = $container->getDefinition('regex_parser.command.validate');\n        $this->assertSame(RegexParserValidateCommand::class, $definition->getClass());\n        $this->assertArrayHasKey('console.command', $definition->getTags());\n    }\n\n    public function test_bundle_can_be_disabled(): void\n    {\n        $container = $this->createContainer(['enabled' => false]);\n        $container->compile();\n\n        $this->assertFalse($container->has('regex_parser.regex'));\n    }\n\n    /**\n     * @param array<string, mixed> $config\n     */\n    private function createContainer(array $config): ContainerBuilder\n    {\n        $container = new ContainerBuilder();\n        $container->setParameter('kernel.debug', true);\n\n        $extension = new RegexParserExtension();\n        $container->registerExtension($extension);\n        $container->loadFromExtension($extension->getAlias(), $config);\n\n        return $container;\n    }\n}\n\nfinal class InMemoryLogger implements LoggerInterface\n{\n    /**\n     * @var array<int, array{level: string, message: string}>\n     */\n    public array $records = [];\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function emergency(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('emergency', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function alert(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('alert', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function critical(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('critical', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function error(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('error', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function warning(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('warning', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function notice(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('notice', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function info(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('info', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function debug(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('debug', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function log($level, \\Stringable|string $message, array $context = []): void\n    {\n        $levelString = \\is_scalar($level) || $level instanceof \\Stringable ? (string) $level : get_debug_type($level);\n        $this->records[] = [\n            'level' => $levelString,\n            'message' => (string) $message,\n        ];\n    }\n}\n\nfinal readonly class RouteCollectionRouter implements RouterInterface\n{\n    public function __construct(private RouteCollection $routes) {}\n\n    public function setContext(RequestContext $context): void {}\n\n    public function getContext(): RequestContext\n    {\n        return new RequestContext();\n    }\n\n    public function getRouteCollection(): RouteCollection\n    {\n        return $this->routes;\n    }\n\n    /**\n     * @param array<string, mixed> $parameters\n     */\n    public function generate(string $name, array $parameters = [], int $referenceType = self::ABSOLUTE_PATH): string\n    {\n        return '';\n    }\n\n    /**\n     * @return array<string, mixed>\n     */\n    public function match(string $pathinfo): array\n    {\n        return [];\n    }\n}\n",
    "tests/Bridge/Symfony/Analyzer/RouteRequirementAnalyzerTest.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Tests\\Bridge\\Symfony\\Analyzer;\n\nuse PHPUnit\\Framework\\TestCase;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Routing\\Route;\nuse Symfony\\Component\\Routing\\RouteCollection;\n\nfinal class RouteRequirementAnalyzerTest extends TestCase\n{\n    public function test_valid_requirement_produces_no_issues(): void\n    {\n        $analyzer = new RouteRequirementAnalyzer(Regex::create(), 100, 200);\n\n        $routes = new RouteCollection();\n        $routes->add('home', new Route('/home', [], ['slug' => '[a-z]+']));\n\n        $this->assertSame([], $analyzer->analyze($routes));\n    }\n\n    public function test_invalid_requirement_is_reported(): void\n    {\n        $analyzer = new RouteRequirementAnalyzer(Regex::create(), 100, 200);\n\n        $routes = new RouteCollection();\n        $routes->add('broken', new Route('/broken', [], ['id' => '(']));\n\n        $issues = $analyzer->analyze($routes);\n\n        $this->assertCount(1, $issues);\n        $this->assertTrue($issues[0]->isError);\n        $this->assertStringContainsString('broken', $issues[0]->message);\n    }\n\n    public function test_warning_threshold_is_applied(): void\n    {\n        $analyzer = new RouteRequirementAnalyzer(Regex::create(), 0, 1000);\n\n        $routes = new RouteCollection();\n        $routes->add('warn', new Route('/warn', [], ['name' => '.+']));\n\n        $issues = $analyzer->analyze($routes);\n\n        $this->assertCount(1, $issues);\n        $this->assertFalse($issues[0]->isError);\n        $this->assertStringContainsString('warn', $issues[0]->message);\n    }\n}\n",
    "tests/Bridge/Symfony/CacheWarmer/RegexParserCacheWarmerTest.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Tests\\Bridge\\Symfony\\CacheWarmer;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Log\\LoggerInterface;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RouteRequirementAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse RegexParser\\Bridge\\Symfony\\CacheWarmer\\RegexParserCacheWarmer;\nuse RegexParser\\Regex;\nuse RegexParser\\Tests\\Bridge\\Symfony\\Analyzer\\FakeLoader;\nuse RegexParser\\Tests\\Bridge\\Symfony\\Analyzer\\FakeValidator;\nuse Symfony\\Component\\Routing\\RequestContext;\nuse Symfony\\Component\\Routing\\Route;\nuse Symfony\\Component\\Routing\\RouteCollection;\nuse Symfony\\Component\\Routing\\RouterInterface;\nuse Symfony\\Component\\Validator\\Constraints\\Regex as SymfonyRegex;\n\nfinal class RegexParserCacheWarmerTest extends TestCase\n{\n    public function test_warm_up_logs_issues(): void\n    {\n        $logger = new InMemoryLogger();\n        $analyzer = new RouteRequirementAnalyzer(Regex::create(), 0, 0);\n        $warmup = new RegexParserCacheWarmer($analyzer, new RouteCollectionRouterWithIssue(), $logger);\n\n        $warmup->warmUp(sys_get_temp_dir());\n\n        $this->assertNotEmpty($logger->records);\n        $this->assertSame('error', $logger->records[0]['level']);\n    }\n\n    public function test_warm_up_is_optional(): void\n    {\n        $analyzer = new RouteRequirementAnalyzer(Regex::create(), 0, 0);\n        $warmup = new RegexParserCacheWarmer($analyzer, null, null);\n\n        $this->assertTrue($warmup->isOptional());\n        $this->assertSame([], $warmup->warmUp(sys_get_temp_dir()));\n    }\n\n    public function test_warm_up_logs_validator_issues(): void\n    {\n        $logger = new InMemoryLogger();\n        $validatorAnalyzer = new ValidatorRegexAnalyzer(Regex::create(), 0, 1000);\n        $validator = new FakeValidator([new SymfonyRegex(pattern: '(')]);\n        $loader = new FakeLoader([FakeValidator::class]);\n\n        $warmup = new RegexParserCacheWarmer(\n            new RouteRequirementAnalyzer(Regex::create(), 0, 0),\n            null,\n            $logger,\n            $validatorAnalyzer,\n            $validator,\n            $loader,\n        );\n\n        $warmup->warmUp(sys_get_temp_dir());\n\n        $this->assertNotEmpty($logger->records);\n        $this->assertSame('error', $logger->records[0]['level']);\n    }\n}\n\nfinal class RouteCollectionRouterWithIssue implements RouterInterface\n{\n    public function setContext(RequestContext $context): void {}\n\n    public function getContext(): RequestContext\n    {\n        return new RequestContext();\n    }\n\n    public function getRouteCollection(): RouteCollection\n    {\n        $collection = new RouteCollection();\n        $collection->add('foo', new Route('/foo', [], ['slug' => '(']));\n\n        return $collection;\n    }\n\n    /**\n     * @param array<string, mixed> $parameters\n     */\n    public function generate(string $name, array $parameters = [], int $referenceType = self::ABSOLUTE_PATH): string\n    {\n        return '';\n    }\n\n    /**\n     * @return array<string, mixed>\n     */\n    public function match(string $pathinfo): array\n    {\n        return [];\n    }\n}\n\nfinal class InMemoryLogger implements LoggerInterface\n{\n    /**\n     * @var array<int, array{level: string, message: string}>\n     */\n    public array $records = [];\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function emergency(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('emergency', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function alert(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('alert', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function critical(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('critical', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function error(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('error', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function warning(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('warning', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function notice(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('notice', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function info(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('info', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function debug(\\Stringable|string $message, array $context = []): void\n    {\n        $this->log('debug', $message, $context);\n    }\n\n    /**\n     * @param array<string, mixed> $context\n     */\n    public function log($level, \\Stringable|string $message, array $context = []): void\n    {\n        $levelString = \\is_scalar($level) || $level instanceof \\Stringable ? (string) $level : get_debug_type($level);\n        $this->records[] = [\n            'level' => $levelString,\n            'message' => (string) $message,\n        ];\n    }\n}\n",
    "Bridge/Symfony/Analyzer/ValidatorRegexAnalyzer.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Validator\\Constraint;\nuse Symfony\\Component\\Validator\\Constraints\\Regex as SymfonyRegex;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadataInterface;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Mapping\\MetadataInterface;\nuse Symfony\\Component\\Validator\\Mapping\\PropertyMetadataInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n/**\n * Analyses Symfony Validator metadata for Regex constraints.\n *\n * @internal\n */\nfinal readonly class ValidatorRegexAnalyzer\n{\n    public function __construct(\n        private Regex $regex,\n        private int $warningThreshold,\n        private int $redosThreshold,\n    ) {}\n\n    /**\n     * @return list<RegexAnalysisIssue>\n     */\n    public function analyze(?ValidatorInterface $validator, ?LoaderInterface $loader): array\n    {\n        if (null === $validator) {\n            return [];\n        }\n\n        $classes = [];\n        if (null !== $loader && \\method_exists($loader, 'getMappedClasses')) {\n            $classes = $loader->getMappedClasses();\n        }\n\n        $issues = [];\n        foreach ($classes as $className) {\n            if (!\\is_string($className) || '' === $className) {\n                continue;\n            }\n\n            try {\n                $metadata = $validator->getMetadataFor($className);\n            } catch (\\Throwable) {\n                continue;\n            }\n\n            $issues = \\array_merge(\n                $issues,\n                $this->analyzeMetadata($metadata, $className),\n            );\n        }\n\n        return $issues;\n    }\n\n    /**\n     * @return list<RegexAnalysisIssue>\n     */\n    private function analyzeMetadata(MetadataInterface $metadata, string $className): array\n    {\n        $issues = [];\n        $constraints = [];\n\n        if ($metadata instanceof ClassMetadataInterface) {\n            $constraints = $metadata->getConstraints();\n\n            foreach ($metadata->getConstrainedProperties() as $propertyName) {\n                foreach ($metadata->getPropertyMetadata($propertyName) as $propertyMetadata) {\n                    $issues = \\array_merge(\n                        $issues,\n                        $this->analyzeConstraints(\n                            $propertyMetadata->getConstraints(),\n                            \\sprintf('%s::$%s', $className, $propertyMetadata->getName()),\n                        ),\n                    );\n                }\n            }\n        }\n\n        return \\array_merge(\n            $issues,\n            $this->analyzeConstraints($constraints, $className),\n        );\n    }\n\n    /**\n     * @param array<Constraint> $constraints\n     *\n     * @return list<RegexAnalysisIssue>\n     */\n    private function analyzeConstraints(array $constraints, string $source): array\n    {\n        $issues = [];\n\n        foreach ($constraints as $constraint) {\n            if (!$constraint instanceof SymfonyRegex || null === $constraint->pattern || '' === $constraint->pattern) {\n                continue;\n            }\n\n            $result = $this->regex->validate((string) $constraint->pattern);\n\n            if (!$result->isValid) {\n                $issues[] = new RegexAnalysisIssue(\n                    \\sprintf('Validator \"%s\" pattern is invalid: %s', $source, $result->error ?? 'unknown error'),\n                    true,\n                );\n                continue;\n            }\n\n            if ($result->complexityScore >= $this->redosThreshold) {\n                $issues[] = new RegexAnalysisIssue(\n                    \\sprintf('Validator \"%s\" pattern may be vulnerable to ReDoS (score: %d).', $source, $result->complexityScore),\n                    true,\n                );\n                continue;\n            }\n\n            if ($result->complexityScore >= $this->warningThreshold) {\n                $issues[] = new RegexAnalysisIssue(\n                    \\sprintf('Validator \"%s\" pattern is complex (score: %d).', $source, $result->complexityScore),\n                    false,\n                );\n            }\n        }\n\n        return $issues;\n    }\n}\n",
    "Bridge/Symfony/Analyzer/RegexAnalysisIssue.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Bridge\\Symfony\\Analyzer;\n\n/**\n * @internal\n */\nfinal readonly class RegexAnalysisIssue\n{\n    public function __construct(\n        public string $message,\n        public bool $isError,\n    ) {}\n}\n",
    "tests/Bridge/Symfony/Analyzer/ValidatorRegexAnalyzerTest.php": "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the RegexParser package.\n *\n * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace RegexParser\\Tests\\Bridge\\Symfony\\Analyzer;\n\nuse PHPUnit\\Framework\\TestCase;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\RegexAnalysisIssue;\nuse RegexParser\\Bridge\\Symfony\\Analyzer\\ValidatorRegexAnalyzer;\nuse RegexParser\\Regex;\nuse Symfony\\Component\\Validator\\Constraint;\nuse Symfony\\Component\\Validator\\ConstraintViolationList;\nuse Symfony\\Component\\Validator\\Constraints\\Regex as SymfonyRegex;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\nuse Symfony\\Component\\Validator\\Mapping\\PropertyMetadata;\nuse Symfony\\Component\\Validator\\Mapping\\Loader\\LoaderInterface;\nuse Symfony\\Component\\Validator\\Constraints\\GroupSequence;\nuse Symfony\\Component\\Validator\\Validator\\ContextualValidatorInterface;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\nfinal class ValidatorRegexAnalyzerTest extends TestCase\n{\n    public function testAnalyzerReportsInvalidAndWarningPatterns(): void\n    {\n        $validator = new FakeValidator([\n            new SymfonyRegex(pattern: '('), // invalid\n            new SymfonyRegex(pattern: '/.+/'), // warning (score >= 0)\n        ]);\n\n        $loader = new FakeLoader([FakeEntity::class]);\n\n        $analyzer = new ValidatorRegexAnalyzer(Regex::create(), 0, 1000);\n\n        $issues = $analyzer->analyze($validator, $loader);\n\n        self::assertCount(2, $issues);\n        self::assertInstanceOf(RegexAnalysisIssue::class, $issues[0]);\n        self::assertTrue($issues[0]->isError);\n        self::assertFalse($issues[1]->isError);\n    }\n}\n\nfinal class FakeEntity\n{\n    public string $name = '';\n}\n\nfinal class FakeLoader implements LoaderInterface\n{\n    /**\n     * @param list<string> $classes\n     */\n    public function __construct(private readonly array $classes) {}\n\n    public function loadClassMetadata(\\Symfony\\Component\\Validator\\Mapping\\ClassMetadata $metadata): bool\n    {\n        return false;\n    }\n\n    /**\n     * @return list<string>\n     */\n    public function getMappedClasses(): array\n    {\n        return $this->classes;\n    }\n}\n\nfinal class FakeValidator implements ValidatorInterface\n{\n    private ClassMetadata $metadata;\n\n    /**\n     * @param list<SymfonyRegex> $constraints\n     */\n    public function __construct(array $constraints)\n    {\n        $this->metadata = new ClassMetadata(FakeEntity::class);\n        foreach ($constraints as $constraint) {\n            $this->metadata->addPropertyConstraint('name', $constraint);\n        }\n    }\n\n    public function getMetadataFor(mixed $value): ClassMetadata\n    {\n        return $this->metadata;\n    }\n\n    public function hasMetadataFor(mixed $value): bool\n    {\n        return true;\n    }\n\n    public function validate(mixed $value, Constraint|array|null $constraints = null, GroupSequence|array|string|null $groups = null): ConstraintViolationList\n    {\n        return new ConstraintViolationList();\n    }\n\n    public function validateProperty(object $object, string $propertyName, GroupSequence|array|string|null $groups = null): ConstraintViolationList\n    {\n        return new ConstraintViolationList();\n    }\n\n    public function validatePropertyValue(object|string $objectOrClass, string $propertyName, mixed $value, GroupSequence|array|string|null $groups = null): ConstraintViolationList\n    {\n        return new ConstraintViolationList();\n    }\n\n    public function startContext(): ContextualValidatorInterface\n    {\n        throw new \\BadMethodCallException('Not implemented.');\n    }\n\n    public function inContext(\\Symfony\\Component\\Validator\\Context\\ExecutionContextInterface $context): ContextualValidatorInterface\n    {\n        throw new \\BadMethodCallException('Not implemented.');\n    }\n}\n"
}
