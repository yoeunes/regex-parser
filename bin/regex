#!/usr/bin/env php
<?php

declare(strict_types=1);

/*
 * This file is part of the RegexParser package.
 *
 * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

if (version_compare('8.2.0', \PHP_VERSION, '>')) {
    fwrite(\STDERR, \sprintf('This version of RegexParser requires PHP >= 8.2.0.'.\PHP_EOL.'You are using PHP %s (%s).'.\PHP_EOL, \PHP_VERSION, \PHP_BINARY));

    exit(1);
}

$autoloadPath = null;
$autoloadPaths = [
    __DIR__.'/../../../../vendor/autoload.php',
    __DIR__.'/../../autoload.php',
    __DIR__.'/../vendor/autoload.php',
    __DIR__.'/vendor/autoload.php',
];

foreach ($autoloadPaths as $path) {
    if (file_exists($path)) {
        $autoloadPath = $path;

        break;
    }
}

if (null === $autoloadPath) {
    throw new \RuntimeException('Unable to locate autoload.php file.');
}

require_once $autoloadPath;

use RegexParser\Exception\InvalidRegexOptionException;
use RegexParser\Exception\LexerException;
use RegexParser\Exception\ParserException;
use RegexParser\Lint\Formatter\ConsoleFormatter;
use RegexParser\Lint\Formatter\FormatterRegistry;
use RegexParser\Lint\Formatter\OutputConfiguration;
use RegexParser\Lint\PhpRegexPatternSource;
use RegexParser\Lint\PhpStanExtractionStrategy;
use RegexParser\Lint\RegexAnalysisService;
use RegexParser\Lint\RegexLintRequest;
use RegexParser\Lint\RegexLintService;
use RegexParser\Lint\RegexPatternExtractor;
use RegexParser\Lint\RegexPatternSourceCollection;
use RegexParser\Lint\TokenBasedExtractionStrategy;
use RegexParser\NodeVisitor\ConsoleHighlighterVisitor;
use RegexParser\NodeVisitor\HtmlHighlighterVisitor;
use RegexParser\NodeVisitor\RailroadDiagramVisitor;
use RegexParser\OptimizationResult;
use RegexParser\Regex;
use RegexParser\RegexOptions;
use RegexParser\RegexPattern;
use RegexParser\ReDoS\ReDoSHeatmap;
use RegexParser\ReDoS\ReDoSInputGenerator;
use RegexParser\ReDoS\ReDoSHotspot;
use RegexParser\ReDoS\ReDoSSeverity;

// ANSI color codes
const RESET = "\033[0m";
const RED = "\033[31m";
const GREEN = "\033[32m";
const YELLOW = "\033[33m";
const BLUE = "\033[34m";
const MAGENTA = "\033[35m";
const CYAN = "\033[36m";
const WHITE = "\033[37m";
const GRAY = "\033[90m";
const BLACK = "\033[30m";
const BOLD = "\033[1m";
const BG_RED = "\033[41m";
const BG_GREEN = "\033[42m";
const BG_YELLOW = "\033[43m";
const BG_BLUE = "\033[44m";
const BG_CYAN = "\033[46m";
const BG_GRAY = "\033[100m";
const PROGRESS_BAR_WIDTH = 28;
const PROGRESS_BAR_FULL = "▓";
const PROGRESS_BAR_EMPTY = "░";

function color(string $text, string $color): string
{
    global $ansi;

    return $ansi ? $color.$text.RESET : $text;
}

function success(string $text): string
{
    return color($text, GREEN);
}

function error(string $text): string
{
    return color($text, RED);
}

function warning(string $text): string
{
    return color($text, YELLOW);
}

function info(string $text): string
{
    return color($text, BLUE);
}

function bold(string $text): string
{
    return color($text, BOLD);
}

function dim(string $text): string
{
    return color($text, GRAY);
}

function badge(string $text, string $fg, string $bg): string
{
    global $ansi;

    if (!$ansi) {
        return '['.$text.']';
    }

    return color(' '.$text.' ', $bg.$fg.BOLD);
}

function output(string $text): void
{
    global $quiet;

    if (!$quiet) {
        echo $text;
    }
}

function formatElapsed(int $seconds): string
{
    $seconds = max(0, $seconds);
    $hours = intdiv($seconds, 3600);
    $minutes = intdiv($seconds % 3600, 60);
    $secs = $seconds % 60;

    if ($hours > 0) {
        return \sprintf('%02d:%02d:%02d', $hours, $minutes, $secs);
    }

    return \sprintf('%02d:%02d', $minutes, $secs);
}

function progressStart(int $total): void
{
    global $progressTotal, $progressCurrent, $progressActive, $progressStartedAt, $ansi, $quiet;

    if ($total <= 0 || $quiet) {
        $progressActive = false;

        return;
    }

    $progressTotal = $total;
    $progressCurrent = 0;
    $progressActive = $ansi;
    $progressStartedAt = \time();

    if (!$progressActive) {
        return;
    }

    renderProgress();
}

function progressAdvance(int $step = 1): void
{
    global $progressTotal, $progressCurrent, $progressActive;

    if (!$progressActive) {
        return;
    }

    $progressCurrent = min($progressTotal, $progressCurrent + $step);
    renderProgress();
}

function progressFinish(): void
{
    global $progressTotal, $progressCurrent, $progressActive;

    if (!$progressActive) {
        return;
    }

    $progressCurrent = $progressTotal;
    renderProgress(true);
    $progressActive = false;
}

function renderProgress(bool $finish = false): void
{
    global $progressTotal, $progressCurrent, $progressStartedAt;

    $total = max(1, (int) $progressTotal);
    $current = min((int) $progressCurrent, $total);
    $ratio = $current / $total;
    $filled = (int) floor($ratio * PROGRESS_BAR_WIDTH);

    $bar = str_repeat(PROGRESS_BAR_FULL, $filled).str_repeat(PROGRESS_BAR_EMPTY, PROGRESS_BAR_WIDTH - $filled);
    $percent = (int) round($ratio * 100);
    $elapsed = formatElapsed((int) (\time() - (int) $progressStartedAt));
    $line = \sprintf(' %d/%d [%s] %3d%% %8s', $current, $total, $bar, $percent, $elapsed);

    output("\r".$line);

    if ($finish) {
        output("\n\n");
    }

    if (\function_exists('fflush')) {
        fflush(\STDOUT);
    }
}

function showHelp(): void
{
    output(color('Regex Parser', CYAN)."\n");
    output(color(str_repeat('=', 12), CYAN)."\n\n");

    output(color('Description:', MAGENTA)."\n");
    output('  '.bold('CLI for regex parsing, validation, analysis, and linting')."\n\n");

    output(color('Usage:', MAGENTA)."\n");
    output('  regex '.color('<command>', YELLOW).' '.color('[options]', CYAN).' '.color('<pattern>', GREEN)."\n\n");

    output(color('Commands:', MAGENTA)."\n");
    output('  '.info('parse')."       Parse and recompile a regex pattern\n");
    output('  '.info('analyze')."     Parse, validate, and analyze ReDoS risk\n");
    output('  '.info('debug')."       Deep ReDoS analysis with heatmap output\n");
    output('  '.info('diagram')."     Render an ASCII diagram of the AST\n");
    output('  '.info('highlight')."   Highlight a regex for display\n");
    output('  '.info('validate')."    Validate a regex pattern\n");
    output('  '.info('lint')."        Lint regex patterns in PHP source code\n");
    output('  '.info('help')."        Display this help message\n\n");

    output(color('Global Options:', MAGENTA)."\n");
    output('  '.color('--ansi', CYAN)."            Force ANSI output\n");
    output('  '.color('--no-ansi', CYAN)."         Disable ANSI output\n");
    output('  '.color('-q, --quiet', CYAN)."       Suppress output\n");
    output('  '.color('--silent', CYAN)."          Same as --quiet\n");
    output('  '.color('--php-version', CYAN)." <ver>  Target PHP version for validation\n");
    output('  '.color('--help', CYAN)."            Display this help message\n\n");

    output(color('Lint Options:', MAGENTA)."\n");
    output('  '.color('--exclude', CYAN)." <path>       Paths to exclude (repeatable)\n");
    output('  '.color('--min-savings', CYAN)." <n>     Minimum optimization savings\n");
    output('  '.color('--jobs', CYAN)." <n>           Parallel workers for analysis\n");
    output('  '.color('--format', CYAN)." <format>     Output format (console, json, github, checkstyle, junit)\n");
    output('  '.color('--no-redos', CYAN)."           Skip ReDoS risk analysis\n");
    output('  '.color('--no-validate', CYAN)."        Skip validation errors (structural lint only)\n");
    output('  '.color('--no-optimize', CYAN)."        Disable optimization suggestions\n");
    output('  '.color('-v, --verbose', CYAN)."         Show detailed output\n");
    output('  '.color('--debug', CYAN)."              Show debug information\n\n");
    output(dim('  Config: regex.json or regex.dist.json in the working directory sets lint defaults.')."\n");
    output(dim('  Inline ignore: // @regex-ignore-next-line or // @regex-ignore')."\n\n");

    output(color('Diagram Options:', MAGENTA)."\n");
    output('  '.color('--format', CYAN)." <format>     Output format (ascii)\n\n");

    output(color('Debug Options:', MAGENTA)."\n");
    output('  '.color('--input', CYAN)." <string>     Input string to test against the pattern\n\n");

    output(color('Examples:', MAGENTA)."\n");
    output('  '.color('regex', BLUE).' '.color("'/a+'", GREEN)."                           # Quick highlight\n");
    output('  '.color('regex', BLUE).' '.color('parse', YELLOW).' '.color("'/a+'", GREEN).' '.color('--validate', CYAN)."          # Parse with validation\n");
    output('  '.color('regex', BLUE).' '.color('analyze', YELLOW).' '.color("'/a+'", GREEN)."                   # Full analysis\n");
    output('  '.color('regex', BLUE).' '.color('diagram', YELLOW).' '.color("'/^a+$/'", GREEN)."                # ASCII diagram\n");
    output('  '.color('regex', BLUE).' '.color('debug', YELLOW).' '.color("'/(a+)+$/'", GREEN)."              # Heatmap + ReDoS details\n");
    output('  '.color('regex', BLUE).' '.color('highlight', YELLOW).' '.color("'/a+'", GREEN).' '.color('--format=html', CYAN)."   # HTML highlight\n");
    output('  '.color('regex', BLUE).' '.color('lint', YELLOW).' '.color('src/', GREEN).' '.color('--exclude=vendor', CYAN)."       # Lint a codebase\n");
    output('  '.color('regex', BLUE).' '.color('lint', YELLOW).' '.color('--format=json', CYAN).' '.color('src/', GREEN)."           # JSON output\n");
    output('  '.color('regex', BLUE).' '.color('lint', YELLOW).' '.color('--verbose', CYAN).' '.color('src/', GREEN)."              # Verbose output\n");
}

function outputVersion(): void
{
    $versionFile = __DIR__.'/../composer.json';
    if (!file_exists($versionFile)) {
        output('  '.color('Error:', RED)." unable to read version information.\n");
        exit(1);
    }

    $composerData = json_decode(file_get_contents($versionFile), true);
    $version = $composerData['version'] ?? '1.0.0';

    output('RegexParser '.color($version, GREEN)." by Younes ENNAJI\n");
    output("https://github.com/yoeunes/regex-parser\n");
}

function createRegex(array $options): Regex
{
    try {
        return Regex::create($options);
    } catch (InvalidRegexOptionException $e) {
        output(error('Invalid option: '.$e->getMessage()."\n"));
        exit(1);
    }
}

function extractGlobalOptions(array $args): array
{
    $options = [
        'quiet' => false,
        'ansi' => null,
        'help' => false,
        'phpVersion' => null,
        'error' => null,
    ];
    $remaining = [];

    for ($i = 0; $i < \count($args); $i++) {
        $arg = $args[$i];

        if ('-q' === $arg || '--quiet' === $arg || '--silent' === $arg) {
            $options['quiet'] = true;

            continue;
        }

        if ('--ansi' === $arg) {
            $options['ansi'] = true;

            continue;
        }

        if ('--no-ansi' === $arg) {
            $options['ansi'] = false;

            continue;
        }

        if ('--help' === $arg || '-h' === $arg) {
            $options['help'] = true;

            continue;
        }

        if (str_starts_with($arg, '--php-version=')) {
            $options['phpVersion'] = substr($arg, \strlen('--php-version='));

            continue;
        }

        if ('--php-version' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                $options['error'] = 'Missing value for --php-version.';

                break;
            }
            $options['phpVersion'] = $value;
            $i++;

            continue;
        }

        $remaining[] = $arg;
    }

    return [$options, $remaining];
}

function resolveAnsi(?bool $forced): bool
{
    if (null !== $forced) {
        return $forced;
    }

    return \function_exists('posix_isatty') && posix_isatty(\STDOUT);
}

function relativePath(string $path): string
{
    $normalizedPath = str_replace('\\', '/', $path);
    $cwd = getcwd();
    if (false === $cwd) {
        return $normalizedPath;
    }

    $normalizedCwd = rtrim(str_replace('\\', '/', $cwd), '/');
    if ('' === $normalizedCwd) {
        return $normalizedPath;
    }

    $prefix = $normalizedCwd.'/';
    if (str_starts_with($normalizedPath, $prefix)) {
        return substr($normalizedPath, \strlen($prefix));
    }

    return $normalizedPath;
}

function renderSummary(array $stats, bool $isEmpty = false): void
{
    output("\n");

    if ($isEmpty) {
        output('  '.badge('PASS', WHITE, BG_GREEN).' '.dim('No regex patterns found.')."\n");
        showFooter();

        return;
    }

    $errors = $stats['errors'];
    $warnings = $stats['warnings'];
    $optimizations = $stats['optimizations'];

    if ($errors > 0) {
        output('  '.badge('FAIL', WHITE, BG_RED).' '.color(\sprintf('%d invalid patterns', $errors), RED.BOLD)
            .dim(\sprintf(', %d warnings, %d optimizations.', $warnings, $optimizations))
            ."\n");
    } elseif ($warnings > 0) {
        output('  '.badge('PASS', BLACK, BG_YELLOW).' '.color(\sprintf('%d warnings found', $warnings), YELLOW.BOLD)
            .dim(\sprintf(', %d optimizations available.', $optimizations))
            ."\n");
    } else {
        output('  '.badge('PASS', WHITE, BG_GREEN).' '.color('No issues found', GREEN.BOLD)
            .dim(\sprintf(', %d optimizations available.', $optimizations))
            ."\n");
    }

    showFooter();
}

function showFooter(): void
{
    output("\n");
    output('  '.dim('Star the repo: https://github.com/yoeunes/regex-parser')."\n\n");
}

function renderLintBanner(int $jobs = 1, array $configFiles = []): string
{
    $versionFile = __DIR__.'/../composer.json';
    $version = 'dev';
    if (file_exists($versionFile)) {
        $composerData = json_decode(file_get_contents($versionFile), true);
        $version = $composerData['version'] ?? 'dev';
    }

    $output = color('RegexParser', CYAN.BOLD).' '.warning($version).' by Younes ENNAJI'."\n\n";
    $output .= 'Runtime:       PHP '.warning(\PHP_VERSION)."\n";
    $output .= 'Processes:     '.warning((string) $jobs)."\n";

    if ([] !== $configFiles) {
        $paths = array_map(static fn (string $path): string => relativePath($path), $configFiles);
        $output .= 'Configuration: '.implode(', ', $paths)."\n";
    }

    $output .= "\n";
    
    return $output;
}

function loadLintConfig(): array
{
    $cwd = getcwd();
    if (false === $cwd) {
        return ['config' => [], 'files' => []];
    }

    $config = [];
    $files = [];
    $paths = [$cwd.'/regex.dist.json', $cwd.'/regex.json'];

    foreach ($paths as $path) {
        if (!file_exists($path)) {
            continue;
        }

        $readResult = readLintConfigFile($path);
        if (isset($readResult['error'])) {
            return ['error' => $readResult['error']];
        }

        $normalized = normalizeLintConfig($readResult['config'], $path);
        if (isset($normalized['error'])) {
            return ['error' => $normalized['error']];
        }

        $config = array_replace_recursive($config, $normalized['config']);
        $files[] = $path;
    }

    return ['config' => $config, 'files' => $files];
}

/**
 * @return array{config: array<string, mixed>}|array{error: string}
 */
function readLintConfigFile(string $path): array
{
    $contents = @file_get_contents($path);
    if (false === $contents) {
        return ['error' => 'Failed to read config file: '.$path];
    }

    $decoded = json_decode($contents, true);
    if (null === $decoded && JSON_ERROR_NONE !== json_last_error()) {
        return ['error' => 'Invalid JSON in '.$path.': '.json_last_error_msg()];
    }

    if (!\is_array($decoded)) {
        return ['error' => 'Config file must contain a JSON object: '.$path];
    }

    return ['config' => $decoded];
}

/**
 * @param array<string, mixed> $config
 *
 * @return array{config: array<string, mixed>}|array{error: string}
 */
function normalizeLintConfig(array $config, string $path): array
{
    $normalized = [];

    if (array_key_exists('paths', $config)) {
        $paths = normalizeStringList($config['paths'], $path, 'paths');
        if (isset($paths['error'])) {
            return $paths;
        }
        $normalized['paths'] = $paths['values'];
    }

    if (array_key_exists('exclude', $config)) {
        $exclude = normalizeStringList($config['exclude'], $path, 'exclude');
        if (isset($exclude['error'])) {
            return $exclude;
        }
        $normalized['exclude'] = $exclude['values'];
    }

    if (array_key_exists('jobs', $config)) {
        if (!\is_int($config['jobs'])) {
            return ['error' => 'Invalid "jobs" in '.$path.': expected an integer.'];
        }
        if ($config['jobs'] < 1) {
            return ['error' => 'Invalid "jobs" in '.$path.': value must be >= 1.'];
        }
        $normalized['jobs'] = $config['jobs'];
    }

    if (array_key_exists('minSavings', $config)) {
        if (!\is_int($config['minSavings'])) {
            return ['error' => 'Invalid "minSavings" in '.$path.': expected an integer.'];
        }
        if ($config['minSavings'] < 1) {
            return ['error' => 'Invalid "minSavings" in '.$path.': value must be >= 1.'];
        }
        $normalized['minSavings'] = $config['minSavings'];
    }

    if (array_key_exists('format', $config)) {
        if (!\is_string($config['format']) || '' === $config['format']) {
            return ['error' => 'Invalid "format" in '.$path.': expected a non-empty string.'];
        }
        $normalized['format'] = $config['format'];
    }

    if (array_key_exists('rules', $config)) {
        if (!\is_array($config['rules'])) {
            return ['error' => 'Invalid "rules" in '.$path.': expected an object.'];
        }

        $rules = [];
        foreach (['redos', 'validation', 'optimization'] as $ruleKey) {
            if (!array_key_exists($ruleKey, $config['rules'])) {
                continue;
            }
            if (!\is_bool($config['rules'][$ruleKey])) {
                return ['error' => 'Invalid "rules.'.$ruleKey.'" in '.$path.': expected a boolean.'];
            }
            $rules[$ruleKey] = $config['rules'][$ruleKey];
        }

        if ([] !== $rules) {
            $normalized['rules'] = $rules;
        }
    }

    return ['config' => $normalized];
}

/**
 * @return array{values: array<int, string>}|array{error: string}
 */
function normalizeStringList(mixed $value, string $path, string $key): array
{
    if (\is_string($value)) {
        $value = [$value];
    }

    if (!\is_array($value)) {
        return ['error' => 'Invalid "'.$key.'" in '.$path.': expected an array of strings.'];
    }

    $normalized = [];
    foreach ($value as $entry) {
        if (!\is_string($entry) || '' === $entry) {
            return ['error' => 'Invalid "'.$key.'" in '.$path.': expected an array of strings.'];
        }
        $normalized[] = $entry;
    }

    return ['values' => $normalized];
}

/**
 * @param array<string, mixed> $config
 *
 * @return array<string, mixed>
 */
function buildLintDefaults(array $config): array
{
    $defaults = [];

    if (isset($config['paths'])) {
        $defaults['paths'] = $config['paths'];
    }

    if (isset($config['exclude'])) {
        $defaults['exclude'] = $config['exclude'];
    }

    if (isset($config['jobs'])) {
        $defaults['jobs'] = $config['jobs'];
    }

    if (isset($config['minSavings'])) {
        $defaults['minSavings'] = $config['minSavings'];
    }

    if (isset($config['format'])) {
        $defaults['format'] = $config['format'];
    }

    if (isset($config['rules']) && \is_array($config['rules'])) {
        if (array_key_exists('redos', $config['rules'])) {
            $defaults['checkRedos'] = $config['rules']['redos'];
        }
        if (array_key_exists('validation', $config['rules'])) {
            $defaults['checkValidation'] = $config['rules']['validation'];
        }
        if (array_key_exists('optimization', $config['rules'])) {
            $defaults['checkOptimizations'] = $config['rules']['optimization'];
        }
    }

    return $defaults;
}

function createExtractor(): RegexPatternExtractor
{
    $parserFactoryClass = \PhpParser\ParserFactory::class;

    if (class_exists($parserFactoryClass)) {
        return new RegexPatternExtractor(new PhpStanExtractionStrategy());
    }

    return new RegexPatternExtractor(new TokenBasedExtractionStrategy());
}

function parseLintArgs(array $args, array $defaults = []): array
{
    $paths = $defaults['paths'] ?? [];
    $exclude = $defaults['exclude'] ?? [];
    $minSavings = $defaults['minSavings'] ?? 1;
    $verbosity = $defaults['verbosity'] ?? OutputConfiguration::VERBOSITY_NORMAL;
    $format = $defaults['format'] ?? 'console';
    $quiet = $defaults['quiet'] ?? false;
    $checkRedos = $defaults['checkRedos'] ?? true;
    $checkValidation = $defaults['checkValidation'] ?? true;
    $checkOptimizations = $defaults['checkOptimizations'] ?? true;
    $jobs = $defaults['jobs'] ?? 1;
    $pathsProvided = false;

    for ($i = 0; $i < \count($args); $i++) {
        $arg = $args[$i];

        if ('--help' === $arg || '-h' === $arg) {
            return ['help' => true];
        }

        if ('--quiet' === $arg || '-q' === $arg) {
            $quiet = true;
            $verbosity = OutputConfiguration::VERBOSITY_QUIET;

            continue;
        }

        if ('--verbose' === $arg || '-v' === $arg) {
            $verbosity = OutputConfiguration::VERBOSITY_VERBOSE;

            continue;
        }

        if ('--debug' === $arg) {
            $verbosity = OutputConfiguration::VERBOSITY_DEBUG;

            continue;
        }

        if ('--no-redos' === $arg) {
            $checkRedos = false;

            continue;
        }

        if ('--no-validate' === $arg) {
            $checkValidation = false;

            continue;
        }

        if ('--no-optimize' === $arg) {
            $checkOptimizations = false;

            continue;
        }

        if (str_starts_with($arg, '--format=')) {
            $format = substr($arg, \strlen('--format='));

            continue;
        }

        if ('--format' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --format.'];
            }
            $format = $value;
            $i++;

            continue;
        }

        if (str_starts_with($arg, '--exclude=')) {
            $exclude[] = substr($arg, \strlen('--exclude='));

            continue;
        }

        if ('--exclude' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --exclude.'];
            }
            $exclude[] = $value;
            $i++;

            continue;
        }

        if (str_starts_with($arg, '--min-savings=')) {
            $minSavings = (int) substr($arg, \strlen('--min-savings='));

            continue;
        }

        if (str_starts_with($arg, '--jobs=')) {
            $jobs = (int) substr($arg, \strlen('--jobs='));
            if ($jobs < 1) {
                return ['error' => 'The --jobs value must be a positive integer.'];
            }

            continue;
        }

        if ('--min-savings' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --min-savings.'];
            }
            $minSavings = (int) $value;
            $i++;

            continue;
        }

        if ('--jobs' === $arg || '-j' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --jobs.'];
            }
            $jobs = (int) $value;
            if ($jobs < 1) {
                return ['error' => 'The --jobs value must be a positive integer.'];
            }
            $i++;

            continue;
        }

        if (str_starts_with($arg, '-')) {
            return ['error' => 'Unknown option: '.$arg];
        }

        if (!$pathsProvided) {
            $paths = [];
            $pathsProvided = true;
        }
        $paths[] = $arg;
    }

    return [
        'paths' => $paths,
        'exclude' => $exclude,
        'minSavings' => $minSavings,
        'verbosity' => $verbosity,
        'format' => $format,
        'quiet' => $quiet,
        'checkRedos' => $checkRedos,
        'checkValidation' => $checkValidation,
        'checkOptimizations' => $checkOptimizations,
        'jobs' => $jobs,
    ];
}

$args = $argv;
array_shift($args);
[$globalOptions, $args] = extractGlobalOptions($args);
$quiet = $globalOptions['quiet'];
$ansi = resolveAnsi($globalOptions['ansi']);
$phpVersionOption = $globalOptions['phpVersion'];
$regexOptions = null !== $phpVersionOption ? ['php_version' => $phpVersionOption] : [];

if (null !== $globalOptions['error']) {
    output(error('Error: '.$globalOptions['error']."\n"));
    exit(1);
}

if ($globalOptions['help']) {
    showHelp();
    exit(0);
}

if ([] === $args) {
    showHelp();
    exit(1);
}

$command = $args[0] ?? null;
$commandArgs = \array_slice($args, 1);

$pattern = '';
if (str_starts_with($command, '/')) {
    $pattern = $command;
    $command = 'highlight';
} else {
    $pattern = $commandArgs[0] ?? '';
}

switch ($command) {
    case 'help':
    case '--help':
    case '-h':
        showHelp();
        exit(0);

    case 'version':
    case '--version':
    case '-v':
        outputVersion();
        exit(0);

    case 'parse':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex parse <pattern> [--validate]\n");
            exit(1);
        }
        $validate = \in_array('--validate', $commandArgs, true);
        $regex = createRegex($regexOptions);

        try {
            $ast = $regex->parse($pattern);
            $compiled = $ast->accept(new RegexParser\NodeVisitor\CompilerNodeVisitor());

            output(bold("Parse\n"));
            output('  Pattern:    '.$pattern."\n");
            output('  Recompiled: '.$compiled."\n");

            if ($validate) {
                $validation = $regex->validate($pattern);
                $status = $validation->isValid ? success('OK') : error('INVALID');
                output('  Validation: '.$status."\n");
                if (!$validation->isValid && $validation->error) {
                    output('  '.error($validation->error)."\n");
                }
            }
        } catch (LexerException|ParserException $e) {
            output(error('Parse failed: '.$e->getMessage()."\n"));
            exit(1);
        }

        break;

    case 'analyze':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex analyze <pattern>\n");
            exit(1);
        }
        $regex = createRegex($regexOptions);

        try {
            $ast = $regex->parse($pattern);
            $validation = $regex->validate($pattern);
            $analysis = $regex->redos($pattern);
            $explain = $regex->explain($pattern);

            output(bold("Analyze\n"));
            output('  Pattern:    '.$pattern."\n");
            output('  Parse:      '.success('OK')."\n");
            $validationStatus = $validation->isValid ? success('OK') : error('INVALID');
            output('  Validation: '.$validationStatus."\n");
            if (!$validation->isValid && $validation->error) {
                output('  '.error($validation->error)."\n");
            }

            $severityLabel = strtoupper($analysis->severity->value);
            output('  ReDoS:      '.warning($severityLabel).' (score '.$analysis->score.")\n");
            if ($analysis->error) {
                output('  '.error('ReDoS error: '.$analysis->error)."\n");
            }

            output("\n".bold('Explanation')."\n");
            output($explain."\n");
        } catch (LexerException|ParserException $e) {
            output(error('Analyze failed: '.$e->getMessage()."\n"));
            exit(1);
        }

        break;

    case 'debug':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex debug <pattern> [--input <string>]\n");
            exit(1);
        }

        $input = null;
        for ($i = 0; $i < \count($commandArgs); $i++) {
            $arg = $commandArgs[$i];
            if (str_starts_with($arg, '--input=')) {
                $input = substr($arg, \strlen('--input='));

                continue;
            }
            if ('--input' === $arg) {
                $value = $commandArgs[$i + 1] ?? '';
                if ('' === $value || str_starts_with($value, '-')) {
                    output(error("Error: Missing value for --input\n"));
                    exit(1);
                }
                $input = $value;
                $i++;
            }
        }

        $regex = createRegex($regexOptions);
        $phpVersionId = null;
        if ([] !== $regexOptions) {
            $phpVersionId = RegexOptions::fromArray($regexOptions)->phpVersionId;
        }

        try {
            $patternInfo = RegexPattern::fromDelimited($pattern, $phpVersionId);
            $analysis = $regex->redos($pattern);
            $heatmap = new ReDoSHeatmap();
            $heatmapBody = $heatmap->highlight($patternInfo->pattern, $analysis->hotspots, $ansi);
            $heatmapPattern = $patternInfo->delimiter.$heatmapBody.$patternInfo->delimiter.$patternInfo->flags;

            output(bold("Debug\n"));
            output('  Pattern:    '.$heatmapPattern."\n");

            if (null !== $analysis->error) {
                output('  Error:      '.error($analysis->error)."\n");
            }

            $severityLabel = strtoupper($analysis->severity->value);
            $severityOutput = match ($analysis->severity) {
                ReDoSSeverity::SAFE, ReDoSSeverity::LOW => success($severityLabel),
                ReDoSSeverity::MEDIUM => warning($severityLabel),
                ReDoSSeverity::HIGH, ReDoSSeverity::CRITICAL => error($severityLabel),
                ReDoSSeverity::UNKNOWN => info($severityLabel),
            };

            output('  ReDoS:      '.$severityOutput.' (score '.$analysis->score.")\n");

            if (null !== $analysis->getVulnerableSubpattern()) {
                output('  Culprit:    '.$analysis->getVulnerableSubpattern()."\n");
            }

            if (null !== $analysis->trigger && '' !== $analysis->trigger) {
                output('  Trigger:    '.$analysis->trigger."\n");
            }

            if ([] !== $analysis->hotspots) {
                output('  Hotspots:   '.\count($analysis->hotspots)."\n");
            }

            $inputSource = '';
            if (null === $input && null !== $analysis->getCulpritNode()) {
                $input = (new ReDoSInputGenerator())->generate(
                    $analysis->getCulpritNode(),
                    $patternInfo->flags,
                    $analysis->severity,
                );
                $inputSource = ' (auto)';
            }

            if (null !== $input) {
                $escaped = addcslashes($input, "\0..\37\177..\377");
                output('  Input:      "'.$escaped.'"'.$inputSource."\n");
            }

            $hotspot = null;
            $hotspotRank = -1;
            foreach ($analysis->hotspots as $candidate) {
                if (!$candidate instanceof ReDoSHotspot) {
                    continue;
                }
                $rank = match ($candidate->severity) {
                    ReDoSSeverity::SAFE => 0,
                    ReDoSSeverity::LOW => 1,
                    ReDoSSeverity::MEDIUM => 2,
                    ReDoSSeverity::HIGH => 3,
                    ReDoSSeverity::CRITICAL => 4,
                    ReDoSSeverity::UNKNOWN => 1,
                };
                if ($rank > $hotspotRank) {
                    $hotspotRank = $rank;
                    $hotspot = $candidate;
                }
            }

            if (null !== $hotspot) {
                $prefix = '  Pattern:    ';
                $start = max(0, $hotspot->start);
                $length = max(1, $hotspot->end - $hotspot->start);
                $caret = str_repeat(' ', \strlen($prefix) + 1 + $start).str_repeat('^', $length);
                $caretColor = match ($hotspot->severity) {
                    ReDoSSeverity::SAFE, ReDoSSeverity::LOW => GREEN,
                    ReDoSSeverity::MEDIUM => YELLOW,
                    ReDoSSeverity::HIGH, ReDoSSeverity::CRITICAL => RED,
                    ReDoSSeverity::UNKNOWN => GRAY,
                };
                output(color($caret, $caretColor)."\n");
            }

            if ([] !== $analysis->findings) {
                output("\n".bold('Findings')."\n");
                foreach ($analysis->findings as $finding) {
                    $label = strtoupper($finding->severity->value);
                    $findingSeverity = match ($finding->severity) {
                        ReDoSSeverity::SAFE, ReDoSSeverity::LOW => success($label),
                        ReDoSSeverity::MEDIUM => warning($label),
                        ReDoSSeverity::HIGH, ReDoSSeverity::CRITICAL => error($label),
                        ReDoSSeverity::UNKNOWN => info($label),
                    };
                    output('  - ['.$findingSeverity.'] '.$finding->message."\n");
                    if (null !== $finding->suggestedRewrite && '' !== $finding->suggestedRewrite) {
                        output('      Suggested: '.$finding->suggestedRewrite."\n");
                    }
                }
            }
        } catch (LexerException|ParserException $e) {
            output(error('Debug failed: '.$e->getMessage()."\n"));
            exit(1);
        } catch (Throwable $e) {
            output(error('Debug failed: '.$e->getMessage()."\n"));
            exit(1);
        }

        break;

    case 'diagram':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex diagram <pattern> [--format=ascii]\n");
            exit(1);
        }

        $format = 'ascii';
        for ($i = 0; $i < \count($commandArgs); $i++) {
            $arg = $commandArgs[$i];
            if (str_starts_with($arg, '--format=')) {
                $format = substr($arg, \strlen('--format='));

                break;
            }
            if ('--format' === $arg) {
                $format = $commandArgs[$i + 1] ?? $format;
                $i++;
            }
        }

        if (!\in_array($format, ['ascii', 'cli'], true)) {
            output(error("Error: Unsupported format '{$format}'. Use --format=ascii.\n"));
            exit(1);
        }

        $regex = createRegex($regexOptions);

        try {
            $ast = $regex->parse($pattern);
            $diagram = $ast->accept(new RailroadDiagramVisitor());
            output($diagram."\n");
        } catch (LexerException|ParserException $e) {
            output(error('Diagram failed: '.$e->getMessage()."\n"));
            exit(1);
        }

        break;

    case 'highlight':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex highlight <pattern> [--format=auto|cli|html]\n");
            exit(1);
        }
        $format = 'auto';
        for ($i = 0; $i < \count($commandArgs); $i++) {
            $arg = $commandArgs[$i];
            if (str_starts_with($arg, '--format=')) {
                $format = substr($arg, 9);

                break;
            }
            if ('--format' === $arg) {
                $format = $commandArgs[$i + 1] ?? $format;
                $i++;
            }
        }
        $regex = createRegex($regexOptions);

        try {
            if ('auto' === $format) {
                $format = \PHP_SAPI === 'cli' ? 'cli' : 'html';
            }

            $visitor = match ($format) {
                'cli' => new ConsoleHighlighterVisitor(),
                'html' => new HtmlHighlighterVisitor(),
                default => throw new \InvalidArgumentException("Invalid format: $format"),
            };

            $ast = $regex->parse($pattern);
            $highlighted = $ast->accept($visitor);

            output($highlighted."\n");
        } catch (LexerException|ParserException $e) {
            output(error("✗ Error: {$e->getMessage()}\n"));
            exit(1);
        }

        break;

    case 'validate':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex validate <pattern>\n");
            exit(1);
        }
        $regex = createRegex($regexOptions);

        $validation = $regex->validate($pattern);
        if ($validation->isValid) {
            output(success('OK').'  '.$pattern."\n");
            break;
        }

        output(error('INVALID').'  '.$pattern."\n");
        if ($validation->error) {
            output('  '.error($validation->error)."\n");
        }

        exit(1);

        break;

    case 'lint':
        $lintConfigResult = loadLintConfig();
        if (isset($lintConfigResult['error'])) {
            output(error('Error: '.$lintConfigResult['error']."\n"));
            exit(1);
        }
        $lintDefaults = buildLintDefaults($lintConfigResult['config'] ?? []);
        $lintConfigFiles = $lintConfigResult['files'] ?? [];

        $parsed = parseLintArgs($commandArgs, $lintDefaults);
        if (isset($parsed['help'])) {
            showHelp();
            exit(0);
        }
        if (isset($parsed['error'])) {
            output(error('Error: '.$parsed['error']."\n"));
            output("Usage: regex lint [paths...] [--exclude <path>] [--min-savings <n>] [--jobs <n>] [--format console|json|github|checkstyle|junit] [--no-redos] [--no-validate] [--no-optimize] [--verbose|--debug|--quiet]\n");
            exit(1);
        }

        $paths = $parsed['paths'] ?? [];
        $exclude = $parsed['exclude'] ?? [];
        $minSavings = (int) ($parsed['minSavings'] ?? 1);
        $verbosity = $parsed['verbosity'] ?? OutputConfiguration::VERBOSITY_NORMAL;
        $format = $parsed['format'] ?? 'console';
        $quiet = $parsed['quiet'] ?? false;
        $checkRedos = $parsed['checkRedos'] ?? true;
        $checkValidation = $parsed['checkValidation'] ?? true;
        $checkOptimizations = $parsed['checkOptimizations'] ?? true;
        $jobs = (int) ($parsed['jobs'] ?? 1);

        if ([] === $paths) {
            $paths = ['.'];
        }
        if ([] === $exclude && !array_key_exists('exclude', $lintDefaults)) {
            $exclude = ['vendor'];
        }

        // Create output configuration
        $config = match ($verbosity) {
            OutputConfiguration::VERBOSITY_QUIET => OutputConfiguration::quiet(),
            OutputConfiguration::VERBOSITY_VERBOSE => OutputConfiguration::verbose(),
            OutputConfiguration::VERBOSITY_DEBUG => OutputConfiguration::debug(),
            default => new OutputConfiguration(ansi: $ansi),
        };

        // Get formatter
        $formatterRegistry = new FormatterRegistry();
        if (!$formatterRegistry->has($format)) {
            output(error(\sprintf('Unknown format: %s. Available formats: %s', $format, implode(', ', $formatterRegistry->getNames()))."\n"));
            exit(1);
        }
        $formatter = $formatterRegistry->get($format);

        // Update console formatter with analysis service for highlighting
        if ('console' === $format) {
            $analysis = new RegexAnalysisService(createRegex($regexOptions));
            $formatter = new ConsoleFormatter($analysis, $config);
        }

        $analysis = new RegexAnalysisService(createRegex($regexOptions));
        $extractor = createExtractor();
        $sources = new RegexPatternSourceCollection([
            new PhpRegexPatternSource($extractor),
        ]);
        $lint = new RegexLintService($analysis, $sources);

        if ('console' === $format && OutputConfiguration::VERBOSITY_QUIET !== $verbosity) {
            echo renderLintBanner($jobs, $lintConfigFiles);
        }

        $collectionProgress = null;
        $startTime = microtime(true);
        $startMemory = memory_get_peak_usage(true);
        $collectionStartTime = $startTime;
        
        if ('console' === $format && $config->shouldShowProgress()) {
            output('  '.dim('[1/2] Collecting patterns')."\n");
            $collectionStarted = false;
            $lastCount = 0;
            $collectionProgress = static function (int $current, int $total) use (&$collectionStarted, &$lastCount): void {
                if ($total <= 0) {
                    return;
                }

                if (!$collectionStarted) {
                    progressStart($total);
                    $collectionStarted = true;
                }

                $advance = $current - $lastCount;
                if ($advance > 0) {
                    progressAdvance($advance);
                    $lastCount = $current;
                }

                if ($collectionStarted && $current >= $total) {
                    progressFinish();
                }
            };
        }

        try {
            $request = new RegexLintRequest(
                paths: $paths,
                excludePaths: $exclude,
                minSavings: $minSavings,
                checkValidation: $checkValidation,
                checkRedos: $checkRedos,
                checkOptimizations: $checkOptimizations,
                analysisWorkers: $jobs,
            );
            $patterns = $lint->collectPatterns($request, $collectionProgress);
        } catch (Throwable $e) {
            output(error("Failed to collect patterns: {$e->getMessage()}\n"));
            exit(1);
        }

        $collectionTime = microtime(true) - $collectionStartTime;

        if ([] === $patterns) {
            if ($format === 'console') {
                renderSummary(['errors' => 0, 'warnings' => 0, 'optimizations' => 0], true);
                exit(0);
            }

            $emptyReport = new \RegexParser\Lint\RegexLintReport([], ['errors' => 0, 'warnings' => 0, 'optimizations' => 0]);
            echo $formatter->format($emptyReport);
            exit(0);
        }

        if ('console' === $format && $config->shouldShowProgress() && $collectionTime > 1) {
            $collectionInfo = 'Collection: '.round($collectionTime, 2).'s';
            if ($jobs > 1) {
                $collectionInfo .= ' (parallel: '.$jobs.' workers)';
            }
            output('  '.dim($collectionInfo)."\n\n");
        }

        $progressCallback = null;
        $analysisStartTime = microtime(true);
        if ('console' === $format && $config->shouldShowProgress()) {
            output('  '.dim('[2/2] Analyzing patterns')."\n");
            progressStart(\count($patterns));
            $progressCallback = static fn () => progressAdvance();
        }

        $report = $lint->analyze($patterns, $request, $progressCallback);

        if (null !== $progressCallback) {
            progressFinish();
        }

        $analysisTime = microtime(true) - $analysisStartTime;

        if ('console' === $format && $config->shouldShowProgress() && $analysisTime > 0.1) {
            $analysisInfo = 'Analysis: '.round($analysisTime, 2).'s';
            if ($jobs > 1) {
                $analysisInfo .= ' (parallel: '.$jobs.' workers)';
            }
            output('  '.dim($analysisInfo)."\n");
        }

        // Output using formatter
        echo $formatter->format($report);
        echo $formatter->getSummary($report->stats);
        $elapsed = microtime(true) - $startTime;
        $peakMemory = memory_get_peak_usage(true);
        output("  ".bold("Time: ".round($elapsed, 2)."s | Memory: ".round($peakMemory / 1024 / 1024, 2)." MB")."\n");
        output("\n");
        echo $formatter->formatFooter();

        exit($report->stats['errors'] > 0 ? 1 : 0);

    default:
        output(error("Unknown command: {$command}\n\n"));
        showHelp();
        exit(1);
}
