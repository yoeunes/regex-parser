#!/usr/bin/env php
<?php

declare(strict_types=1);

/*
 * This file is part of the RegexParser package.
 *
 * (c) Younes ENNAJI <younes.ennaji.pro@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

if (version_compare('8.2.0', \PHP_VERSION, '>')) {
    fwrite(\STDERR, \sprintf('This version of RegexParser requires PHP >= 8.2.0.'.\PHP_EOL.'You are using PHP %s (%s).'.\PHP_EOL, \PHP_VERSION, \PHP_BINARY));

    exit(1);
}

$autoloadPath = null;
$autoloadPaths = [
    __DIR__.'/../../../../vendor/autoload.php',
    __DIR__.'/../../autoload.php',
    __DIR__.'/../vendor/autoload.php',
    __DIR__.'/vendor/autoload.php',
];

foreach ($autoloadPaths as $path) {
    if (file_exists($path)) {
        $autoloadPath = $path;

        break;
    }
}

if (null === $autoloadPath) {
    throw new \RuntimeException('Unable to locate autoload.php file.');
}

require_once $autoloadPath;

use RegexParser\Exception\LexerException;
use RegexParser\Exception\ParserException;
use RegexParser\Lint\Formatter\ConsoleFormatter;
use RegexParser\Lint\Formatter\FormatterRegistry;
use RegexParser\Lint\Formatter\OutputConfiguration;
use RegexParser\Lint\PhpRegexPatternSource;
use RegexParser\Lint\PhpStanExtractionStrategy;
use RegexParser\Lint\RegexAnalysisService;
use RegexParser\Lint\RegexLintRequest;
use RegexParser\Lint\RegexLintService;
use RegexParser\Lint\RegexPatternExtractor;
use RegexParser\Lint\RegexPatternSourceCollection;
use RegexParser\Lint\TokenBasedExtractionStrategy;
use RegexParser\NodeVisitor\ConsoleHighlighterVisitor;
use RegexParser\NodeVisitor\HtmlHighlighterVisitor;
use RegexParser\OptimizationResult;
use RegexParser\Regex;

// ANSI color codes
const RESET = "\033[0m";
const RED = "\033[31m";
const GREEN = "\033[32m";
const YELLOW = "\033[33m";
const BLUE = "\033[34m";
const MAGENTA = "\033[35m";
const CYAN = "\033[36m";
const WHITE = "\033[37m";
const GRAY = "\033[90m";
const BLACK = "\033[30m";
const BOLD = "\033[1m";
const BG_RED = "\033[41m";
const BG_GREEN = "\033[42m";
const BG_YELLOW = "\033[43m";
const BG_BLUE = "\033[44m";
const BG_CYAN = "\033[46m";
const BG_GRAY = "\033[100m";
const PROGRESS_BAR_WIDTH = 28;
const PROGRESS_BAR_FULL = "▓";
const PROGRESS_BAR_EMPTY = "░";

function color(string $text, string $color): string
{
    global $ansi;

    return $ansi ? $color.$text.RESET : $text;
}

function success(string $text): string
{
    return color($text, GREEN);
}

function error(string $text): string
{
    return color($text, RED);
}

function warning(string $text): string
{
    return color($text, YELLOW);
}

function info(string $text): string
{
    return color($text, BLUE);
}

function bold(string $text): string
{
    return color($text, BOLD);
}

function dim(string $text): string
{
    return color($text, GRAY);
}

function badge(string $text, string $fg, string $bg): string
{
    global $ansi;

    if (!$ansi) {
        return '['.$text.']';
    }

    return color(' '.$text.' ', $bg.$fg.BOLD);
}

function output(string $text): void
{
    global $quiet;

    if (!$quiet) {
        echo $text;
    }
}

function formatElapsed(int $seconds): string
{
    $seconds = max(0, $seconds);
    $hours = intdiv($seconds, 3600);
    $minutes = intdiv($seconds % 3600, 60);
    $secs = $seconds % 60;

    if ($hours > 0) {
        return \sprintf('%02d:%02d:%02d', $hours, $minutes, $secs);
    }

    return \sprintf('%02d:%02d', $minutes, $secs);
}

function progressStart(int $total): void
{
    global $progressTotal, $progressCurrent, $progressActive, $progressStartedAt, $ansi, $quiet;

    if ($total <= 0 || $quiet) {
        $progressActive = false;

        return;
    }

    $progressTotal = $total;
    $progressCurrent = 0;
    $progressActive = $ansi;
    $progressStartedAt = \time();

    if (!$progressActive) {
        return;
    }

    renderProgress();
}

function progressAdvance(int $step = 1): void
{
    global $progressTotal, $progressCurrent, $progressActive;

    if (!$progressActive) {
        return;
    }

    $progressCurrent = min($progressTotal, $progressCurrent + $step);
    renderProgress();
}

function progressFinish(): void
{
    global $progressTotal, $progressCurrent, $progressActive;

    if (!$progressActive) {
        return;
    }

    $progressCurrent = $progressTotal;
    renderProgress(true);
    $progressActive = false;
}

function renderProgress(bool $finish = false): void
{
    global $progressTotal, $progressCurrent, $progressStartedAt;

    $total = max(1, (int) $progressTotal);
    $current = min((int) $progressCurrent, $total);
    $ratio = $current / $total;
    $filled = (int) floor($ratio * PROGRESS_BAR_WIDTH);

    $bar = str_repeat(PROGRESS_BAR_FULL, $filled).str_repeat(PROGRESS_BAR_EMPTY, PROGRESS_BAR_WIDTH - $filled);
    $percent = (int) round($ratio * 100);
    $elapsed = formatElapsed((int) (\time() - (int) $progressStartedAt));
    $line = \sprintf(' %d/%d [%s] %3d%% %8s', $current, $total, $bar, $percent, $elapsed);

    output("\r".$line);

    if ($finish) {
        output("\n\n");
    }

    if (\function_exists('fflush')) {
        fflush(\STDOUT);
    }
}

function showHelp(): void
{
    output(color('Regex Parser', CYAN)."\n");
    output(color(str_repeat('=', 12), CYAN)."\n\n");

    output(color('Description:', MAGENTA)."\n");
    output('  '.bold('CLI for regex parsing, validation, analysis, and linting')."\n\n");

    output(color('Usage:', MAGENTA)."\n");
    output('  regex '.color('<command>', YELLOW).' '.color('[options]', CYAN).' '.color('<pattern>', GREEN)."\n\n");

    output(color('Commands:', MAGENTA)."\n");
    output('  '.info('parse')."       Parse and recompile a regex pattern\n");
    output('  '.info('analyze')."     Parse, validate, and analyze ReDoS risk\n");
    output('  '.info('highlight')."   Highlight a regex for display\n");
    output('  '.info('validate')."    Validate a regex pattern\n");
    output('  '.info('lint')."        Lint regex patterns in PHP source code\n");
    output('  '.info('help')."        Display this help message\n\n");

    output(color('Global Options:', MAGENTA)."\n");
    output('  '.color('--ansi', CYAN)."            Force ANSI output\n");
    output('  '.color('--no-ansi', CYAN)."         Disable ANSI output\n");
    output('  '.color('-q, --quiet', CYAN)."       Suppress output\n");
    output('  '.color('--silent', CYAN)."          Same as --quiet\n");
    output('  '.color('--help', CYAN)."            Display this help message\n\n");

    output(color('Lint Options:', MAGENTA)."\n");
    output('  '.color('--exclude', CYAN)." <path>       Paths to exclude (repeatable)\n");
    output('  '.color('--min-savings', CYAN)." <n>     Minimum optimization savings\n");
    output('  '.color('--format', CYAN)." <format>     Output format (console, json, github, checkstyle, junit)\n");
    output('  '.color('--no-redos', CYAN)."           Skip ReDoS risk analysis\n");
    output('  '.color('--no-validate', CYAN)."        Skip validation errors (structural lint only)\n");
    output('  '.color('--no-optimize', CYAN)."        Disable optimization suggestions\n");
    output('  '.color('-v, --verbose', CYAN)."         Show detailed output\n");
    output('  '.color('--debug', CYAN)."              Show debug information\n\n");

    output(color('Examples:', MAGENTA)."\n");
    output('  '.color('regex', BLUE).' '.color("'/a+'", GREEN)."                           # Quick highlight\n");
    output('  '.color('regex', BLUE).' '.color('parse', YELLOW).' '.color("'/a+'", GREEN).' '.color('--validate', CYAN)."          # Parse with validation\n");
    output('  '.color('regex', BLUE).' '.color('analyze', YELLOW).' '.color("'/a+'", GREEN)."                   # Full analysis\n");
    output('  '.color('regex', BLUE).' '.color('highlight', YELLOW).' '.color("'/a+'", GREEN).' '.color('--format=html', CYAN)."   # HTML highlight\n");
    output('  '.color('regex', BLUE).' '.color('lint', YELLOW).' '.color('src/', GREEN).' '.color('--exclude=vendor', CYAN)."       # Lint a codebase\n");
    output('  '.color('regex', BLUE).' '.color('lint', YELLOW).' '.color('--format=json', CYAN).' '.color('src/', GREEN)."           # JSON output\n");
    output('  '.color('regex', BLUE).' '.color('lint', YELLOW).' '.color('--verbose', CYAN).' '.color('src/', GREEN)."              # Verbose output\n");
}

function extractGlobalOptions(array $args): array
{
    $options = [
        'quiet' => false,
        'ansi' => null,
        'help' => false,
    ];
    $remaining = [];

    foreach ($args as $arg) {
        if ('-q' === $arg || '--quiet' === $arg || '--silent' === $arg) {
            $options['quiet'] = true;

            continue;
        }

        if ('--ansi' === $arg) {
            $options['ansi'] = true;

            continue;
        }

        if ('--no-ansi' === $arg) {
            $options['ansi'] = false;

            continue;
        }

        if ('--help' === $arg || '-h' === $arg) {
            $options['help'] = true;

            continue;
        }

        $remaining[] = $arg;
    }

    return [$options, $remaining];
}

function resolveAnsi(?bool $forced): bool
{
    if (null !== $forced) {
        return $forced;
    }

    return \function_exists('posix_isatty') && posix_isatty(\STDOUT);
}

function relativePath(string $path): string
{
    $normalizedPath = str_replace('\\', '/', $path);
    $cwd = getcwd();
    if (false === $cwd) {
        return $normalizedPath;
    }

    $normalizedCwd = rtrim(str_replace('\\', '/', $cwd), '/');
    if ('' === $normalizedCwd) {
        return $normalizedPath;
    }

    $prefix = $normalizedCwd.'/';
    if (str_starts_with($normalizedPath, $prefix)) {
        return substr($normalizedPath, \strlen($prefix));
    }

    return $normalizedPath;
}

function renderSummary(array $stats, bool $isEmpty = false): void
{
    output("\n");

    if ($isEmpty) {
        output('  '.badge('PASS', WHITE, BG_GREEN).' '.dim('No regex patterns found.')."\n");
        showFooter();

        return;
    }

    $errors = $stats['errors'];
    $warnings = $stats['warnings'];
    $optimizations = $stats['optimizations'];

    if ($errors > 0) {
        output('  '.badge('FAIL', WHITE, BG_RED).' '.color(\sprintf('%d invalid patterns', $errors), RED.BOLD)
            .dim(\sprintf(', %d warnings, %d optimizations.', $warnings, $optimizations))
            ."\n");
    } elseif ($warnings > 0) {
        output('  '.badge('PASS', BLACK, BG_YELLOW).' '.color(\sprintf('%d warnings found', $warnings), YELLOW.BOLD)
            .dim(\sprintf(', %d optimizations available.', $optimizations))
            ."\n");
    } else {
        output('  '.badge('PASS', WHITE, BG_GREEN).' '.color('No issues found', GREEN.BOLD)
            .dim(\sprintf(', %d optimizations available.', $optimizations))
            ."\n");
    }

    showFooter();
}

function showFooter(): void
{
    output("\n");
    output('  '.dim('Star the repo: https://github.com/yoeunes/regex-parser')."\n\n");
}

function renderLintBanner(): string
{
    return color('Regex Parser', CYAN.BOLD).' '.dim('· lint')."\n\n";
}

function createExtractor(): RegexPatternExtractor
{
    $parserFactoryClass = \PhpParser\ParserFactory::class;

    if (class_exists($parserFactoryClass)) {
        return new RegexPatternExtractor(new PhpStanExtractionStrategy());
    }

    return new RegexPatternExtractor(new TokenBasedExtractionStrategy());
}

function parseLintArgs(array $args): array
{
    $paths = [];
    $exclude = [];
    $minSavings = 1;
    $verbosity = OutputConfiguration::VERBOSITY_NORMAL;
    $format = 'console';
    $quiet = false;
    $checkRedos = true;
    $checkValidation = true;
    $checkOptimizations = true;

    for ($i = 0; $i < \count($args); $i++) {
        $arg = $args[$i];

        if ('--help' === $arg || '-h' === $arg) {
            return ['help' => true];
        }

        if ('--quiet' === $arg || '-q' === $arg) {
            $quiet = true;
            $verbosity = OutputConfiguration::VERBOSITY_QUIET;

            continue;
        }

        if ('--verbose' === $arg || '-v' === $arg) {
            $verbosity = OutputConfiguration::VERBOSITY_VERBOSE;

            continue;
        }

        if ('--debug' === $arg) {
            $verbosity = OutputConfiguration::VERBOSITY_DEBUG;

            continue;
        }

        if ('--no-redos' === $arg) {
            $checkRedos = false;

            continue;
        }

        if ('--no-validate' === $arg) {
            $checkValidation = false;

            continue;
        }

        if ('--no-optimize' === $arg) {
            $checkOptimizations = false;

            continue;
        }

        if (str_starts_with($arg, '--format=')) {
            $format = substr($arg, \strlen('--format='));

            continue;
        }

        if ('--format' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --format.'];
            }
            $format = $value;
            $i++;

            continue;
        }

        if (str_starts_with($arg, '--exclude=')) {
            $exclude[] = substr($arg, \strlen('--exclude='));

            continue;
        }

        if ('--exclude' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --exclude.'];
            }
            $exclude[] = $value;
            $i++;

            continue;
        }

        if (str_starts_with($arg, '--min-savings=')) {
            $minSavings = (int) substr($arg, \strlen('--min-savings='));

            continue;
        }

        if ('--min-savings' === $arg) {
            $value = $args[$i + 1] ?? '';
            if ('' === $value || str_starts_with($value, '-')) {
                return ['error' => 'Missing value for --min-savings.'];
            }
            $minSavings = (int) $value;
            $i++;

            continue;
        }

        if (str_starts_with($arg, '-')) {
            return ['error' => 'Unknown option: '.$arg];
        }

        $paths[] = $arg;
    }

    return [
        'paths' => $paths,
        'exclude' => $exclude,
        'minSavings' => $minSavings,
        'verbosity' => $verbosity,
        'format' => $format,
        'quiet' => $quiet,
        'checkRedos' => $checkRedos,
        'checkValidation' => $checkValidation,
        'checkOptimizations' => $checkOptimizations,
    ];
}

$args = $argv;
array_shift($args);
[$globalOptions, $args] = extractGlobalOptions($args);
$quiet = $globalOptions['quiet'];
$ansi = resolveAnsi($globalOptions['ansi']);

if ($globalOptions['help']) {
    showHelp();
    exit(0);
}

if ([] === $args) {
    showHelp();
    exit(1);
}

$command = $args[0] ?? null;
$commandArgs = \array_slice($args, 1);

$pattern = '';
if (str_starts_with($command, '/')) {
    $pattern = $command;
    $command = 'highlight';
} else {
    $pattern = $commandArgs[0] ?? '';
}

switch ($command) {
    case 'help':
    case '--help':
    case '-h':
        showHelp();
        exit(0);

    case 'parse':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex parse <pattern> [--validate]\n");
            exit(1);
        }
        $validate = \in_array('--validate', $commandArgs, true);
        $regex = Regex::create();

        try {
            $ast = $regex->parse($pattern);
            $compiled = $ast->accept(new RegexParser\NodeVisitor\CompilerNodeVisitor());

            output(bold("Parse\n"));
            output('  Pattern:    '.$pattern."\n");
            output('  Recompiled: '.$compiled."\n");

            if ($validate) {
                $validation = $regex->validate($pattern);
                $status = $validation->isValid ? success('OK') : error('INVALID');
                output('  Validation: '.$status."\n");
                if (!$validation->isValid && $validation->error) {
                    output('  '.error($validation->error)."\n");
                }
            }
        } catch (LexerException|ParserException $e) {
            output(error('Parse failed: '.$e->getMessage()."\n"));
            exit(1);
        }

        break;

    case 'analyze':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex analyze <pattern>\n");
            exit(1);
        }
        $regex = Regex::create();

        try {
            $ast = $regex->parse($pattern);
            $validation = $regex->validate($pattern);
            $analysis = $regex->redos($pattern);
            $explain = $regex->explain($pattern);

            output(bold("Analyze\n"));
            output('  Pattern:    '.$pattern."\n");
            output('  Parse:      '.success('OK')."\n");
            $validationStatus = $validation->isValid ? success('OK') : error('INVALID');
            output('  Validation: '.$validationStatus."\n");
            if (!$validation->isValid && $validation->error) {
                output('  '.error($validation->error)."\n");
            }

            $severityLabel = strtoupper($analysis->severity->value);
            output('  ReDoS:      '.warning($severityLabel).' (score '.$analysis->score.")\n");
            if ($analysis->error) {
                output('  '.error('ReDoS error: '.$analysis->error)."\n");
            }

            output("\n".bold('Explanation')."\n");
            output($explain."\n");
        } catch (LexerException|ParserException $e) {
            output(error('Analyze failed: '.$e->getMessage()."\n"));
            exit(1);
        }

        break;

    case 'highlight':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex highlight <pattern> [--format=auto|cli|html]\n");
            exit(1);
        }
        $format = 'auto';
        for ($i = 0; $i < \count($commandArgs); $i++) {
            $arg = $commandArgs[$i];
            if (str_starts_with($arg, '--format=')) {
                $format = substr($arg, 9);

                break;
            }
            if ('--format' === $arg) {
                $format = $commandArgs[$i + 1] ?? $format;
                $i++;
            }
        }
        $regex = Regex::create();

        try {
            if ('auto' === $format) {
                $format = \PHP_SAPI === 'cli' ? 'cli' : 'html';
            }

            $visitor = match ($format) {
                'cli' => new ConsoleHighlighterVisitor(),
                'html' => new HtmlHighlighterVisitor(),
                default => throw new \InvalidArgumentException("Invalid format: $format"),
            };

            $ast = $regex->parse($pattern);
            $highlighted = $ast->accept($visitor);

            output($highlighted."\n");
        } catch (LexerException|ParserException $e) {
            output(error("✗ Error: {$e->getMessage()}\n"));
            exit(1);
        }

        break;

    case 'validate':
        if (empty($pattern)) {
            output(error("Error: Missing pattern\n"));
            output("Usage: regex validate <pattern>\n");
            exit(1);
        }
        $regex = Regex::create();

        $validation = $regex->validate($pattern);
        if ($validation->isValid) {
            output(success('OK').'  '.$pattern."\n");
            break;
        }

        output(error('INVALID').'  '.$pattern."\n");
        if ($validation->error) {
            output('  '.error($validation->error)."\n");
        }

        exit(1);

        break;

    case 'lint':
        $parsed = parseLintArgs($commandArgs);
        if (isset($parsed['help'])) {
            showHelp();
            exit(0);
        }
        if (isset($parsed['error'])) {
            output(error('Error: '.$parsed['error']."\n"));
            output("Usage: regex lint [paths...] [--exclude <path>] [--min-savings <n>] [--format console|json|github|checkstyle|junit] [--no-redos] [--no-validate] [--no-optimize] [--verbose|--debug|--quiet]\n");
            exit(1);
        }

        $paths = $parsed['paths'] ?? [];
        $exclude = $parsed['exclude'] ?? [];
        $minSavings = (int) ($parsed['minSavings'] ?? 1);
        $verbosity = $parsed['verbosity'] ?? OutputConfiguration::VERBOSITY_NORMAL;
        $format = $parsed['format'] ?? 'console';
        $quiet = $parsed['quiet'] ?? false;
        $checkRedos = $parsed['checkRedos'] ?? true;
        $checkValidation = $parsed['checkValidation'] ?? true;
        $checkOptimizations = $parsed['checkOptimizations'] ?? true;

        if ([] === $paths) {
            $paths = ['.'];
        }
        if ([] === $exclude) {
            $exclude = ['vendor'];
        }

        // Create output configuration
        $config = match ($verbosity) {
            OutputConfiguration::VERBOSITY_QUIET => OutputConfiguration::quiet(),
            OutputConfiguration::VERBOSITY_VERBOSE => OutputConfiguration::verbose(),
            OutputConfiguration::VERBOSITY_DEBUG => OutputConfiguration::debug(),
            default => new OutputConfiguration(ansi: $ansi),
        };

        // Get formatter
        $formatterRegistry = new FormatterRegistry();
        if (!$formatterRegistry->has($format)) {
            output(error(\sprintf('Unknown format: %s. Available formats: %s', $format, implode(', ', $formatterRegistry->getNames()))."\n"));
            exit(1);
        }
        $formatter = $formatterRegistry->get($format);

        // Update console formatter with analysis service for highlighting
        if ('console' === $format) {
            $analysis = new RegexAnalysisService(Regex::create());
            $formatter = new ConsoleFormatter($analysis, $config);
        }

        $analysis = new RegexAnalysisService(Regex::create());
        $extractor = createExtractor();
        $sources = new RegexPatternSourceCollection([
            new PhpRegexPatternSource($extractor),
        ]);
        $lint = new RegexLintService($analysis, $sources);

        if ('console' === $format && OutputConfiguration::VERBOSITY_QUIET !== $verbosity) {
            echo renderLintBanner();
        }

        $collectionProgress = null;
        if ('console' === $format && $config->shouldShowProgress()) {
            output('  '.dim('[1/2] Collecting patterns')."\n");
            $collectionStarted = false;
            $lastCount = 0;
            $collectionProgress = static function (int $current, int $total) use (&$collectionStarted, &$lastCount): void {
                if ($total <= 0) {
                    return;
                }

                if (!$collectionStarted) {
                    progressStart($total);
                    $collectionStarted = true;
                }

                $advance = $current - $lastCount;
                if ($advance > 0) {
                    progressAdvance($advance);
                    $lastCount = $current;
                }

                if ($collectionStarted && $current >= $total) {
                    progressFinish();
                }
            };
        }

        try {
            $request = new RegexLintRequest(
                paths: $paths,
                excludePaths: $exclude,
                minSavings: $minSavings,
                checkValidation: $checkValidation,
                checkRedos: $checkRedos,
                checkOptimizations: $checkOptimizations,
            );
            $patterns = $lint->collectPatterns($request, $collectionProgress);
        } catch (Throwable $e) {
            output(error("Failed to collect patterns: {$e->getMessage()}\n"));
            exit(1);
        }

        if ([] === $patterns) {
            if ($format === 'console') {
                renderSummary(['errors' => 0, 'warnings' => 0, 'optimizations' => 0], true);
                exit(0);
            }

            $emptyReport = new \RegexParser\Lint\RegexLintReport([], ['errors' => 0, 'warnings' => 0, 'optimizations' => 0]);
            echo $formatter->format($emptyReport);
            exit(0);
        }

        $startTime = microtime(true);
        $startMemory = memory_get_peak_usage(true);

        $progressCallback = null;
        if ('console' === $format && $config->shouldShowProgress()) {
            output('  '.dim('[2/2] Analyzing patterns')."\n");
            progressStart(\count($patterns));
            $progressCallback = static fn () => progressAdvance();
        }

        $report = $lint->analyze($patterns, $request, $progressCallback);

        if (null !== $progressCallback) {
            progressFinish();
        }

        // Output using formatter
        echo $formatter->format($report);
        echo $formatter->getSummary($report->stats);
        $elapsed = microtime(true) - $startTime;
        $peakMemory = memory_get_peak_usage(true);
        output("  ".bold("Time: ".round($elapsed, 2)."s | Memory: ".round($peakMemory / 1024 / 1024, 2)." MB")."\n");
        output("\n");
        echo $formatter->formatFooter();

        exit($report->stats['errors'] > 0 ? 1 : 0);

    default:
        output(error("Unknown command: {$command}\n\n"));
        showHelp();
        exit(1);
}
